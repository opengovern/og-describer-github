// Code is generated by go generate. DO NOT EDIT.
package opengovernance

import (
	"context"
	github "github.com/opengovern/og-describer-github/provider/model"
	essdk "github.com/opengovern/og-util/pkg/opengovernance-es-sdk"
	steampipesdk "github.com/opengovern/og-util/pkg/steampipe"
	"github.com/turbot/steampipe-plugin-sdk/v5/plugin"
	"runtime"
)

type Client struct {
	essdk.Client
}

// ==========================  START: Artifact =============================

type Artifact struct {
	ResourceID      string                     `json:"resource_id"`
	PlatformID      string                     `json:"platform_id"`
	Description     github.ArtifactDescription `json:"description"`
	Metadata        github.Metadata            `json:"metadata"`
	DescribedBy     string                     `json:"described_by"`
	ResourceType    string                     `json:"resource_type"`
	IntegrationType string                     `json:"integration_type"`
	IntegrationID   string                     `json:"integration_id"`
}

type ArtifactHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Artifact      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ArtifactHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []ArtifactHit     `json:"hits"`
}

type ArtifactSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  ArtifactHits `json:"hits"`
}

type ArtifactPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewArtifactPaginator(filters []essdk.BoolFilter, limit *int64) (ArtifactPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_actions_artifact", filters, limit)
	if err != nil {
		return ArtifactPaginator{}, err
	}

	p := ArtifactPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ArtifactPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ArtifactPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ArtifactPaginator) NextPage(ctx context.Context) ([]Artifact, error) {
	var response ArtifactSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Artifact
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listArtifactFilters = map[string]string{
	"archive_download_url": "description.ArchiveDownloadURL",
	"expired":              "description.Expired",
	"id":                   "description.ID",
	"name":                 "description.Name",
	"node_id":              "description.NodeID",
	"repository_full_name": "description.RepoFullName",
	"size_in_bytes":        "description.SizeInBytes",
}

func ListArtifact(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListArtifact")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListArtifact NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListArtifact NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListArtifact GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListArtifact GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListArtifact GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewArtifactPaginator(essdk.BuildFilter(ctx, d.QueryContext, listArtifactFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListArtifact NewArtifactPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListArtifact paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getArtifactFilters = map[string]string{
	"archive_download_url": "description.ArchiveDownloadURL",
	"expired":              "description.Expired",
	"id":                   "description.ID",
	"name":                 "description.Name",
	"node_id":              "description.NodeID",
	"repository_full_name": "description.RepoFullName",
	"size_in_bytes":        "description.SizeInBytes",
}

func GetArtifact(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetArtifact")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewArtifactPaginator(essdk.BuildFilter(ctx, d.QueryContext, getArtifactFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Artifact =============================

// ==========================  START: Runner =============================

type Runner struct {
	ResourceID      string                   `json:"resource_id"`
	PlatformID      string                   `json:"platform_id"`
	Description     github.RunnerDescription `json:"description"`
	Metadata        github.Metadata          `json:"metadata"`
	DescribedBy     string                   `json:"described_by"`
	ResourceType    string                   `json:"resource_type"`
	IntegrationType string                   `json:"integration_type"`
	IntegrationID   string                   `json:"integration_id"`
}

type RunnerHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Runner        `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type RunnerHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []RunnerHit       `json:"hits"`
}

type RunnerSearchResponse struct {
	PitID string     `json:"pit_id"`
	Hits  RunnerHits `json:"hits"`
}

type RunnerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRunnerPaginator(filters []essdk.BoolFilter, limit *int64) (RunnerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_actions_runner", filters, limit)
	if err != nil {
		return RunnerPaginator{}, err
	}

	p := RunnerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RunnerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RunnerPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RunnerPaginator) NextPage(ctx context.Context) ([]Runner, error) {
	var response RunnerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Runner
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRunnerFilters = map[string]string{
	"busy":                 "description.Busy",
	"id":                   "description.ID",
	"labels":               "description.Labels",
	"name":                 "description.Name",
	"os":                   "description.OS",
	"repository_full_name": "description.RepoFullName",
	"status":               "description.Status",
}

func ListRunner(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRunner")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRunner NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRunner NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRunner GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRunner GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRunner GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRunnerPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRunnerFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRunner NewRunnerPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRunner paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRunnerFilters = map[string]string{
	"busy":                 "description.Busy",
	"id":                   "description.ID",
	"labels":               "description.Labels",
	"name":                 "description.Name",
	"os":                   "description.OS",
	"repository_full_name": "description.RepoFullName",
	"status":               "description.Status",
}

func GetRunner(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRunner")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRunnerPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRunnerFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Runner =============================

// ==========================  START: Secret =============================

type Secret struct {
	ResourceID      string                   `json:"resource_id"`
	PlatformID      string                   `json:"platform_id"`
	Description     github.SecretDescription `json:"description"`
	Metadata        github.Metadata          `json:"metadata"`
	DescribedBy     string                   `json:"described_by"`
	ResourceType    string                   `json:"resource_type"`
	IntegrationType string                   `json:"integration_type"`
	IntegrationID   string                   `json:"integration_id"`
}

type SecretHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Secret        `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type SecretHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []SecretHit       `json:"hits"`
}

type SecretSearchResponse struct {
	PitID string     `json:"pit_id"`
	Hits  SecretHits `json:"hits"`
}

type SecretPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSecretPaginator(filters []essdk.BoolFilter, limit *int64) (SecretPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_actions_secret", filters, limit)
	if err != nil {
		return SecretPaginator{}, err
	}

	p := SecretPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SecretPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SecretPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SecretPaginator) NextPage(ctx context.Context) ([]Secret, error) {
	var response SecretSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Secret
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSecretFilters = map[string]string{
	"name":                      "description.Name",
	"repository_full_name":      "description.RepoFullName",
	"selected_repositories_url": "description.SelectedRepositoriesURL",
	"visibility":                "description.Visibility",
}

func ListSecret(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSecret")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecret NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecret NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecret GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecret GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecret GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSecretPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSecretFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecret NewSecretPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSecret paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSecretFilters = map[string]string{
	"name":                      "description.Name",
	"repository_full_name":      "description.RepoFullName",
	"selected_repositories_url": "description.SelectedRepositoriesURL",
	"visibility":                "description.Visibility",
}

func GetSecret(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSecret")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSecretPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSecretFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Secret =============================

// ==========================  START: WorkflowRun =============================

type WorkflowRun struct {
	ResourceID      string                        `json:"resource_id"`
	PlatformID      string                        `json:"platform_id"`
	Description     github.WorkflowRunDescription `json:"description"`
	Metadata        github.Metadata               `json:"metadata"`
	DescribedBy     string                        `json:"described_by"`
	ResourceType    string                        `json:"resource_type"`
	IntegrationType string                        `json:"integration_type"`
	IntegrationID   string                        `json:"integration_id"`
}

type WorkflowRunHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  WorkflowRun   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type WorkflowRunHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []WorkflowRunHit  `json:"hits"`
}

type WorkflowRunSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  WorkflowRunHits `json:"hits"`
}

type WorkflowRunPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWorkflowRunPaginator(filters []essdk.BoolFilter, limit *int64) (WorkflowRunPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_actions_workflowrun", filters, limit)
	if err != nil {
		return WorkflowRunPaginator{}, err
	}

	p := WorkflowRunPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WorkflowRunPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WorkflowRunPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p WorkflowRunPaginator) NextPage(ctx context.Context) ([]WorkflowRun, error) {
	var response WorkflowRunSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []WorkflowRun
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWorkflowRunFilters = map[string]string{
	"actor":                "description.Actor",
	"artifact_count":       "description.ArtifactCount",
	"artifacts":            "description.Artifacts",
	"conclusion":           "description.Conclusion",
	"created_at":           "description.CreatedAt",
	"event":                "description.Event",
	"head_branch":          "description.HeadBranch",
	"head_commit":          "description.HeadCommit",
	"head_repository":      "description.HeadRepository",
	"head_sha":             "description.HeadSHA",
	"html_url":             "description.HTMLURL",
	"id":                   "description.ID",
	"name":                 "description.Name",
	"referenced_workflows": "description.ReferencedWorkflows",
	"repository":           "description.Repository",
	"run_attempt":          "description.RunAttempt",
	"run_number":           "description.RunNumber",
	"run_started_at":       "description.RunStartedAt",
	"status":               "description.Status",
	"updated_at":           "description.UpdatedAt",
	"workflow_id":          "description.WorkflowID",
}

func ListWorkflowRun(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWorkflowRun")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkflowRun NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkflowRun NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkflowRun GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkflowRun GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkflowRun GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewWorkflowRunPaginator(essdk.BuildFilter(ctx, d.QueryContext, listWorkflowRunFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkflowRun NewWorkflowRunPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListWorkflowRun paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getWorkflowRunFilters = map[string]string{
	"actor":                "description.Actor",
	"artifact_count":       "description.ArtifactCount",
	"artifacts":            "description.Artifacts",
	"conclusion":           "description.Conclusion",
	"created_at":           "description.CreatedAt",
	"event":                "description.Event",
	"head_branch":          "description.HeadBranch",
	"head_commit":          "description.HeadCommit",
	"head_repository":      "description.HeadRepository",
	"head_sha":             "description.HeadSHA",
	"html_url":             "description.HTMLURL",
	"id":                   "description.ID",
	"name":                 "description.Name",
	"referenced_workflows": "description.ReferencedWorkflows",
	"repository":           "description.Repository",
	"run_attempt":          "description.RunAttempt",
	"run_number":           "description.RunNumber",
	"run_started_at":       "description.RunStartedAt",
	"status":               "description.Status",
	"updated_at":           "description.UpdatedAt",
	"workflow_id":          "description.WorkflowID",
}

func GetWorkflowRun(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWorkflowRun")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewWorkflowRunPaginator(essdk.BuildFilter(ctx, d.QueryContext, getWorkflowRunFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: WorkflowRun =============================

// ==========================  START: Branch =============================

type Branch struct {
	ResourceID      string                   `json:"resource_id"`
	PlatformID      string                   `json:"platform_id"`
	Description     github.BranchDescription `json:"description"`
	Metadata        github.Metadata          `json:"metadata"`
	DescribedBy     string                   `json:"described_by"`
	ResourceType    string                   `json:"resource_type"`
	IntegrationType string                   `json:"integration_type"`
	IntegrationID   string                   `json:"integration_id"`
}

type BranchHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Branch        `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type BranchHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []BranchHit       `json:"hits"`
}

type BranchSearchResponse struct {
	PitID string     `json:"pit_id"`
	Hits  BranchHits `json:"hits"`
}

type BranchPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewBranchPaginator(filters []essdk.BoolFilter, limit *int64) (BranchPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_branch", filters, limit)
	if err != nil {
		return BranchPaginator{}, err
	}

	p := BranchPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p BranchPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p BranchPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p BranchPaginator) NextPage(ctx context.Context) ([]Branch, error) {
	var response BranchSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Branch
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listBranchFilters = map[string]string{
	"branch_protection_rule": "description.BranchProtectionRule",
	"commit":                 "description.Commit",
	"name":                   "description.Name",
	"protected":              "description.Protected",
	"repository_full_name":   "description.RepoFullName",
}

func ListBranch(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListBranch")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListBranch NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListBranch NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListBranch GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListBranch GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListBranch GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewBranchPaginator(essdk.BuildFilter(ctx, d.QueryContext, listBranchFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListBranch NewBranchPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListBranch paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getBranchFilters = map[string]string{
	"branch_protection_rule": "description.BranchProtectionRule",
	"commit":                 "description.Commit",
	"name":                   "description.Name",
	"protected":              "description.Protected",
	"repository_full_name":   "description.RepoFullName",
}

func GetBranch(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetBranch")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewBranchPaginator(essdk.BuildFilter(ctx, d.QueryContext, getBranchFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Branch =============================

// ==========================  START: BranchProtection =============================

type BranchProtection struct {
	ResourceID      string                             `json:"resource_id"`
	PlatformID      string                             `json:"platform_id"`
	Description     github.BranchProtectionDescription `json:"description"`
	Metadata        github.Metadata                    `json:"metadata"`
	DescribedBy     string                             `json:"described_by"`
	ResourceType    string                             `json:"resource_type"`
	IntegrationType string                             `json:"integration_type"`
	IntegrationID   string                             `json:"integration_id"`
}

type BranchProtectionHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  BranchProtection `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type BranchProtectionHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []BranchProtectionHit `json:"hits"`
}

type BranchProtectionSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  BranchProtectionHits `json:"hits"`
}

type BranchProtectionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewBranchProtectionPaginator(filters []essdk.BoolFilter, limit *int64) (BranchProtectionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_branch_protection", filters, limit)
	if err != nil {
		return BranchProtectionPaginator{}, err
	}

	p := BranchProtectionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p BranchProtectionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p BranchProtectionPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p BranchProtectionPaginator) NextPage(ctx context.Context) ([]BranchProtection, error) {
	var response BranchProtectionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []BranchProtection
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listBranchProtectionFilters = map[string]string{
	"allows_deletions":                    "description.AllowsDeletions",
	"allows_force_pushes":                 "description.AllowsForcePushes",
	"blocks_creations":                    "description.BlocksCreations",
	"bypass_force_push_allowance_apps":    "description.BypassForcePushAllowanceApps",
	"bypass_force_push_allowance_teams":   "description.BypassForcePushAllowanceTeams",
	"bypass_force_push_allowance_users":   "description.BypassForcePushAllowanceUsers",
	"bypass_pull_request_allowance_apps":  "description.BypassPullRequestAllowanceApps",
	"bypass_pull_request_allowance_teams": "description.BypassPullRequestAllowanceTeams",
	"bypass_pull_request_allowance_users": "description.BypassPullRequestAllowanceUsers",
	"creator_login":                       "description.CreatorLogin",
	"dismisses_stale_reviews":             "description.DismissesStaleReviews",
	"id":                                  "description.Id",
	"is_admin_enforced":                   "description.IsAdminEnforced",
	"lock_allows_fetch_and_merge":         "description.LockAllowsFetchAndMerge",
	"lock_branch":                         "description.LockBranch",
	"matching_branches":                   "description.MatchingBranches",
	"node_id":                             "description.NodeId",
	"pattern":                             "description.Pattern",
	"push_allowance_apps":                 "description.PushAllowanceApps",
	"push_allowance_teams":                "description.PushAllowanceTeams",
	"push_allowance_users":                "description.PushAllowanceUsers",
	"repository_full_name":                "description.RepoFullName",
	"require_last_push_approval":          "description.RequireLastPushApproval",
	"required_approving_review_count":     "description.RequiredApprovingReviewCount",
	"required_deployment_environments":    "description.RequiredDeploymentEnvironments",
	"required_status_checks":              "description.RequiredStatusChecks",
	"requires_approving_reviews":          "description.RequiresApprovingReviews",
	"requires_code_owner_reviews":         "description.RequiresCodeOwnerReviews",
	"requires_commit_signatures":          "description.RequiresCommitSignatures",
	"requires_conversation_resolution":    "description.RequiresConversationResolution",
	"requires_deployments":                "description.RequiresDeployments",
	"requires_linear_history":             "description.RequiresLinearHistory",
	"requires_status_checks":              "description.RequiresStatusChecks",
	"requires_strict_status_checks":       "description.RequiresStrictStatusChecks",
	"restricts_pushes":                    "description.RestrictsPushes",
	"restricts_review_dismissals":         "description.RestrictsReviewDismissals",
}

func ListBranchProtection(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListBranchProtection")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListBranchProtection NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListBranchProtection NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListBranchProtection GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListBranchProtection GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListBranchProtection GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewBranchProtectionPaginator(essdk.BuildFilter(ctx, d.QueryContext, listBranchProtectionFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListBranchProtection NewBranchProtectionPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListBranchProtection paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getBranchProtectionFilters = map[string]string{
	"allows_deletions":                    "description.AllowsDeletions",
	"allows_force_pushes":                 "description.AllowsForcePushes",
	"blocks_creations":                    "description.BlocksCreations",
	"bypass_force_push_allowance_apps":    "description.BypassForcePushAllowanceApps",
	"bypass_force_push_allowance_teams":   "description.BypassForcePushAllowanceTeams",
	"bypass_force_push_allowance_users":   "description.BypassForcePushAllowanceUsers",
	"bypass_pull_request_allowance_apps":  "description.BypassPullRequestAllowanceApps",
	"bypass_pull_request_allowance_teams": "description.BypassPullRequestAllowanceTeams",
	"bypass_pull_request_allowance_users": "description.BypassPullRequestAllowanceUsers",
	"creator_login":                       "description.CreatorLogin",
	"dismisses_stale_reviews":             "description.DismissesStaleReviews",
	"id":                                  "description.Id",
	"is_admin_enforced":                   "description.IsAdminEnforced",
	"lock_allows_fetch_and_merge":         "description.LockAllowsFetchAndMerge",
	"lock_branch":                         "description.LockBranch",
	"matching_branches":                   "description.MatchingBranches",
	"node_id":                             "description.NodeId",
	"pattern":                             "description.Pattern",
	"push_allowance_apps":                 "description.PushAllowanceApps",
	"push_allowance_teams":                "description.PushAllowanceTeams",
	"push_allowance_users":                "description.PushAllowanceUsers",
	"repository_full_name":                "description.RepoFullName",
	"require_last_push_approval":          "description.RequireLastPushApproval",
	"required_approving_review_count":     "description.RequiredApprovingReviewCount",
	"required_deployment_environments":    "description.RequiredDeploymentEnvironments",
	"required_status_checks":              "description.RequiredStatusChecks",
	"requires_approving_reviews":          "description.RequiresApprovingReviews",
	"requires_code_owner_reviews":         "description.RequiresCodeOwnerReviews",
	"requires_commit_signatures":          "description.RequiresCommitSignatures",
	"requires_conversation_resolution":    "description.RequiresConversationResolution",
	"requires_deployments":                "description.RequiresDeployments",
	"requires_linear_history":             "description.RequiresLinearHistory",
	"requires_status_checks":              "description.RequiresStatusChecks",
	"requires_strict_status_checks":       "description.RequiresStrictStatusChecks",
	"restricts_pushes":                    "description.RestrictsPushes",
	"restricts_review_dismissals":         "description.RestrictsReviewDismissals",
}

func GetBranchProtection(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetBranchProtection")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewBranchProtectionPaginator(essdk.BuildFilter(ctx, d.QueryContext, getBranchProtectionFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: BranchProtection =============================

// ==========================  START: Commit =============================

type Commit struct {
	ResourceID      string                   `json:"resource_id"`
	PlatformID      string                   `json:"platform_id"`
	Description     github.CommitDescription `json:"description"`
	Metadata        github.Metadata          `json:"metadata"`
	DescribedBy     string                   `json:"described_by"`
	ResourceType    string                   `json:"resource_type"`
	IntegrationType string                   `json:"integration_type"`
	IntegrationID   string                   `json:"integration_id"`
}

type CommitHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Commit        `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type CommitHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []CommitHit       `json:"hits"`
}

type CommitSearchResponse struct {
	PitID string     `json:"pit_id"`
	Hits  CommitHits `json:"hits"`
}

type CommitPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCommitPaginator(filters []essdk.BoolFilter, limit *int64) (CommitPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_commit", filters, limit)
	if err != nil {
		return CommitPaginator{}, err
	}

	p := CommitPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CommitPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CommitPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CommitPaginator) NextPage(ctx context.Context) ([]Commit, error) {
	var response CommitSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Commit
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCommitFilters = map[string]string{
	"author":        "description.Author",
	"comments_url":  "description.CommentsURL",
	"commit_detail": "description.CommitDetail",
	"commiter":      "description.Committer",
	"files":         "description.Files",
	"html_url":      "description.HTMLURL",
	"node_id":       "description.NodeID",
	"parents":       "description.Parents",
	"sha":           "description.SHA",
	"stats":         "description.Stats",
	"url":           "description.URL",
}

func ListCommit(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCommit")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCommit NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCommit NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCommit GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCommit GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCommit GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCommitPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCommitFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCommit NewCommitPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCommit paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCommitFilters = map[string]string{
	"author":        "description.Author",
	"comments_url":  "description.CommentsURL",
	"commit_detail": "description.CommitDetail",
	"commiter":      "description.Committer",
	"files":         "description.Files",
	"html_url":      "description.HTMLURL",
	"node_id":       "description.NodeID",
	"parents":       "description.Parents",
	"sha":           "description.SHA",
	"stats":         "description.Stats",
	"url":           "description.URL",
}

func GetCommit(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCommit")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCommitPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCommitFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Commit =============================

// ==========================  START: Issue =============================

type Issue struct {
	ResourceID      string                  `json:"resource_id"`
	PlatformID      string                  `json:"platform_id"`
	Description     github.IssueDescription `json:"description"`
	Metadata        github.Metadata         `json:"metadata"`
	DescribedBy     string                  `json:"described_by"`
	ResourceType    string                  `json:"resource_type"`
	IntegrationType string                  `json:"integration_type"`
	IntegrationID   string                  `json:"integration_id"`
}

type IssueHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Issue         `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type IssueHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []IssueHit        `json:"hits"`
}

type IssueSearchResponse struct {
	PitID string    `json:"pit_id"`
	Hits  IssueHits `json:"hits"`
}

type IssuePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIssuePaginator(filters []essdk.BoolFilter, limit *int64) (IssuePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_issue", filters, limit)
	if err != nil {
		return IssuePaginator{}, err
	}

	p := IssuePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IssuePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IssuePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p IssuePaginator) NextPage(ctx context.Context) ([]Issue, error) {
	var response IssueSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Issue
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIssueFilters = map[string]string{
	"active_lock_reason":         "description.ActiveLockReason",
	"assignees":                  "description.Assignees",
	"assignees_total_count":      "description.AssigneesTotalCount",
	"author":                     "description.Author",
	"author_association":         "description.AuthorAssociation",
	"author_login":               "description.AuthorLogin",
	"body":                       "description.Body",
	"body_url":                   "description.BodyUrl",
	"closed":                     "description.Closed",
	"comments_total_count":       "description.CommentsTotalCount",
	"created_via_email":          "description.CreatedViaEmail",
	"editor":                     "description.Editor",
	"full_database_id":           "description.FullDatabaseId",
	"id":                         "description.Id",
	"includes_created_edit":      "description.IncludesCreatedEdit",
	"is_pinned":                  "description.IsPinned",
	"is_read_by_user":            "description.IsReadByUser",
	"labels":                     "description.Labels",
	"labels_src":                 "description.LabelsSrc",
	"labels_total_count":         "description.LabelsTotalCount",
	"locked":                     "description.Locked",
	"milestone":                  "description.Milestone",
	"node_id":                    "description.NodeId",
	"number":                     "description.Number",
	"repository_full_name":       "description.RepositoryFullName",
	"state":                      "description.State",
	"state_reason":               "description.StateReason",
	"title":                      "description.Title",
	"url":                        "description.Url",
	"user_can_close":             "description.UserCanClose",
	"user_can_react":             "description.UserCanReact",
	"user_can_reopen":            "description.UserCanReopen",
	"user_can_subscribe":         "description.UserCanSubscribe",
	"user_can_update":            "description.UserCanUpdate",
	"user_cannot_update_reasons": "description.UserCannotUpdateReasons",
	"user_did_author":            "description.UserDidAuthor",
	"user_subscription":          "description.UserSubscription",
}

func ListIssue(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIssue")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListIssue NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListIssue NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListIssue GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListIssue GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListIssue GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewIssuePaginator(essdk.BuildFilter(ctx, d.QueryContext, listIssueFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListIssue NewIssuePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListIssue paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getIssueFilters = map[string]string{
	"active_lock_reason":         "description.ActiveLockReason",
	"assignees":                  "description.Assignees",
	"assignees_total_count":      "description.AssigneesTotalCount",
	"author":                     "description.Author",
	"author_association":         "description.AuthorAssociation",
	"author_login":               "description.AuthorLogin",
	"body":                       "description.Body",
	"body_url":                   "description.BodyUrl",
	"closed":                     "description.Closed",
	"comments_total_count":       "description.CommentsTotalCount",
	"created_via_email":          "description.CreatedViaEmail",
	"editor":                     "description.Editor",
	"full_database_id":           "description.FullDatabaseId",
	"id":                         "description.Id",
	"includes_created_edit":      "description.IncludesCreatedEdit",
	"is_pinned":                  "description.IsPinned",
	"is_read_by_user":            "description.IsReadByUser",
	"labels":                     "description.Labels",
	"labels_src":                 "description.LabelsSrc",
	"labels_total_count":         "description.LabelsTotalCount",
	"locked":                     "description.Locked",
	"milestone":                  "description.Milestone",
	"node_id":                    "description.NodeId",
	"number":                     "description.Number",
	"repository_full_name":       "description.RepositoryFullName",
	"state":                      "description.State",
	"state_reason":               "description.StateReason",
	"title":                      "description.Title",
	"url":                        "description.Url",
	"user_can_close":             "description.UserCanClose",
	"user_can_react":             "description.UserCanReact",
	"user_can_reopen":            "description.UserCanReopen",
	"user_can_subscribe":         "description.UserCanSubscribe",
	"user_can_update":            "description.UserCanUpdate",
	"user_cannot_update_reasons": "description.UserCannotUpdateReasons",
	"user_did_author":            "description.UserDidAuthor",
	"user_subscription":          "description.UserSubscription",
}

func GetIssue(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIssue")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewIssuePaginator(essdk.BuildFilter(ctx, d.QueryContext, getIssueFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Issue =============================

// ==========================  START: License =============================

type License struct {
	ResourceID      string                    `json:"resource_id"`
	PlatformID      string                    `json:"platform_id"`
	Description     github.LicenseDescription `json:"description"`
	Metadata        github.Metadata           `json:"metadata"`
	DescribedBy     string                    `json:"described_by"`
	ResourceType    string                    `json:"resource_type"`
	IntegrationType string                    `json:"integration_type"`
	IntegrationID   string                    `json:"integration_id"`
}

type LicenseHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  License       `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type LicenseHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []LicenseHit      `json:"hits"`
}

type LicenseSearchResponse struct {
	PitID string      `json:"pit_id"`
	Hits  LicenseHits `json:"hits"`
}

type LicensePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLicensePaginator(filters []essdk.BoolFilter, limit *int64) (LicensePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_license", filters, limit)
	if err != nil {
		return LicensePaginator{}, err
	}

	p := LicensePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LicensePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LicensePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p LicensePaginator) NextPage(ctx context.Context) ([]License, error) {
	var response LicenseSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []License
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLicenseFilters = map[string]string{
	"conditions":     "description.Conditions",
	"description":    "description.Description",
	"featured":       "description.Featured",
	"hidden":         "description.Hidden",
	"implementation": "description.Implementation",
	"key":            "description.Key",
	"limitations":    "description.Limitations",
	"name":           "description.Name",
	"nickname":       "description.Nickname",
	"permissions":    "description.Permissions",
	"pseudo_license": "description.PseudoLicense",
	"spdx_id":        "description.SpdxId",
	"url":            "description.Url",
}

func ListLicense(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLicense")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListLicense NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListLicense NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListLicense GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListLicense GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListLicense GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewLicensePaginator(essdk.BuildFilter(ctx, d.QueryContext, listLicenseFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListLicense NewLicensePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListLicense paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getLicenseFilters = map[string]string{
	"conditions":     "description.Conditions",
	"description":    "description.Description",
	"featured":       "description.Featured",
	"hidden":         "description.Hidden",
	"implementation": "description.Implementation",
	"key":            "description.Key",
	"limitations":    "description.Limitations",
	"name":           "description.Name",
	"nickname":       "description.Nickname",
	"permissions":    "description.Permissions",
	"pseudo_license": "description.PseudoLicense",
	"spdx_id":        "description.SpdxId",
	"url":            "description.Url",
}

func GetLicense(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLicense")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewLicensePaginator(essdk.BuildFilter(ctx, d.QueryContext, getLicenseFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: License =============================

// ==========================  START: Organization =============================

type Organization struct {
	ResourceID      string                         `json:"resource_id"`
	PlatformID      string                         `json:"platform_id"`
	Description     github.OrganizationDescription `json:"description"`
	Metadata        github.Metadata                `json:"metadata"`
	DescribedBy     string                         `json:"described_by"`
	ResourceType    string                         `json:"resource_type"`
	IntegrationType string                         `json:"integration_type"`
	IntegrationID   string                         `json:"integration_id"`
}

type OrganizationHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Organization  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type OrganizationHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []OrganizationHit `json:"hits"`
}

type OrganizationSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  OrganizationHits `json:"hits"`
}

type OrganizationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewOrganizationPaginator(filters []essdk.BoolFilter, limit *int64) (OrganizationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_organization", filters, limit)
	if err != nil {
		return OrganizationPaginator{}, err
	}

	p := OrganizationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p OrganizationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p OrganizationPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p OrganizationPaginator) NextPage(ctx context.Context) ([]Organization, error) {
	var response OrganizationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Organization
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listOrganizationFilters = map[string]string{
	"announcement":                            "description.Announcement",
	"announcement_user_dismissible":           "description.AnnouncementUserDismissible",
	"any_pinnable_items":                      "description.AnyPinnableItems",
	"avatar_url":                              "description.AvatarUrl",
	"billing_email":                           "description.BillingEmail",
	"can_administer":                          "description.CanAdminister",
	"can_changed_pinned_items":                "description.CanChangedPinnedItems",
	"can_create_projects":                     "description.CanCreateProjects",
	"can_create_repositories":                 "description.CanCreateRepositories",
	"can_create_teams":                        "description.CanCreateTeams",
	"can_sponsor":                             "description.CanSponsor",
	"collaborators":                           "description.Collaborators",
	"default_repo_permission":                 "description.DefaultRepoPermission",
	"description":                             "description.Description",
	"email":                                   "description.Email",
	"estimated_next_sponsors_payout_in_cents": "description.EstimatedNextSponsorsPayoutInCents",
	"followers":                               "description.Followers",
	"following":                               "description.Following",
	"has_organization_projects":               "description.HasOrganizationProjects",
	"has_repository_projects":                 "description.HasRepositoryProjects",
	"has_sponsors_listing":                    "description.HasSponsorsListing",
	"hooks":                                   "description.Hooks",
	"id":                                      "description.Id",
	"interaction_ability":                     "description.InteractionAbility",
	"is_a_member":                             "description.IsAMember",
	"is_following":                            "description.IsFollowing",
	"is_sponsoring":                           "description.IsSponsoring",
	"is_sponsoring_you":                       "description.IsSponsoringYou",
	"is_verified":                             "description.IsVerified",
	"location":                                "description.Location",
	"login":                                   "description.Login",
	"members_allowed_repository_creation_type":   "description.MembersAllowedRepositoryCreationType",
	"members_can_create_internal_repos":          "description.MembersCanCreateInternalRepos",
	"members_can_create_pages":                   "description.MembersCanCreatePages",
	"members_can_create_private_repos":           "description.MembersCanCreatePrivateRepos",
	"members_can_create_public_repos":            "description.MembersCanCreatePublicRepos",
	"members_can_create_repos":                   "description.MembersCanCreateRepos",
	"members_can_fork_private_repos":             "description.MembersCanForkPrivateRepos",
	"members_with_role_total_count":              "description.MembersWithRoleTotalCount",
	"monthly_estimated_sponsors_income_in_cents": "description.MonthlyEstimatedSponsorsIncomeInCents",
	"name":                                         "description.Name",
	"new_team_url":                                 "description.NewTeamUrl",
	"node_id":                                      "description.NodeId",
	"packages_total_count":                         "description.PackagesTotalCount",
	"pinnable_items_total_count":                   "description.PinnableItemsTotalCount",
	"pinned_items_remaining":                       "description.PinnedItemsRemaining",
	"pinned_items_total_count":                     "description.PinnedItemsTotalCount",
	"plan_filled_seats":                            "description.PlanFilledSeats",
	"plan_name":                                    "description.PlanName",
	"plan_private_repos":                           "description.PlanPrivateRepos",
	"plan_seats":                                   "description.PlanSeats",
	"plan_space":                                   "description.PlanSpace",
	"private_repositories_total_count":             "description.PrivateRepositoriesTotalCount",
	"projects_total_count":                         "description.ProjectsTotalCount",
	"projects_url":                                 "description.ProjectsUrl",
	"projects_v2_total_count":                      "description.ProjectsV2TotalCount",
	"public_repositories_total_count":              "description.PublicRepositoriesTotalCount",
	"repositories_total_count":                     "description.RepositoriesTotalCount",
	"repositories_total_disk_usage":                "description.RepositoriesTotalDiskUsage",
	"saml_identity_provider":                       "description.SamlIdentityProvider",
	"sponsoring_total_count":                       "description.SponsoringTotalCount",
	"sponsors_listing":                             "description.SponsorsListing",
	"sponsors_total_count":                         "description.SponsorsTotalCount",
	"teams_total_count":                            "description.TeamsTotalCount",
	"teams_url":                                    "description.TeamsUrl",
	"total_sponsorship_amount_as_sponsor_in_cents": "description.TotalSponsorshipAmountAsSponsorInCents",
	"twitter_username":                             "description.TwitterUsername",
	"two_factor_requirement_enabled":               "description.TwoFactorRequirementEnabled",
	"url":                                          "description.Url",
	"web_commit_signoff_required":                  "description.WebCommitSignoffRequired",
	"website_url":                                  "description.WebsiteUrl",
}

func ListOrganization(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListOrganization")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganization NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganization NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganization GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganization GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganization GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewOrganizationPaginator(essdk.BuildFilter(ctx, d.QueryContext, listOrganizationFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganization NewOrganizationPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListOrganization paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getOrganizationFilters = map[string]string{
	"announcement":                            "description.Announcement",
	"announcement_user_dismissible":           "description.AnnouncementUserDismissible",
	"any_pinnable_items":                      "description.AnyPinnableItems",
	"avatar_url":                              "description.AvatarUrl",
	"billing_email":                           "description.BillingEmail",
	"can_administer":                          "description.CanAdminister",
	"can_changed_pinned_items":                "description.CanChangedPinnedItems",
	"can_create_projects":                     "description.CanCreateProjects",
	"can_create_repositories":                 "description.CanCreateRepositories",
	"can_create_teams":                        "description.CanCreateTeams",
	"can_sponsor":                             "description.CanSponsor",
	"collaborators":                           "description.Collaborators",
	"default_repo_permission":                 "description.DefaultRepoPermission",
	"description":                             "description.Description",
	"email":                                   "description.Email",
	"estimated_next_sponsors_payout_in_cents": "description.EstimatedNextSponsorsPayoutInCents",
	"followers":                               "description.Followers",
	"following":                               "description.Following",
	"has_organization_projects":               "description.HasOrganizationProjects",
	"has_repository_projects":                 "description.HasRepositoryProjects",
	"has_sponsors_listing":                    "description.HasSponsorsListing",
	"hooks":                                   "description.Hooks",
	"id":                                      "description.Id",
	"interaction_ability":                     "description.InteractionAbility",
	"is_a_member":                             "description.IsAMember",
	"is_following":                            "description.IsFollowing",
	"is_sponsoring":                           "description.IsSponsoring",
	"is_sponsoring_you":                       "description.IsSponsoringYou",
	"is_verified":                             "description.IsVerified",
	"location":                                "description.Location",
	"login":                                   "description.Login",
	"members_allowed_repository_creation_type":   "description.MembersAllowedRepositoryCreationType",
	"members_can_create_internal_repos":          "description.MembersCanCreateInternalRepos",
	"members_can_create_pages":                   "description.MembersCanCreatePages",
	"members_can_create_private_repos":           "description.MembersCanCreatePrivateRepos",
	"members_can_create_public_repos":            "description.MembersCanCreatePublicRepos",
	"members_can_create_repos":                   "description.MembersCanCreateRepos",
	"members_can_fork_private_repos":             "description.MembersCanForkPrivateRepos",
	"members_with_role_total_count":              "description.MembersWithRoleTotalCount",
	"monthly_estimated_sponsors_income_in_cents": "description.MonthlyEstimatedSponsorsIncomeInCents",
	"name":                                         "description.Name",
	"new_team_url":                                 "description.NewTeamUrl",
	"node_id":                                      "description.NodeId",
	"packages_total_count":                         "description.PackagesTotalCount",
	"pinnable_items_total_count":                   "description.PinnableItemsTotalCount",
	"pinned_items_remaining":                       "description.PinnedItemsRemaining",
	"pinned_items_total_count":                     "description.PinnedItemsTotalCount",
	"plan_filled_seats":                            "description.PlanFilledSeats",
	"plan_name":                                    "description.PlanName",
	"plan_private_repos":                           "description.PlanPrivateRepos",
	"plan_seats":                                   "description.PlanSeats",
	"plan_space":                                   "description.PlanSpace",
	"private_repositories_total_count":             "description.PrivateRepositoriesTotalCount",
	"projects_total_count":                         "description.ProjectsTotalCount",
	"projects_url":                                 "description.ProjectsUrl",
	"projects_v2_total_count":                      "description.ProjectsV2TotalCount",
	"public_repositories_total_count":              "description.PublicRepositoriesTotalCount",
	"repositories_total_count":                     "description.RepositoriesTotalCount",
	"repositories_total_disk_usage":                "description.RepositoriesTotalDiskUsage",
	"saml_identity_provider":                       "description.SamlIdentityProvider",
	"sponsoring_total_count":                       "description.SponsoringTotalCount",
	"sponsors_listing":                             "description.SponsorsListing",
	"sponsors_total_count":                         "description.SponsorsTotalCount",
	"teams_total_count":                            "description.TeamsTotalCount",
	"teams_url":                                    "description.TeamsUrl",
	"total_sponsorship_amount_as_sponsor_in_cents": "description.TotalSponsorshipAmountAsSponsorInCents",
	"twitter_username":                             "description.TwitterUsername",
	"two_factor_requirement_enabled":               "description.TwoFactorRequirementEnabled",
	"url":                                          "description.Url",
	"web_commit_signoff_required":                  "description.WebCommitSignoffRequired",
	"website_url":                                  "description.WebsiteUrl",
}

func GetOrganization(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetOrganization")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewOrganizationPaginator(essdk.BuildFilter(ctx, d.QueryContext, getOrganizationFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Organization =============================

// ==========================  START: OrgCollaborators =============================

type OrgCollaborators struct {
	ResourceID      string                             `json:"resource_id"`
	PlatformID      string                             `json:"platform_id"`
	Description     github.OrgCollaboratorsDescription `json:"description"`
	Metadata        github.Metadata                    `json:"metadata"`
	DescribedBy     string                             `json:"described_by"`
	ResourceType    string                             `json:"resource_type"`
	IntegrationType string                             `json:"integration_type"`
	IntegrationID   string                             `json:"integration_id"`
}

type OrgCollaboratorsHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  OrgCollaborators `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type OrgCollaboratorsHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []OrgCollaboratorsHit `json:"hits"`
}

type OrgCollaboratorsSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  OrgCollaboratorsHits `json:"hits"`
}

type OrgCollaboratorsPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewOrgCollaboratorsPaginator(filters []essdk.BoolFilter, limit *int64) (OrgCollaboratorsPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_organization_collaborator", filters, limit)
	if err != nil {
		return OrgCollaboratorsPaginator{}, err
	}

	p := OrgCollaboratorsPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p OrgCollaboratorsPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p OrgCollaboratorsPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p OrgCollaboratorsPaginator) NextPage(ctx context.Context) ([]OrgCollaborators, error) {
	var response OrgCollaboratorsSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []OrgCollaborators
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listOrgCollaboratorsFilters = map[string]string{
	"affiliation":     "description.Affiliation",
	"organization":    "description.Organization",
	"permission":      "description.Permission",
	"repository_name": "description.RepositoryName",
	"user_login":      "description.UserLogin",
}

func ListOrgCollaborators(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListOrgCollaborators")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgCollaborators NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgCollaborators NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgCollaborators GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgCollaborators GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgCollaborators GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewOrgCollaboratorsPaginator(essdk.BuildFilter(ctx, d.QueryContext, listOrgCollaboratorsFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgCollaborators NewOrgCollaboratorsPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListOrgCollaborators paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getOrgCollaboratorsFilters = map[string]string{
	"affiliation":     "description.Affiliation",
	"organization":    "description.Organization",
	"permission":      "description.Permission",
	"repository_name": "description.RepositoryName",
	"user_login":      "description.UserLogin",
}

func GetOrgCollaborators(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetOrgCollaborators")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewOrgCollaboratorsPaginator(essdk.BuildFilter(ctx, d.QueryContext, getOrgCollaboratorsFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: OrgCollaborators =============================

// ==========================  START: OrgAlertDependabot =============================

type OrgAlertDependabot struct {
	ResourceID      string                               `json:"resource_id"`
	PlatformID      string                               `json:"platform_id"`
	Description     github.OrgAlertDependabotDescription `json:"description"`
	Metadata        github.Metadata                      `json:"metadata"`
	DescribedBy     string                               `json:"described_by"`
	ResourceType    string                               `json:"resource_type"`
	IntegrationType string                               `json:"integration_type"`
	IntegrationID   string                               `json:"integration_id"`
}

type OrgAlertDependabotHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  OrgAlertDependabot `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type OrgAlertDependabotHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []OrgAlertDependabotHit `json:"hits"`
}

type OrgAlertDependabotSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  OrgAlertDependabotHits `json:"hits"`
}

type OrgAlertDependabotPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewOrgAlertDependabotPaginator(filters []essdk.BoolFilter, limit *int64) (OrgAlertDependabotPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_organization_dependabot_alert", filters, limit)
	if err != nil {
		return OrgAlertDependabotPaginator{}, err
	}

	p := OrgAlertDependabotPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p OrgAlertDependabotPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p OrgAlertDependabotPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p OrgAlertDependabotPaginator) NextPage(ctx context.Context) ([]OrgAlertDependabot, error) {
	var response OrgAlertDependabotSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []OrgAlertDependabot
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listOrgAlertDependabotFilters = map[string]string{
	"alert_number":                         "description.AlertNumber",
	"dependency_manifest_path":             "description.DependencyManifestPath",
	"dependency_package_ecosystem":         "description.DependencyPackageEcosystem",
	"dependency_package_name":              "description.DependencyPackageName",
	"dependency_scope":                     "description.DependencyScope",
	"dismissed_comment":                    "description.DismissedComment",
	"dismissed_reason":                     "description.DismissedReason",
	"html_url":                             "description.HTMLURL",
	"security_advisory_cve_id":             "description.SecurityAdvisoryCVEID",
	"security_advisory_cvss_score":         "description.SecurityAdvisoryCVSSScore",
	"security_advisory_cvss_vector_string": "description.SecurityAdvisoryCVSSVector",
	"security_advisory_cwes":               "description.SecurityAdvisoryCWEs",
	"security_advisory_description":        "description.SecurityAdvisoryDescription",
	"security_advisory_ghsa_id":            "description.SecurityAdvisoryGHSAID",
	"security_advisory_severity":           "description.SecurityAdvisorySeverity",
	"security_advisory_summary":            "description.SecurityAdvisorySummary",
	"state":                                "description.State",
	"url":                                  "description.URL",
}

func ListOrgAlertDependabot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListOrgAlertDependabot")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgAlertDependabot NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgAlertDependabot NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgAlertDependabot GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgAlertDependabot GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgAlertDependabot GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewOrgAlertDependabotPaginator(essdk.BuildFilter(ctx, d.QueryContext, listOrgAlertDependabotFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgAlertDependabot NewOrgAlertDependabotPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListOrgAlertDependabot paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getOrgAlertDependabotFilters = map[string]string{
	"alert_number":                         "description.AlertNumber",
	"dependency_manifest_path":             "description.DependencyManifestPath",
	"dependency_package_ecosystem":         "description.DependencyPackageEcosystem",
	"dependency_package_name":              "description.DependencyPackageName",
	"dependency_scope":                     "description.DependencyScope",
	"dismissed_comment":                    "description.DismissedComment",
	"dismissed_reason":                     "description.DismissedReason",
	"html_url":                             "description.HTMLURL",
	"security_advisory_cve_id":             "description.SecurityAdvisoryCVEID",
	"security_advisory_cvss_score":         "description.SecurityAdvisoryCVSSScore",
	"security_advisory_cvss_vector_string": "description.SecurityAdvisoryCVSSVector",
	"security_advisory_cwes":               "description.SecurityAdvisoryCWEs",
	"security_advisory_description":        "description.SecurityAdvisoryDescription",
	"security_advisory_ghsa_id":            "description.SecurityAdvisoryGHSAID",
	"security_advisory_severity":           "description.SecurityAdvisorySeverity",
	"security_advisory_summary":            "description.SecurityAdvisorySummary",
	"state":                                "description.State",
	"url":                                  "description.URL",
}

func GetOrgAlertDependabot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetOrgAlertDependabot")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewOrgAlertDependabotPaginator(essdk.BuildFilter(ctx, d.QueryContext, getOrgAlertDependabotFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: OrgAlertDependabot =============================

// ==========================  START: OrgMembers =============================

type OrgMembers struct {
	ResourceID      string                       `json:"resource_id"`
	PlatformID      string                       `json:"platform_id"`
	Description     github.OrgMembersDescription `json:"description"`
	Metadata        github.Metadata              `json:"metadata"`
	DescribedBy     string                       `json:"described_by"`
	ResourceType    string                       `json:"resource_type"`
	IntegrationType string                       `json:"integration_type"`
	IntegrationID   string                       `json:"integration_id"`
}

type OrgMembersHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  OrgMembers    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type OrgMembersHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []OrgMembersHit   `json:"hits"`
}

type OrgMembersSearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  OrgMembersHits `json:"hits"`
}

type OrgMembersPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewOrgMembersPaginator(filters []essdk.BoolFilter, limit *int64) (OrgMembersPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_organization_member", filters, limit)
	if err != nil {
		return OrgMembersPaginator{}, err
	}

	p := OrgMembersPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p OrgMembersPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p OrgMembersPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p OrgMembersPaginator) NextPage(ctx context.Context) ([]OrgMembers, error) {
	var response OrgMembersSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []OrgMembers
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listOrgMembersFilters = map[string]string{
	"has_two_factor_enabled": "description.HasTwoFactorEnabled",
	"organization":           "description.Organization",
	"role":                   "description.Role",
}

func ListOrgMembers(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListOrgMembers")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgMembers NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgMembers NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgMembers GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgMembers GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgMembers GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewOrgMembersPaginator(essdk.BuildFilter(ctx, d.QueryContext, listOrgMembersFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgMembers NewOrgMembersPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListOrgMembers paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getOrgMembersFilters = map[string]string{
	"has_two_factor_enabled": "description.HasTwoFactorEnabled",
	"organization":           "description.Organization",
	"role":                   "description.Role",
}

func GetOrgMembers(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetOrgMembers")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewOrgMembersPaginator(essdk.BuildFilter(ctx, d.QueryContext, getOrgMembersFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: OrgMembers =============================

// ==========================  START: PullRequest =============================

type PullRequest struct {
	ResourceID      string                        `json:"resource_id"`
	PlatformID      string                        `json:"platform_id"`
	Description     github.PullRequestDescription `json:"description"`
	Metadata        github.Metadata               `json:"metadata"`
	DescribedBy     string                        `json:"described_by"`
	ResourceType    string                        `json:"resource_type"`
	IntegrationType string                        `json:"integration_type"`
	IntegrationID   string                        `json:"integration_id"`
}

type PullRequestHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  PullRequest   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type PullRequestHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []PullRequestHit  `json:"hits"`
}

type PullRequestSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  PullRequestHits `json:"hits"`
}

type PullRequestPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewPullRequestPaginator(filters []essdk.BoolFilter, limit *int64) (PullRequestPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_pullrequest", filters, limit)
	if err != nil {
		return PullRequestPaginator{}, err
	}

	p := PullRequestPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p PullRequestPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p PullRequestPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p PullRequestPaginator) NextPage(ctx context.Context) ([]PullRequest, error) {
	var response PullRequestSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []PullRequest
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listPullRequestFilters = map[string]string{
	"active_lock_reason":          "description.ActiveLockReason",
	"additions":                   "description.Additions",
	"assignees":                   "description.Assignees",
	"assignees_total_count":       "description.AssigneesTotalCount",
	"author":                      "description.Author",
	"author_association":          "description.AuthorAssociation",
	"base_ref":                    "description.BaseRef",
	"base_ref_name":               "description.BaseRefName",
	"body":                        "description.Body",
	"can_apply_suggestion":        "description.CanApplySuggestion",
	"can_close":                   "description.CanClose",
	"can_delete_head_ref":         "description.CanDeleteHeadRef",
	"can_disable_auto_merge":      "description.CanDisableAutoMerge",
	"can_edit_files":              "description.CanEditFiles",
	"can_enable_auto_merge":       "description.CanEnableAutoMerge",
	"can_merge_as_admin":          "description.CanMergeAsAdmin",
	"can_react":                   "description.CanReact",
	"can_reopen":                  "description.CanReopen",
	"can_subscribe":               "description.CanSubscribe",
	"can_update":                  "description.CanUpdate",
	"can_update_branch":           "description.CanUpdateBranch",
	"cannot_update_reasons":       "description.CannotUpdateReasons",
	"changed_files":               "description.ChangedFiles",
	"checks_url":                  "description.ChecksUrl",
	"closed":                      "description.Closed",
	"commits_total_count":         "description.CommitsTotalCount",
	"created_via_email":           "description.CreatedViaEmail",
	"deletions":                   "description.Deletions",
	"did_author":                  "description.DidAuthor",
	"editor":                      "description.Editor",
	"head_ref":                    "description.HeadRef",
	"head_ref_name":               "description.HeadRefName",
	"head_ref_oid":                "description.HeadRefOid",
	"id":                          "description.Id",
	"includes_created_edit":       "description.IncludesCreatedEdit",
	"is_cross_repository":         "description.IsCrossRepository",
	"is_draft":                    "description.IsDraft",
	"is_read_by_user":             "description.IsReadByUser",
	"labels":                      "description.Labels",
	"labels_src":                  "description.LabelsSrc",
	"labels_total_count":          "description.LabelsTotalCount",
	"locked":                      "description.Locked",
	"maintainer_can_modify":       "description.MaintainerCanModify",
	"merge_commit":                "description.MergeCommit",
	"mergeable":                   "description.Mergeable",
	"merged":                      "description.Merged",
	"merged_by":                   "description.MergedBy",
	"milestone":                   "description.Milestone",
	"node_id":                     "description.NodeId",
	"number":                      "description.Number",
	"permalink":                   "description.Permalink",
	"repository_full_name":        "description.RepoFullName",
	"revert_url":                  "description.RevertUrl",
	"review_decision":             "description.ReviewDecision",
	"review_requests_total_count": "description.ReviewRequestsTotalCount",
	"reviews_total_count":         "description.ReviewsTotalCount",
	"state":                       "description.State",
	"subscription":                "description.Subscription",
	"suggested_reviewers":         "description.SuggestedReviewers",
	"title":                       "description.Title",
	"total_comments_count":        "description.TotalCommentsCount",
	"url":                         "description.Url",
}

func ListPullRequest(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListPullRequest")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListPullRequest NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListPullRequest NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListPullRequest GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListPullRequest GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListPullRequest GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewPullRequestPaginator(essdk.BuildFilter(ctx, d.QueryContext, listPullRequestFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListPullRequest NewPullRequestPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListPullRequest paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getPullRequestFilters = map[string]string{
	"active_lock_reason":          "description.ActiveLockReason",
	"additions":                   "description.Additions",
	"assignees":                   "description.Assignees",
	"assignees_total_count":       "description.AssigneesTotalCount",
	"author":                      "description.Author",
	"author_association":          "description.AuthorAssociation",
	"base_ref":                    "description.BaseRef",
	"base_ref_name":               "description.BaseRefName",
	"body":                        "description.Body",
	"can_apply_suggestion":        "description.CanApplySuggestion",
	"can_close":                   "description.CanClose",
	"can_delete_head_ref":         "description.CanDeleteHeadRef",
	"can_disable_auto_merge":      "description.CanDisableAutoMerge",
	"can_edit_files":              "description.CanEditFiles",
	"can_enable_auto_merge":       "description.CanEnableAutoMerge",
	"can_merge_as_admin":          "description.CanMergeAsAdmin",
	"can_react":                   "description.CanReact",
	"can_reopen":                  "description.CanReopen",
	"can_subscribe":               "description.CanSubscribe",
	"can_update":                  "description.CanUpdate",
	"can_update_branch":           "description.CanUpdateBranch",
	"cannot_update_reasons":       "description.CannotUpdateReasons",
	"changed_files":               "description.ChangedFiles",
	"checks_url":                  "description.ChecksUrl",
	"closed":                      "description.Closed",
	"commits_total_count":         "description.CommitsTotalCount",
	"created_via_email":           "description.CreatedViaEmail",
	"deletions":                   "description.Deletions",
	"did_author":                  "description.DidAuthor",
	"editor":                      "description.Editor",
	"head_ref":                    "description.HeadRef",
	"head_ref_name":               "description.HeadRefName",
	"head_ref_oid":                "description.HeadRefOid",
	"id":                          "description.Id",
	"includes_created_edit":       "description.IncludesCreatedEdit",
	"is_cross_repository":         "description.IsCrossRepository",
	"is_draft":                    "description.IsDraft",
	"is_read_by_user":             "description.IsReadByUser",
	"labels":                      "description.Labels",
	"labels_src":                  "description.LabelsSrc",
	"labels_total_count":          "description.LabelsTotalCount",
	"locked":                      "description.Locked",
	"maintainer_can_modify":       "description.MaintainerCanModify",
	"merge_commit":                "description.MergeCommit",
	"mergeable":                   "description.Mergeable",
	"merged":                      "description.Merged",
	"merged_by":                   "description.MergedBy",
	"milestone":                   "description.Milestone",
	"node_id":                     "description.NodeId",
	"number":                      "description.Number",
	"permalink":                   "description.Permalink",
	"repository_full_name":        "description.RepoFullName",
	"revert_url":                  "description.RevertUrl",
	"review_decision":             "description.ReviewDecision",
	"review_requests_total_count": "description.ReviewRequestsTotalCount",
	"reviews_total_count":         "description.ReviewsTotalCount",
	"state":                       "description.State",
	"subscription":                "description.Subscription",
	"suggested_reviewers":         "description.SuggestedReviewers",
	"title":                       "description.Title",
	"total_comments_count":        "description.TotalCommentsCount",
	"url":                         "description.Url",
}

func GetPullRequest(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetPullRequest")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewPullRequestPaginator(essdk.BuildFilter(ctx, d.QueryContext, getPullRequestFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: PullRequest =============================

// ==========================  START: Repository =============================

type Repository struct {
	ResourceID      string                       `json:"resource_id"`
	PlatformID      string                       `json:"platform_id"`
	Description     github.RepositoryDescription `json:"description"`
	Metadata        github.Metadata              `json:"metadata"`
	DescribedBy     string                       `json:"described_by"`
	ResourceType    string                       `json:"resource_type"`
	IntegrationType string                       `json:"integration_type"`
	IntegrationID   string                       `json:"integration_id"`
}

type RepositoryHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Repository    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type RepositoryHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []RepositoryHit   `json:"hits"`
}

type RepositorySearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  RepositoryHits `json:"hits"`
}

type RepositoryPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRepositoryPaginator(filters []essdk.BoolFilter, limit *int64) (RepositoryPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_repository", filters, limit)
	if err != nil {
		return RepositoryPaginator{}, err
	}

	p := RepositoryPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RepositoryPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RepositoryPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RepositoryPaginator) NextPage(ctx context.Context) ([]Repository, error) {
	var response RepositorySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Repository
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRepositoryFilters = map[string]string{
	"created_at":                 "description.CreatedAt",
	"default_branch_ref":         "description.DefaultBranchRef",
	"description":                "description.Description",
	"homepage_url":               "description.HomepageURL",
	"id":                         "description.GitHubRepoID",
	"is_active":                  "description.IsActive",
	"is_empty":                   "description.IsEmpty",
	"is_fork":                    "description.IsFork",
	"is_security_policy_enabled": "description.IsSecurityPolicyEnabled",
	"languages":                  "description.Languages",
	"license_info":               "description.LicenseInfo",
	"metrics":                    "description.Metrics",
	"name":                       "description.Name",
	"name_with_owner":            "description.NameWithOwner",
	"node_id":                    "description.NodeID",
	"organization":               "description.Organization",
	"owner":                      "description.Owner",
	"parent":                     "description.Parent",
	"permissions":                "description.Permissions",
	"primary_language":           "description.PrimaryLanguage",
	"pushed_at":                  "description.PushedAt",
	"repo_settings":              "description.RepositorySettings",
	"repo_urls":                  "description.RepoURLs",
	"security_settings":          "description.SecuritySettings",
	"source":                     "description.Source",
	"topics":                     "description.Topics",
	"updated_at":                 "description.UpdatedAt",
	"visibility":                 "description.Visibility",
}

func ListRepository(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRepository")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepository NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepository NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepository GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepository GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepository GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRepositoryPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRepositoryFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepository NewRepositoryPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRepository paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRepositoryFilters = map[string]string{
	"created_at":                 "description.CreatedAt",
	"default_branch_ref":         "description.DefaultBranchRef",
	"description":                "description.Description",
	"homepage_url":               "description.HomepageURL",
	"id":                         "description.GitHubRepoID",
	"is_active":                  "description.IsActive",
	"is_empty":                   "description.IsEmpty",
	"is_fork":                    "description.IsFork",
	"is_security_policy_enabled": "description.IsSecurityPolicyEnabled",
	"languages":                  "description.Languages",
	"license_info":               "description.LicenseInfo",
	"metrics":                    "description.Metrics",
	"name":                       "description.Name",
	"name_with_owner":            "description.NameWithOwner",
	"node_id":                    "description.NodeID",
	"organization":               "description.Organization",
	"owner":                      "description.Owner",
	"parent":                     "description.Parent",
	"permissions":                "description.Permissions",
	"primary_language":           "description.PrimaryLanguage",
	"pushed_at":                  "description.PushedAt",
	"repo_settings":              "description.RepositorySettings",
	"repo_urls":                  "description.RepoURLs",
	"security_settings":          "description.SecuritySettings",
	"source":                     "description.Source",
	"topics":                     "description.Topics",
	"updated_at":                 "description.UpdatedAt",
	"visibility":                 "description.Visibility",
}

func GetRepository(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRepository")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRepositoryPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRepositoryFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Repository =============================

// ==========================  START: Release =============================

type Release struct {
	ResourceID      string                    `json:"resource_id"`
	PlatformID      string                    `json:"platform_id"`
	Description     github.ReleaseDescription `json:"description"`
	Metadata        github.Metadata           `json:"metadata"`
	DescribedBy     string                    `json:"described_by"`
	ResourceType    string                    `json:"resource_type"`
	IntegrationType string                    `json:"integration_type"`
	IntegrationID   string                    `json:"integration_id"`
}

type ReleaseHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Release       `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ReleaseHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []ReleaseHit      `json:"hits"`
}

type ReleaseSearchResponse struct {
	PitID string      `json:"pit_id"`
	Hits  ReleaseHits `json:"hits"`
}

type ReleasePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewReleasePaginator(filters []essdk.BoolFilter, limit *int64) (ReleasePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_release", filters, limit)
	if err != nil {
		return ReleasePaginator{}, err
	}

	p := ReleasePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ReleasePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ReleasePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ReleasePaginator) NextPage(ctx context.Context) ([]Release, error) {
	var response ReleaseSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Release
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listReleaseFilters = map[string]string{
	"assets":               "description.Assets",
	"assets_url":           "description.AssetsURL",
	"author_login":         "description.AssetsURL",
	"body":                 "description.Body",
	"draft":                "description.Draft",
	"html_url":             "description.HTMLURL",
	"id":                   "description.ID",
	"name":                 "description.Name",
	"node_id":              "description.NodeID",
	"prerelease":           "description.Prerelease",
	"repository_full_name": "description.RepositoryFullName",
	"tag_name":             "description.TagName",
	"tarball_url":          "description.TarballURL",
	"target_commitish":     "description.TargetCommitish",
	"upload_url":           "description.UploadURL",
	"url":                  "description.URL",
	"zipball_url":          "description.ZipballURL",
}

func ListRelease(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRelease")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRelease NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRelease NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRelease GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRelease GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRelease GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewReleasePaginator(essdk.BuildFilter(ctx, d.QueryContext, listReleaseFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRelease NewReleasePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRelease paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getReleaseFilters = map[string]string{
	"assets":               "description.Assets",
	"assets_url":           "description.AssetsURL",
	"author_login":         "description.AssetsURL",
	"body":                 "description.Body",
	"draft":                "description.Draft",
	"html_url":             "description.HTMLURL",
	"id":                   "description.ID",
	"name":                 "description.Name",
	"node_id":              "description.NodeID",
	"prerelease":           "description.Prerelease",
	"repository_full_name": "description.RepositoryFullName",
	"tag_name":             "description.TagName",
	"tarball_url":          "description.TarballURL",
	"target_commitish":     "description.TargetCommitish",
	"upload_url":           "description.UploadURL",
	"url":                  "description.URL",
	"zipball_url":          "description.ZipballURL",
}

func GetRelease(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRelease")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewReleasePaginator(essdk.BuildFilter(ctx, d.QueryContext, getReleaseFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Release =============================

// ==========================  START: RepoCollaborators =============================

type RepoCollaborators struct {
	ResourceID      string                              `json:"resource_id"`
	PlatformID      string                              `json:"platform_id"`
	Description     github.RepoCollaboratorsDescription `json:"description"`
	Metadata        github.Metadata                     `json:"metadata"`
	DescribedBy     string                              `json:"described_by"`
	ResourceType    string                              `json:"resource_type"`
	IntegrationType string                              `json:"integration_type"`
	IntegrationID   string                              `json:"integration_id"`
}

type RepoCollaboratorsHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  RepoCollaborators `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type RepoCollaboratorsHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []RepoCollaboratorsHit `json:"hits"`
}

type RepoCollaboratorsSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  RepoCollaboratorsHits `json:"hits"`
}

type RepoCollaboratorsPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRepoCollaboratorsPaginator(filters []essdk.BoolFilter, limit *int64) (RepoCollaboratorsPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_repository_collaborator", filters, limit)
	if err != nil {
		return RepoCollaboratorsPaginator{}, err
	}

	p := RepoCollaboratorsPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RepoCollaboratorsPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RepoCollaboratorsPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RepoCollaboratorsPaginator) NextPage(ctx context.Context) ([]RepoCollaborators, error) {
	var response RepoCollaboratorsSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RepoCollaborators
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRepoCollaboratorsFilters = map[string]string{
	"affiliation":          "description.Affiliation",
	"permission":           "description.Permission",
	"repository_full_name": "description.RepoFullName",
	"user_login":           "description.UserLogin",
}

func ListRepoCollaborators(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRepoCollaborators")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoCollaborators NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoCollaborators NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoCollaborators GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoCollaborators GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoCollaborators GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRepoCollaboratorsPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRepoCollaboratorsFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoCollaborators NewRepoCollaboratorsPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRepoCollaborators paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRepoCollaboratorsFilters = map[string]string{
	"affiliation":          "description.Affiliation",
	"permission":           "description.Permission",
	"repository_full_name": "description.RepoFullName",
	"user_login":           "description.UserLogin",
}

func GetRepoCollaborators(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRepoCollaborators")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRepoCollaboratorsPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRepoCollaboratorsFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RepoCollaborators =============================

// ==========================  START: RepoAlertDependabot =============================

type RepoAlertDependabot struct {
	ResourceID      string                                `json:"resource_id"`
	PlatformID      string                                `json:"platform_id"`
	Description     github.RepoAlertDependabotDescription `json:"description"`
	Metadata        github.Metadata                       `json:"metadata"`
	DescribedBy     string                                `json:"described_by"`
	ResourceType    string                                `json:"resource_type"`
	IntegrationType string                                `json:"integration_type"`
	IntegrationID   string                                `json:"integration_id"`
}

type RepoAlertDependabotHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  RepoAlertDependabot `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type RepoAlertDependabotHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []RepoAlertDependabotHit `json:"hits"`
}

type RepoAlertDependabotSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  RepoAlertDependabotHits `json:"hits"`
}

type RepoAlertDependabotPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRepoAlertDependabotPaginator(filters []essdk.BoolFilter, limit *int64) (RepoAlertDependabotPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_repository_dependabotalert", filters, limit)
	if err != nil {
		return RepoAlertDependabotPaginator{}, err
	}

	p := RepoAlertDependabotPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RepoAlertDependabotPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RepoAlertDependabotPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RepoAlertDependabotPaginator) NextPage(ctx context.Context) ([]RepoAlertDependabot, error) {
	var response RepoAlertDependabotSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RepoAlertDependabot
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRepoAlertDependabotFilters = map[string]string{}

func ListRepoAlertDependabot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRepoAlertDependabot")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoAlertDependabot NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoAlertDependabot NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoAlertDependabot GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoAlertDependabot GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoAlertDependabot GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRepoAlertDependabotPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRepoAlertDependabotFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoAlertDependabot NewRepoAlertDependabotPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRepoAlertDependabot paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRepoAlertDependabotFilters = map[string]string{}

func GetRepoAlertDependabot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRepoAlertDependabot")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRepoAlertDependabotPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRepoAlertDependabotFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RepoAlertDependabot =============================

// ==========================  START: RepoDeployment =============================

type RepoDeployment struct {
	ResourceID      string                           `json:"resource_id"`
	PlatformID      string                           `json:"platform_id"`
	Description     github.RepoDeploymentDescription `json:"description"`
	Metadata        github.Metadata                  `json:"metadata"`
	DescribedBy     string                           `json:"described_by"`
	ResourceType    string                           `json:"resource_type"`
	IntegrationType string                           `json:"integration_type"`
	IntegrationID   string                           `json:"integration_id"`
}

type RepoDeploymentHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  RepoDeployment `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type RepoDeploymentHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []RepoDeploymentHit `json:"hits"`
}

type RepoDeploymentSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  RepoDeploymentHits `json:"hits"`
}

type RepoDeploymentPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRepoDeploymentPaginator(filters []essdk.BoolFilter, limit *int64) (RepoDeploymentPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_repository_deployment", filters, limit)
	if err != nil {
		return RepoDeploymentPaginator{}, err
	}

	p := RepoDeploymentPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RepoDeploymentPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RepoDeploymentPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RepoDeploymentPaginator) NextPage(ctx context.Context) ([]RepoDeployment, error) {
	var response RepoDeploymentSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RepoDeployment
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRepoDeploymentFilters = map[string]string{
	"commit_sha":           "description.CommitSha",
	"creator":              "description.Creator",
	"description":          "description.Description",
	"environment":          "description.Environment",
	"id":                   "description.Id",
	"latest_environment":   "description.LatestEnvironment",
	"latest_status":        "description.LatestStatus",
	"node_id":              "description.NodeId",
	"original_environment": "description.OriginalEnvironment",
	"payload":              "description.Payload",
	"ref":                  "description.Ref",
	"repository_full_name": "description.RepoFullName",
	"state":                "description.State",
	"task":                 "description.Task",
}

func ListRepoDeployment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRepoDeployment")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoDeployment NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoDeployment NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoDeployment GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoDeployment GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoDeployment GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRepoDeploymentPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRepoDeploymentFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoDeployment NewRepoDeploymentPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRepoDeployment paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRepoDeploymentFilters = map[string]string{
	"commit_sha":           "description.CommitSha",
	"creator":              "description.Creator",
	"description":          "description.Description",
	"environment":          "description.Environment",
	"id":                   "description.Id",
	"latest_environment":   "description.LatestEnvironment",
	"latest_status":        "description.LatestStatus",
	"node_id":              "description.NodeId",
	"original_environment": "description.OriginalEnvironment",
	"payload":              "description.Payload",
	"ref":                  "description.Ref",
	"repository_full_name": "description.RepoFullName",
	"state":                "description.State",
	"task":                 "description.Task",
}

func GetRepoDeployment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRepoDeployment")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRepoDeploymentPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRepoDeploymentFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RepoDeployment =============================

// ==========================  START: RepoEnvironment =============================

type RepoEnvironment struct {
	ResourceID      string                            `json:"resource_id"`
	PlatformID      string                            `json:"platform_id"`
	Description     github.RepoEnvironmentDescription `json:"description"`
	Metadata        github.Metadata                   `json:"metadata"`
	DescribedBy     string                            `json:"described_by"`
	ResourceType    string                            `json:"resource_type"`
	IntegrationType string                            `json:"integration_type"`
	IntegrationID   string                            `json:"integration_id"`
}

type RepoEnvironmentHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  RepoEnvironment `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type RepoEnvironmentHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []RepoEnvironmentHit `json:"hits"`
}

type RepoEnvironmentSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  RepoEnvironmentHits `json:"hits"`
}

type RepoEnvironmentPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRepoEnvironmentPaginator(filters []essdk.BoolFilter, limit *int64) (RepoEnvironmentPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_repository_environment", filters, limit)
	if err != nil {
		return RepoEnvironmentPaginator{}, err
	}

	p := RepoEnvironmentPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RepoEnvironmentPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RepoEnvironmentPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RepoEnvironmentPaginator) NextPage(ctx context.Context) ([]RepoEnvironment, error) {
	var response RepoEnvironmentSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RepoEnvironment
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRepoEnvironmentFilters = map[string]string{
	"id":                   "description.Id",
	"name":                 "description.Name",
	"node_id":              "description.NodeId",
	"repository_full_name": "description.RepoFullName",
}

func ListRepoEnvironment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRepoEnvironment")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoEnvironment NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoEnvironment NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoEnvironment GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoEnvironment GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoEnvironment GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRepoEnvironmentPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRepoEnvironmentFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoEnvironment NewRepoEnvironmentPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRepoEnvironment paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRepoEnvironmentFilters = map[string]string{
	"id":                   "description.Id",
	"name":                 "description.Name",
	"node_id":              "description.NodeId",
	"repository_full_name": "description.RepoFullName",
}

func GetRepoEnvironment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRepoEnvironment")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRepoEnvironmentPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRepoEnvironmentFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RepoEnvironment =============================

// ==========================  START: RepoRuleSet =============================

type RepoRuleSet struct {
	ResourceID      string                        `json:"resource_id"`
	PlatformID      string                        `json:"platform_id"`
	Description     github.RepoRuleSetDescription `json:"description"`
	Metadata        github.Metadata               `json:"metadata"`
	DescribedBy     string                        `json:"described_by"`
	ResourceType    string                        `json:"resource_type"`
	IntegrationType string                        `json:"integration_type"`
	IntegrationID   string                        `json:"integration_id"`
}

type RepoRuleSetHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  RepoRuleSet   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type RepoRuleSetHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []RepoRuleSetHit  `json:"hits"`
}

type RepoRuleSetSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  RepoRuleSetHits `json:"hits"`
}

type RepoRuleSetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRepoRuleSetPaginator(filters []essdk.BoolFilter, limit *int64) (RepoRuleSetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_repository_ruleset", filters, limit)
	if err != nil {
		return RepoRuleSetPaginator{}, err
	}

	p := RepoRuleSetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RepoRuleSetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RepoRuleSetPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RepoRuleSetPaginator) NextPage(ctx context.Context) ([]RepoRuleSet, error) {
	var response RepoRuleSetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RepoRuleSet
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRepoRuleSetFilters = map[string]string{
	"bypass_actors":        "description.BypassActors",
	"conditions":           "description.Conditions",
	"database_id":          "description.DatabaseID",
	"enforcement":          "description.Enforcement",
	"id":                   "description.ID",
	"name":                 "description.Name",
	"repository_full_name": "description.RepoFullName",
	"rules":                "description.Rules",
}

func ListRepoRuleSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRepoRuleSet")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoRuleSet NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoRuleSet NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoRuleSet GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoRuleSet GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoRuleSet GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRepoRuleSetPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRepoRuleSetFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoRuleSet NewRepoRuleSetPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRepoRuleSet paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRepoRuleSetFilters = map[string]string{
	"bypass_actors":        "description.BypassActors",
	"conditions":           "description.Conditions",
	"database_id":          "description.DatabaseID",
	"enforcement":          "description.Enforcement",
	"id":                   "description.ID",
	"name":                 "description.Name",
	"repository_full_name": "description.RepoFullName",
	"rules":                "description.Rules",
}

func GetRepoRuleSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRepoRuleSet")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRepoRuleSetPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRepoRuleSetFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RepoRuleSet =============================

// ==========================  START: RepoSBOM =============================

type RepoSBOM struct {
	ResourceID      string                     `json:"resource_id"`
	PlatformID      string                     `json:"platform_id"`
	Description     github.RepoSBOMDescription `json:"description"`
	Metadata        github.Metadata            `json:"metadata"`
	DescribedBy     string                     `json:"described_by"`
	ResourceType    string                     `json:"resource_type"`
	IntegrationType string                     `json:"integration_type"`
	IntegrationID   string                     `json:"integration_id"`
}

type RepoSBOMHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  RepoSBOM      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type RepoSBOMHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []RepoSBOMHit     `json:"hits"`
}

type RepoSBOMSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  RepoSBOMHits `json:"hits"`
}

type RepoSBOMPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRepoSBOMPaginator(filters []essdk.BoolFilter, limit *int64) (RepoSBOMPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_repository_sbom", filters, limit)
	if err != nil {
		return RepoSBOMPaginator{}, err
	}

	p := RepoSBOMPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RepoSBOMPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RepoSBOMPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RepoSBOMPaginator) NextPage(ctx context.Context) ([]RepoSBOM, error) {
	var response RepoSBOMSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RepoSBOM
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRepoSBOMFilters = map[string]string{
	"creation_info":        "description.CreationInfo",
	"data_license":         "description.DataLicense",
	"document_describes":   "description.DocumentDescribes",
	"document_namespace":   "description.DocumentNamespace",
	"name":                 "description.Name",
	"packages":             "description.Packages",
	"repository_full_name": "description.RepositoryFullName",
	"spdx_id":              "description.SPDXID",
	"spdx_version":         "description.SPDXVersion",
}

func ListRepoSBOM(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRepoSBOM")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoSBOM NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoSBOM NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoSBOM GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoSBOM GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoSBOM GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRepoSBOMPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRepoSBOMFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoSBOM NewRepoSBOMPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRepoSBOM paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRepoSBOMFilters = map[string]string{
	"creation_info":        "description.CreationInfo",
	"data_license":         "description.DataLicense",
	"document_describes":   "description.DocumentDescribes",
	"document_namespace":   "description.DocumentNamespace",
	"name":                 "description.Name",
	"packages":             "description.Packages",
	"repository_full_name": "description.RepositoryFullName",
	"spdx_id":              "description.SPDXID",
	"spdx_version":         "description.SPDXVersion",
}

func GetRepoSBOM(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRepoSBOM")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRepoSBOMPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRepoSBOMFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RepoSBOM =============================

// ==========================  START: RepoVulnerabilityAlert =============================

type RepoVulnerabilityAlert struct {
	ResourceID      string                                   `json:"resource_id"`
	PlatformID      string                                   `json:"platform_id"`
	Description     github.RepoVulnerabilityAlertDescription `json:"description"`
	Metadata        github.Metadata                          `json:"metadata"`
	DescribedBy     string                                   `json:"described_by"`
	ResourceType    string                                   `json:"resource_type"`
	IntegrationType string                                   `json:"integration_type"`
	IntegrationID   string                                   `json:"integration_id"`
}

type RepoVulnerabilityAlertHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  RepoVulnerabilityAlert `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type RepoVulnerabilityAlertHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []RepoVulnerabilityAlertHit `json:"hits"`
}

type RepoVulnerabilityAlertSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  RepoVulnerabilityAlertHits `json:"hits"`
}

type RepoVulnerabilityAlertPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRepoVulnerabilityAlertPaginator(filters []essdk.BoolFilter, limit *int64) (RepoVulnerabilityAlertPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_repository_vulnerabilityalert", filters, limit)
	if err != nil {
		return RepoVulnerabilityAlertPaginator{}, err
	}

	p := RepoVulnerabilityAlertPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RepoVulnerabilityAlertPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RepoVulnerabilityAlertPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RepoVulnerabilityAlertPaginator) NextPage(ctx context.Context) ([]RepoVulnerabilityAlert, error) {
	var response RepoVulnerabilityAlertSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RepoVulnerabilityAlert
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRepoVulnerabilityAlertFilters = map[string]string{
	"cvss_score":                   "description.CvssScore",
	"dependency_scope":             "description.DependencyScope",
	"dismiss_comment":              "description.DismissComment",
	"dismiss_reason":               "description.DismissReason",
	"dismisser":                    "description.Dismisser",
	"node_id":                      "description.NodeID",
	"number":                       "description.Number",
	"repository_full_name":         "description.RepositoryFullName",
	"security_advisory":            "description.SecurityAdvisory",
	"security_vulnerability":       "description.SecurityVulnerability",
	"severity":                     "description.Severity",
	"state":                        "description.State",
	"vulnerable_manifest_filename": "description.VulnerableManifestFilename",
	"vulnerable_manifest_path":     "description.VulnerableManifestPath",
	"vulnerable_requirements":      "description.VulnerableRequirements",
}

func ListRepoVulnerabilityAlert(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRepoVulnerabilityAlert")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoVulnerabilityAlert NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoVulnerabilityAlert NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoVulnerabilityAlert GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoVulnerabilityAlert GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoVulnerabilityAlert GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRepoVulnerabilityAlertPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRepoVulnerabilityAlertFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoVulnerabilityAlert NewRepoVulnerabilityAlertPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRepoVulnerabilityAlert paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRepoVulnerabilityAlertFilters = map[string]string{
	"cvss_score":                   "description.CvssScore",
	"dependency_scope":             "description.DependencyScope",
	"dismiss_comment":              "description.DismissComment",
	"dismiss_reason":               "description.DismissReason",
	"dismisser":                    "description.Dismisser",
	"node_id":                      "description.NodeID",
	"number":                       "description.Number",
	"repository_full_name":         "description.RepositoryFullName",
	"security_advisory":            "description.SecurityAdvisory",
	"security_vulnerability":       "description.SecurityVulnerability",
	"severity":                     "description.Severity",
	"state":                        "description.State",
	"vulnerable_manifest_filename": "description.VulnerableManifestFilename",
	"vulnerable_manifest_path":     "description.VulnerableManifestPath",
	"vulnerable_requirements":      "description.VulnerableRequirements",
}

func GetRepoVulnerabilityAlert(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRepoVulnerabilityAlert")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRepoVulnerabilityAlertPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRepoVulnerabilityAlertFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RepoVulnerabilityAlert =============================

// ==========================  START: Tag =============================

type Tag struct {
	ResourceID      string                `json:"resource_id"`
	PlatformID      string                `json:"platform_id"`
	Description     github.TagDescription `json:"description"`
	Metadata        github.Metadata       `json:"metadata"`
	DescribedBy     string                `json:"described_by"`
	ResourceType    string                `json:"resource_type"`
	IntegrationType string                `json:"integration_type"`
	IntegrationID   string                `json:"integration_id"`
}

type TagHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Tag           `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type TagHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []TagHit          `json:"hits"`
}

type TagSearchResponse struct {
	PitID string  `json:"pit_id"`
	Hits  TagHits `json:"hits"`
}

type TagPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewTagPaginator(filters []essdk.BoolFilter, limit *int64) (TagPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_tag", filters, limit)
	if err != nil {
		return TagPaginator{}, err
	}

	p := TagPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p TagPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p TagPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p TagPaginator) NextPage(ctx context.Context) ([]Tag, error) {
	var response TagSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Tag
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listTagFilters = map[string]string{
	"commit":               "description.Commit",
	"message":              "description.Message",
	"name":                 "description.Name",
	"repository_full_name": "description.RepositoryFullName",
	"tagger_login":         "description.TaggerLogin",
	"tagger_name":          "description.TaggerName",
}

func ListTag(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListTag")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListTag NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListTag NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListTag GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListTag GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListTag GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewTagPaginator(essdk.BuildFilter(ctx, d.QueryContext, listTagFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListTag NewTagPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListTag paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getTagFilters = map[string]string{
	"commit":               "description.Commit",
	"message":              "description.Message",
	"name":                 "description.Name",
	"repository_full_name": "description.RepositoryFullName",
	"tagger_login":         "description.TaggerLogin",
	"tagger_name":          "description.TaggerName",
}

func GetTag(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetTag")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewTagPaginator(essdk.BuildFilter(ctx, d.QueryContext, getTagFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Tag =============================

// ==========================  START: Team =============================

type Team struct {
	ResourceID      string                 `json:"resource_id"`
	PlatformID      string                 `json:"platform_id"`
	Description     github.TeamDescription `json:"description"`
	Metadata        github.Metadata        `json:"metadata"`
	DescribedBy     string                 `json:"described_by"`
	ResourceType    string                 `json:"resource_type"`
	IntegrationType string                 `json:"integration_type"`
	IntegrationID   string                 `json:"integration_id"`
}

type TeamHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Team          `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type TeamHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []TeamHit         `json:"hits"`
}

type TeamSearchResponse struct {
	PitID string   `json:"pit_id"`
	Hits  TeamHits `json:"hits"`
}

type TeamPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewTeamPaginator(filters []essdk.BoolFilter, limit *int64) (TeamPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_organization_team", filters, limit)
	if err != nil {
		return TeamPaginator{}, err
	}

	p := TeamPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p TeamPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p TeamPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p TeamPaginator) NextPage(ctx context.Context) ([]Team, error) {
	var response TeamSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Team
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listTeamFilters = map[string]string{
	"ancestors_total_count":    "description.AncestorsTotalCount",
	"avatar_url":               "description.AvatarURL",
	"can_administer":           "description.CanAdminister",
	"can_subscribe":            "description.CanSubscribe",
	"child_teams_total_count":  "description.ChildTeamsTotalCount",
	"combined_slug":            "description.CombinedSlug",
	"description":              "description.Description",
	"discussions_total_count":  "description.DiscussionsTotalCount",
	"discussions_url":          "description.DiscussionsURL",
	"edit_team_url":            "description.EditTeamURL",
	"id":                       "description.ID",
	"invitations_total_count":  "description.InvitationsTotalCount",
	"members_total_count":      "description.MembersTotalCount",
	"members_url":              "description.MembersURL",
	"name":                     "description.Name",
	"new_team_url":             "description.NewTeamURL",
	"node_id":                  "description.NodeID",
	"organization":             "description.Organization",
	"parent_team":              "description.ParentTeam",
	"privacy":                  "description.Privacy",
	"projects_v2_total_count":  "description.ProjectsV2TotalCount",
	"repositories_total_count": "description.RepositoriesTotalCount",
	"repositories_url":         "description.RepositoriesURL",
	"slug":                     "description.Slug",
	"subscription":             "description.Subscription",
	"teams_url":                "description.TeamsURL",
	"url":                      "description.URL",
}

func ListTeam(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListTeam")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeam NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeam NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeam GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeam GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeam GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewTeamPaginator(essdk.BuildFilter(ctx, d.QueryContext, listTeamFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeam NewTeamPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListTeam paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getTeamFilters = map[string]string{
	"ancestors_total_count":    "description.AncestorsTotalCount",
	"avatar_url":               "description.AvatarURL",
	"can_administer":           "description.CanAdminister",
	"can_subscribe":            "description.CanSubscribe",
	"child_teams_total_count":  "description.ChildTeamsTotalCount",
	"combined_slug":            "description.CombinedSlug",
	"description":              "description.Description",
	"discussions_total_count":  "description.DiscussionsTotalCount",
	"discussions_url":          "description.DiscussionsURL",
	"edit_team_url":            "description.EditTeamURL",
	"id":                       "description.ID",
	"invitations_total_count":  "description.InvitationsTotalCount",
	"members_total_count":      "description.MembersTotalCount",
	"members_url":              "description.MembersURL",
	"name":                     "description.Name",
	"new_team_url":             "description.NewTeamURL",
	"node_id":                  "description.NodeID",
	"organization":             "description.Organization",
	"parent_team":              "description.ParentTeam",
	"privacy":                  "description.Privacy",
	"projects_v2_total_count":  "description.ProjectsV2TotalCount",
	"repositories_total_count": "description.RepositoriesTotalCount",
	"repositories_url":         "description.RepositoriesURL",
	"slug":                     "description.Slug",
	"subscription":             "description.Subscription",
	"teams_url":                "description.TeamsURL",
	"url":                      "description.URL",
}

func GetTeam(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetTeam")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewTeamPaginator(essdk.BuildFilter(ctx, d.QueryContext, getTeamFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Team =============================

// ==========================  START: TeamMembers =============================

type TeamMembers struct {
	ResourceID      string                        `json:"resource_id"`
	PlatformID      string                        `json:"platform_id"`
	Description     github.TeamMembersDescription `json:"description"`
	Metadata        github.Metadata               `json:"metadata"`
	DescribedBy     string                        `json:"described_by"`
	ResourceType    string                        `json:"resource_type"`
	IntegrationType string                        `json:"integration_type"`
	IntegrationID   string                        `json:"integration_id"`
}

type TeamMembersHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  TeamMembers   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type TeamMembersHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []TeamMembersHit  `json:"hits"`
}

type TeamMembersSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  TeamMembersHits `json:"hits"`
}

type TeamMembersPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewTeamMembersPaginator(filters []essdk.BoolFilter, limit *int64) (TeamMembersPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_team_member", filters, limit)
	if err != nil {
		return TeamMembersPaginator{}, err
	}

	p := TeamMembersPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p TeamMembersPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p TeamMembersPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p TeamMembersPaginator) NextPage(ctx context.Context) ([]TeamMembers, error) {
	var response TeamMembersSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []TeamMembers
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listTeamMembersFilters = map[string]string{
	"organization": "description.Organization",
	"role":         "description.Role",
	"slug":         "description.Slug",
}

func ListTeamMembers(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListTeamMembers")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeamMembers NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeamMembers NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeamMembers GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeamMembers GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeamMembers GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewTeamMembersPaginator(essdk.BuildFilter(ctx, d.QueryContext, listTeamMembersFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeamMembers NewTeamMembersPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListTeamMembers paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getTeamMembersFilters = map[string]string{
	"organization": "description.Organization",
	"role":         "description.Role",
	"slug":         "description.Slug",
}

func GetTeamMembers(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetTeamMembers")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewTeamMembersPaginator(essdk.BuildFilter(ctx, d.QueryContext, getTeamMembersFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: TeamMembers =============================

// ==========================  START: User =============================

type User struct {
	ResourceID      string                 `json:"resource_id"`
	PlatformID      string                 `json:"platform_id"`
	Description     github.UserDescription `json:"description"`
	Metadata        github.Metadata        `json:"metadata"`
	DescribedBy     string                 `json:"described_by"`
	ResourceType    string                 `json:"resource_type"`
	IntegrationType string                 `json:"integration_type"`
	IntegrationID   string                 `json:"integration_id"`
}

type UserHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  User          `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type UserHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []UserHit         `json:"hits"`
}

type UserSearchResponse struct {
	PitID string   `json:"pit_id"`
	Hits  UserHits `json:"hits"`
}

type UserPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewUserPaginator(filters []essdk.BoolFilter, limit *int64) (UserPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_user", filters, limit)
	if err != nil {
		return UserPaginator{}, err
	}

	p := UserPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p UserPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p UserPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p UserPaginator) NextPage(ctx context.Context) ([]User, error) {
	var response UserSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []User
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listUserFilters = map[string]string{
	"any_pinnable_items":               "description.AnyPinnableItems",
	"avatar_url":                       "description.AvatarUrl",
	"bio":                              "description.Bio",
	"can_changed_pinned_items":         "description.CanChangedPinnedItems",
	"can_create_projects":              "description.CanCreateProjects",
	"can_follow":                       "description.CanFollow",
	"can_sponsor":                      "description.CanSponsor",
	"closed_pull_requests_total_count": "description.ClosedPullRequestsTotalCount",
	"company":                          "description.Company",
	"email":                            "description.Email",
	"estimated_next_sponsors_payout_in_cents": "description.EstimatedNextSponsorsPayoutInCents",
	"followers_total_count":                   "description.FollowersTotalCount",
	"following_total_count":                   "description.FollowingTotalCount",
	"has_sponsors_listing":                    "description.HasSponsorsListing",
	"id":                                      "description.Id",
	"interaction_ability":                     "description.InteractionAbility",
	"is_bounty_hunter":                        "description.IsBountyHunter",
	"is_campus_expert":                        "description.IsCampusExpert",
	"is_developer_program_member":             "description.IsDeveloperProgramMember",
	"is_employee":                             "description.IsEmployee",
	"is_following":                            "description.IsFollowing",
	"is_following_you":                        "description.IsFollowingYou",
	"is_github_star":                          "description.IsGitHubStar",
	"is_hireable":                             "description.IsHireable",
	"is_site_admin":                           "description.IsSiteAdmin",
	"is_sponsoring":                           "description.IsSponsoring",
	"is_sponsoring_you":                       "description.IsSponsoringYou",
	"is_you":                                  "description.IsYou",
	"issues_total_count":                      "description.IssuesTotalCount",
	"location":                                "description.Location",
	"login":                                   "description.Login",
	"merged_pull_requests_total_count":        "description.MergedPullRequestsTotalCount",
	"monthly_estimated_sponsors_income_in_cents": "description.MonthlyEstimatedSponsorsIncomeInCents",
	"name":                             "description.Name",
	"node_id":                          "description.NodeId",
	"open_pull_requests_total_count":   "description.OpenPullRequestsTotalCount",
	"organizations_total_count":        "description.OrganizationsTotalCount",
	"packages_total_count":             "description.PackagesTotalCount",
	"pinned_items_remaining":           "description.PinnedItemsRemaining",
	"pinned_items_total_count":         "description.PinnedItemsTotalCount",
	"private_repositories_total_count": "description.PrivateRepositoriesTotalCount",
	"projects_url":                     "description.ProjectsUrl",
	"pronouns":                         "description.Pronouns",
	"public_gists_total_count":         "description.PublicGistsTotalCount",
	"public_keys_total_count":          "description.PublicKeysTotalCount",
	"public_repositories_total_count":  "description.PublicRepositoriesTotalCount",
	"repositories_total_disk_usage":    "description.RepositoriesTotalDiskUsage",
	"sponsoring_total_count":           "description.SponsoringTotalCount",
	"sponsors_listing":                 "description.SponsorsListing",
	"sponsors_total_count":             "description.SponsorsTotalCount",
	"starred_repositories_total_count": "description.StarredRepositoriesTotalCount",
	"status":                           "description.Status",
	"twitter_username":                 "description.TwitterUsername",
	"url":                              "description.Url",
	"watching_total_count":             "description.WatchingTotalCount",
	"website_url":                      "description.WebsiteUrl",
}

func ListUser(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListUser")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListUser NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListUser NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListUser GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListUser GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListUser GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewUserPaginator(essdk.BuildFilter(ctx, d.QueryContext, listUserFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListUser NewUserPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListUser paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getUserFilters = map[string]string{
	"any_pinnable_items":               "description.AnyPinnableItems",
	"avatar_url":                       "description.AvatarUrl",
	"bio":                              "description.Bio",
	"can_changed_pinned_items":         "description.CanChangedPinnedItems",
	"can_create_projects":              "description.CanCreateProjects",
	"can_follow":                       "description.CanFollow",
	"can_sponsor":                      "description.CanSponsor",
	"closed_pull_requests_total_count": "description.ClosedPullRequestsTotalCount",
	"company":                          "description.Company",
	"email":                            "description.Email",
	"estimated_next_sponsors_payout_in_cents": "description.EstimatedNextSponsorsPayoutInCents",
	"followers_total_count":                   "description.FollowersTotalCount",
	"following_total_count":                   "description.FollowingTotalCount",
	"has_sponsors_listing":                    "description.HasSponsorsListing",
	"id":                                      "description.Id",
	"interaction_ability":                     "description.InteractionAbility",
	"is_bounty_hunter":                        "description.IsBountyHunter",
	"is_campus_expert":                        "description.IsCampusExpert",
	"is_developer_program_member":             "description.IsDeveloperProgramMember",
	"is_employee":                             "description.IsEmployee",
	"is_following":                            "description.IsFollowing",
	"is_following_you":                        "description.IsFollowingYou",
	"is_github_star":                          "description.IsGitHubStar",
	"is_hireable":                             "description.IsHireable",
	"is_site_admin":                           "description.IsSiteAdmin",
	"is_sponsoring":                           "description.IsSponsoring",
	"is_sponsoring_you":                       "description.IsSponsoringYou",
	"is_you":                                  "description.IsYou",
	"issues_total_count":                      "description.IssuesTotalCount",
	"location":                                "description.Location",
	"login":                                   "description.Login",
	"merged_pull_requests_total_count":        "description.MergedPullRequestsTotalCount",
	"monthly_estimated_sponsors_income_in_cents": "description.MonthlyEstimatedSponsorsIncomeInCents",
	"name":                             "description.Name",
	"node_id":                          "description.NodeId",
	"open_pull_requests_total_count":   "description.OpenPullRequestsTotalCount",
	"organizations_total_count":        "description.OrganizationsTotalCount",
	"packages_total_count":             "description.PackagesTotalCount",
	"pinned_items_remaining":           "description.PinnedItemsRemaining",
	"pinned_items_total_count":         "description.PinnedItemsTotalCount",
	"private_repositories_total_count": "description.PrivateRepositoriesTotalCount",
	"projects_url":                     "description.ProjectsUrl",
	"pronouns":                         "description.Pronouns",
	"public_gists_total_count":         "description.PublicGistsTotalCount",
	"public_keys_total_count":          "description.PublicKeysTotalCount",
	"public_repositories_total_count":  "description.PublicRepositoriesTotalCount",
	"repositories_total_disk_usage":    "description.RepositoriesTotalDiskUsage",
	"sponsoring_total_count":           "description.SponsoringTotalCount",
	"sponsors_listing":                 "description.SponsorsListing",
	"sponsors_total_count":             "description.SponsorsTotalCount",
	"starred_repositories_total_count": "description.StarredRepositoriesTotalCount",
	"status":                           "description.Status",
	"twitter_username":                 "description.TwitterUsername",
	"url":                              "description.Url",
	"watching_total_count":             "description.WatchingTotalCount",
	"website_url":                      "description.WebsiteUrl",
}

func GetUser(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetUser")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewUserPaginator(essdk.BuildFilter(ctx, d.QueryContext, getUserFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: User =============================

// ==========================  START: Workflow =============================

type Workflow struct {
	ResourceID      string                     `json:"resource_id"`
	PlatformID      string                     `json:"platform_id"`
	Description     github.WorkflowDescription `json:"description"`
	Metadata        github.Metadata            `json:"metadata"`
	DescribedBy     string                     `json:"described_by"`
	ResourceType    string                     `json:"resource_type"`
	IntegrationType string                     `json:"integration_type"`
	IntegrationID   string                     `json:"integration_id"`
}

type WorkflowHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Workflow      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type WorkflowHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []WorkflowHit     `json:"hits"`
}

type WorkflowSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  WorkflowHits `json:"hits"`
}

type WorkflowPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWorkflowPaginator(filters []essdk.BoolFilter, limit *int64) (WorkflowPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_workflow", filters, limit)
	if err != nil {
		return WorkflowPaginator{}, err
	}

	p := WorkflowPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WorkflowPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WorkflowPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p WorkflowPaginator) NextPage(ctx context.Context) ([]Workflow, error) {
	var response WorkflowSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Workflow
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWorkflowFilters = map[string]string{
	"badge_url":                  "description.BadgeURL",
	"html_url":                   "description.HTMLURL",
	"id":                         "description.ID",
	"name":                       "description.Name",
	"node_id":                    "description.NodeID",
	"path":                       "description.Path",
	"pipeline":                   "description.Pipeline",
	"repository_full_name":       "description.RepositoryFullName",
	"state":                      "description.State",
	"url":                        "description.URL",
	"workflow_file_content":      "description.WorkFlowFileContent",
	"workflow_file_content_json": "description.WorkFlowFileContentJson",
}

func ListWorkflow(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWorkflow")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkflow NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkflow NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkflow GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkflow GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkflow GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewWorkflowPaginator(essdk.BuildFilter(ctx, d.QueryContext, listWorkflowFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkflow NewWorkflowPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListWorkflow paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getWorkflowFilters = map[string]string{
	"badge_url":                  "description.BadgeURL",
	"html_url":                   "description.HTMLURL",
	"id":                         "description.ID",
	"name":                       "description.Name",
	"node_id":                    "description.NodeID",
	"path":                       "description.Path",
	"pipeline":                   "description.Pipeline",
	"repository_full_name":       "description.RepositoryFullName",
	"state":                      "description.State",
	"url":                        "description.URL",
	"workflow_file_content":      "description.WorkFlowFileContent",
	"workflow_file_content_json": "description.WorkFlowFileContentJson",
}

func GetWorkflow(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWorkflow")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewWorkflowPaginator(essdk.BuildFilter(ctx, d.QueryContext, getWorkflowFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Workflow =============================

// ==========================  START: ContainerPackage =============================

type ContainerPackage struct {
	ResourceID      string                             `json:"resource_id"`
	PlatformID      string                             `json:"platform_id"`
	Description     github.ContainerPackageDescription `json:"description"`
	Metadata        github.Metadata                    `json:"metadata"`
	DescribedBy     string                             `json:"described_by"`
	ResourceType    string                             `json:"resource_type"`
	IntegrationType string                             `json:"integration_type"`
	IntegrationID   string                             `json:"integration_id"`
}

type ContainerPackageHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  ContainerPackage `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type ContainerPackageHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []ContainerPackageHit `json:"hits"`
}

type ContainerPackageSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  ContainerPackageHits `json:"hits"`
}

type ContainerPackagePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewContainerPackagePaginator(filters []essdk.BoolFilter, limit *int64) (ContainerPackagePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_container_package", filters, limit)
	if err != nil {
		return ContainerPackagePaginator{}, err
	}

	p := ContainerPackagePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ContainerPackagePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ContainerPackagePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ContainerPackagePaginator) NextPage(ctx context.Context) ([]ContainerPackage, error) {
	var response ContainerPackageSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ContainerPackage
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listContainerPackageFilters = map[string]string{
	"created_at":       "description.CreatedAt",
	"digest":           "description.Digest",
	"html_url":         "description.HTMLURL",
	"id":               "description.ID",
	"manifest":         "description.Manifest",
	"media_type":       "description.MediaType",
	"metadata":         "description.Metadata",
	"name":             "description.Name",
	"package_html_url": "description.PackageHTMLURL",
	"package_uri":      "description.PackageURI",
	"total_size":       "description.TotalSize",
	"updated_at":       "description.UpdatedAt",
}

func ListContainerPackage(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListContainerPackage")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListContainerPackage NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListContainerPackage NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListContainerPackage GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListContainerPackage GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListContainerPackage GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewContainerPackagePaginator(essdk.BuildFilter(ctx, d.QueryContext, listContainerPackageFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListContainerPackage NewContainerPackagePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListContainerPackage paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getContainerPackageFilters = map[string]string{
	"created_at":       "description.CreatedAt",
	"digest":           "description.Digest",
	"html_url":         "description.HTMLURL",
	"id":               "description.ID",
	"manifest":         "description.Manifest",
	"media_type":       "description.MediaType",
	"metadata":         "description.Metadata",
	"name":             "description.Name",
	"package_html_url": "description.PackageHTMLURL",
	"package_uri":      "description.PackageURI",
	"total_size":       "description.TotalSize",
	"updated_at":       "description.UpdatedAt",
}

func GetContainerPackage(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetContainerPackage")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewContainerPackagePaginator(essdk.BuildFilter(ctx, d.QueryContext, getContainerPackageFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ContainerPackage =============================

// ==========================  START: PackageDetail =============================

type PackageDetail struct {
	ResourceID      string                          `json:"resource_id"`
	PlatformID      string                          `json:"platform_id"`
	Description     github.PackageDetailDescription `json:"description"`
	Metadata        github.Metadata                 `json:"metadata"`
	DescribedBy     string                          `json:"described_by"`
	ResourceType    string                          `json:"resource_type"`
	IntegrationType string                          `json:"integration_type"`
	IntegrationID   string                          `json:"integration_id"`
}

type PackageDetailHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  PackageDetail `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type PackageDetailHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []PackageDetailHit `json:"hits"`
}

type PackageDetailSearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  PackageDetailHits `json:"hits"`
}

type PackageDetailPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewPackageDetailPaginator(filters []essdk.BoolFilter, limit *int64) (PackageDetailPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_npm_package", filters, limit)
	if err != nil {
		return PackageDetailPaginator{}, err
	}

	p := PackageDetailPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p PackageDetailPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p PackageDetailPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p PackageDetailPaginator) NextPage(ctx context.Context) ([]PackageDetail, error) {
	var response PackageDetailSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []PackageDetail
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listPackageDetailFilters = map[string]string{}

func ListPackageDetail(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListPackageDetail")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListPackageDetail NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListPackageDetail NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListPackageDetail GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListPackageDetail GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListPackageDetail GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewPackageDetailPaginator(essdk.BuildFilter(ctx, d.QueryContext, listPackageDetailFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListPackageDetail NewPackageDetailPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListPackageDetail paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getPackageDetailFilters = map[string]string{}

func GetPackageDetail(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetPackageDetail")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewPackageDetailPaginator(essdk.BuildFilter(ctx, d.QueryContext, getPackageDetailFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: PackageDetail =============================

// ==========================  START: Package =============================

type Package struct {
	ResourceID      string                    `json:"resource_id"`
	PlatformID      string                    `json:"platform_id"`
	Description     github.PackageDescription `json:"description"`
	Metadata        github.Metadata           `json:"metadata"`
	DescribedBy     string                    `json:"described_by"`
	ResourceType    string                    `json:"resource_type"`
	IntegrationType string                    `json:"integration_type"`
	IntegrationID   string                    `json:"integration_id"`
}

type PackageHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Package       `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type PackageHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []PackageHit      `json:"hits"`
}

type PackageSearchResponse struct {
	PitID string      `json:"pit_id"`
	Hits  PackageHits `json:"hits"`
}

type PackagePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewPackagePaginator(filters []essdk.BoolFilter, limit *int64) (PackagePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_nuget_package", filters, limit)
	if err != nil {
		return PackagePaginator{}, err
	}

	p := PackagePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p PackagePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p PackagePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p PackagePaginator) NextPage(ctx context.Context) ([]Package, error) {
	var response PackageSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Package
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listPackageFilters = map[string]string{}

func ListPackage(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListPackage")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListPackage NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListPackage NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListPackage GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListPackage GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListPackage GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewPackagePaginator(essdk.BuildFilter(ctx, d.QueryContext, listPackageFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListPackage NewPackagePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListPackage paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getPackageFilters = map[string]string{}

func GetPackage(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetPackage")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewPackagePaginator(essdk.BuildFilter(ctx, d.QueryContext, getPackageFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Package =============================

// ==========================  START: ArtifactDockerFile =============================

type ArtifactDockerFile struct {
	ResourceID      string                               `json:"resource_id"`
	PlatformID      string                               `json:"platform_id"`
	Description     github.ArtifactDockerFileDescription `json:"description"`
	Metadata        github.Metadata                      `json:"metadata"`
	DescribedBy     string                               `json:"described_by"`
	ResourceType    string                               `json:"resource_type"`
	IntegrationType string                               `json:"integration_type"`
	IntegrationID   string                               `json:"integration_id"`
}

type ArtifactDockerFileHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  ArtifactDockerFile `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type ArtifactDockerFileHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []ArtifactDockerFileHit `json:"hits"`
}

type ArtifactDockerFileSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  ArtifactDockerFileHits `json:"hits"`
}

type ArtifactDockerFilePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewArtifactDockerFilePaginator(filters []essdk.BoolFilter, limit *int64) (ArtifactDockerFilePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_artifact_dockerfile", filters, limit)
	if err != nil {
		return ArtifactDockerFilePaginator{}, err
	}

	p := ArtifactDockerFilePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ArtifactDockerFilePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ArtifactDockerFilePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ArtifactDockerFilePaginator) NextPage(ctx context.Context) ([]ArtifactDockerFile, error) {
	var response ArtifactDockerFileSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ArtifactDockerFile
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listArtifactDockerFileFilters = map[string]string{
	"dockerfile_content":        "description.DockerfileContent",
	"dockerfile_content_base64": "description.DockerfileContentBase64",
	"git_url":                   "description.GitURL",
	"html_url":                  "description.HTMLURL",
	"images":                    "description.Images",
	"last_updated_at":           "description.LastUpdatedAt",
	"name":                      "description.Name",
	"path":                      "description.Path",
	"repository":                "description.Repository",
	"sha":                       "description.Sha",
	"uri":                       "description.URI",
}

func ListArtifactDockerFile(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListArtifactDockerFile")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListArtifactDockerFile NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListArtifactDockerFile NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListArtifactDockerFile GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListArtifactDockerFile GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListArtifactDockerFile GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewArtifactDockerFilePaginator(essdk.BuildFilter(ctx, d.QueryContext, listArtifactDockerFileFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListArtifactDockerFile NewArtifactDockerFilePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListArtifactDockerFile paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getArtifactDockerFileFilters = map[string]string{
	"dockerfile_content":        "description.DockerfileContent",
	"dockerfile_content_base64": "description.DockerfileContentBase64",
	"git_url":                   "description.GitURL",
	"html_url":                  "description.HTMLURL",
	"images":                    "description.Images",
	"last_updated_at":           "description.LastUpdatedAt",
	"name":                      "description.Name",
	"path":                      "description.Path",
	"repository":                "description.Repository",
	"sha":                       "description.Sha",
	"uri":                       "description.URI",
}

func GetArtifactDockerFile(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetArtifactDockerFile")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewArtifactDockerFilePaginator(essdk.BuildFilter(ctx, d.QueryContext, getArtifactDockerFileFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ArtifactDockerFile =============================
