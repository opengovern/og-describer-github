// Code is generated by go generate. DO NOT EDIT.
package opengovernance

import (
	"context"
	"encoding/json"
	"fmt"
	githubDescriber "github.com/opengovern/og-describer-github/provider/describer"
	github "github.com/opengovern/og-describer-github/provider/model"
	essdk "github.com/opengovern/og-util/pkg/opengovernance-es-sdk"
	steampipesdk "github.com/opengovern/og-util/pkg/steampipe"
	"github.com/turbot/steampipe-plugin-sdk/v5/plugin"
	"runtime"
)

type Client struct {
	essdk.Client
}

// ==========================  START: Artifact =============================

type Artifact struct {
	ResourceID      string                     `json:"resource_id"`
	PlatformID      string                     `json:"platform_id"`
	Description     github.ArtifactDescription `json:"description"`
	DescribedBy     int                        `json:"described_by"`
	ResourceType    string                     `json:"resource_type"`
	IntegrationType string                     `json:"integration_type"`
	IntegrationID   string                     `json:"integration_id"`
}

func (r *Artifact) UnmarshalJSON(b []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(b, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for k, v := range rawMsg {
		switch k {
		case "description":
			wrapper := githubDescriber.JSONAllFieldsMarshaller{
				Value: r.Description,
			}
			if err := json.Unmarshal(v, &wrapper); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
			var ok bool
			r.Description, ok = wrapper.Value.(github.ArtifactDescription)
			if !ok {
				return fmt.Errorf("unmarshalling type %T: %v", r, fmt.Errorf("expected type %T, got %T", r.Description, wrapper.Value))
			}
		case "platform_id":
			if err := json.Unmarshal(v, &r.PlatformID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_id":
			if err := json.Unmarshal(v, &r.ResourceID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_type":
			if err := json.Unmarshal(v, &r.ResourceType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "described_by":
			if err := json.Unmarshal(v, &r.DescribedBy); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_type":
			if err := json.Unmarshal(v, &r.IntegrationType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_id":
			if err := json.Unmarshal(v, &r.IntegrationID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		default:
		}
	}
	return nil
}

type ArtifactHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Artifact      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ArtifactHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []ArtifactHit     `json:"hits"`
}

type ArtifactSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  ArtifactHits `json:"hits"`
}

type ArtifactPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewArtifactPaginator(filters []essdk.BoolFilter, limit *int64) (ArtifactPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_actions_artifact", filters, limit)
	if err != nil {
		return ArtifactPaginator{}, err
	}

	p := ArtifactPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ArtifactPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ArtifactPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ArtifactPaginator) NextPage(ctx context.Context) ([]Artifact, error) {
	var response ArtifactSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Artifact
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listArtifactFilters = map[string]string{
	"archive_download_url": "ArchiveDownloadURL",
}

func ListArtifact(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListArtifact")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListArtifact NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListArtifact NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListArtifact GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListArtifact GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListArtifact GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewArtifactPaginator(essdk.BuildFilter(ctx, d.QueryContext, listArtifactFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListArtifact NewArtifactPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListArtifact paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getArtifactFilters = map[string]string{
	"archive_download_url": "ArchiveDownloadURL",
}

func GetArtifact(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetArtifact")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewArtifactPaginator(essdk.BuildFilter(ctx, d.QueryContext, getArtifactFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Artifact =============================

// ==========================  START: Runner =============================

type Runner struct {
	ResourceID      string                   `json:"resource_id"`
	PlatformID      string                   `json:"platform_id"`
	Description     github.RunnerDescription `json:"description"`
	DescribedBy     int                      `json:"described_by"`
	ResourceType    string                   `json:"resource_type"`
	IntegrationType string                   `json:"integration_type"`
	IntegrationID   string                   `json:"integration_id"`
}

func (r *Runner) UnmarshalJSON(b []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(b, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for k, v := range rawMsg {
		switch k {
		case "description":
			wrapper := githubDescriber.JSONAllFieldsMarshaller{
				Value: r.Description,
			}
			if err := json.Unmarshal(v, &wrapper); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
			var ok bool
			r.Description, ok = wrapper.Value.(github.RunnerDescription)
			if !ok {
				return fmt.Errorf("unmarshalling type %T: %v", r, fmt.Errorf("expected type %T, got %T", r.Description, wrapper.Value))
			}
		case "platform_id":
			if err := json.Unmarshal(v, &r.PlatformID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_id":
			if err := json.Unmarshal(v, &r.ResourceID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_type":
			if err := json.Unmarshal(v, &r.ResourceType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "described_by":
			if err := json.Unmarshal(v, &r.DescribedBy); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_type":
			if err := json.Unmarshal(v, &r.IntegrationType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_id":
			if err := json.Unmarshal(v, &r.IntegrationID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		default:
		}
	}
	return nil
}

type RunnerHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Runner        `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type RunnerHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []RunnerHit       `json:"hits"`
}

type RunnerSearchResponse struct {
	PitID string     `json:"pit_id"`
	Hits  RunnerHits `json:"hits"`
}

type RunnerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRunnerPaginator(filters []essdk.BoolFilter, limit *int64) (RunnerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_actions_repository_runner", filters, limit)
	if err != nil {
		return RunnerPaginator{}, err
	}

	p := RunnerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RunnerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RunnerPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RunnerPaginator) NextPage(ctx context.Context) ([]Runner, error) {
	var response RunnerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Runner
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRunnerFilters = map[string]string{
	"os": "OS",
}

func ListRunner(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRunner")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRunner NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRunner NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRunner GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRunner GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRunner GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRunnerPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRunnerFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRunner NewRunnerPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRunner paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRunnerFilters = map[string]string{
	"os": "OS",
}

func GetRunner(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRunner")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRunnerPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRunnerFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Runner =============================

// ==========================  START: Secret =============================

type Secret struct {
	ResourceID      string                   `json:"resource_id"`
	PlatformID      string                   `json:"platform_id"`
	Description     github.SecretDescription `json:"description"`
	DescribedBy     int                      `json:"described_by"`
	ResourceType    string                   `json:"resource_type"`
	IntegrationType string                   `json:"integration_type"`
	IntegrationID   string                   `json:"integration_id"`
}

func (r *Secret) UnmarshalJSON(b []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(b, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for k, v := range rawMsg {
		switch k {
		case "description":
			wrapper := githubDescriber.JSONAllFieldsMarshaller{
				Value: r.Description,
			}
			if err := json.Unmarshal(v, &wrapper); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
			var ok bool
			r.Description, ok = wrapper.Value.(github.SecretDescription)
			if !ok {
				return fmt.Errorf("unmarshalling type %T: %v", r, fmt.Errorf("expected type %T, got %T", r.Description, wrapper.Value))
			}
		case "platform_id":
			if err := json.Unmarshal(v, &r.PlatformID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_id":
			if err := json.Unmarshal(v, &r.ResourceID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_type":
			if err := json.Unmarshal(v, &r.ResourceType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "described_by":
			if err := json.Unmarshal(v, &r.DescribedBy); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_type":
			if err := json.Unmarshal(v, &r.IntegrationType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_id":
			if err := json.Unmarshal(v, &r.IntegrationID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		default:
		}
	}
	return nil
}

type SecretHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Secret        `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type SecretHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []SecretHit       `json:"hits"`
}

type SecretSearchResponse struct {
	PitID string     `json:"pit_id"`
	Hits  SecretHits `json:"hits"`
}

type SecretPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSecretPaginator(filters []essdk.BoolFilter, limit *int64) (SecretPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_actions_repository_secret", filters, limit)
	if err != nil {
		return SecretPaginator{}, err
	}

	p := SecretPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SecretPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SecretPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SecretPaginator) NextPage(ctx context.Context) ([]Secret, error) {
	var response SecretSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Secret
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSecretFilters = map[string]string{
	"selected_repositories_url": "SelectedRepositoriesURL",
}

func ListSecret(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSecret")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecret NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecret NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecret GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecret GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecret GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSecretPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSecretFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecret NewSecretPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSecret paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSecretFilters = map[string]string{
	"selected_repositories_url": "SelectedRepositoriesURL",
}

func GetSecret(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSecret")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSecretPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSecretFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Secret =============================

// ==========================  START: WorkflowRun =============================

type WorkflowRun struct {
	ResourceID      string                        `json:"resource_id"`
	PlatformID      string                        `json:"platform_id"`
	Description     github.WorkflowRunDescription `json:"description"`
	DescribedBy     int                           `json:"described_by"`
	ResourceType    string                        `json:"resource_type"`
	IntegrationType string                        `json:"integration_type"`
	IntegrationID   string                        `json:"integration_id"`
}

func (r *WorkflowRun) UnmarshalJSON(b []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(b, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for k, v := range rawMsg {
		switch k {
		case "description":
			wrapper := githubDescriber.JSONAllFieldsMarshaller{
				Value: r.Description,
			}
			if err := json.Unmarshal(v, &wrapper); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
			var ok bool
			r.Description, ok = wrapper.Value.(github.WorkflowRunDescription)
			if !ok {
				return fmt.Errorf("unmarshalling type %T: %v", r, fmt.Errorf("expected type %T, got %T", r.Description, wrapper.Value))
			}
		case "platform_id":
			if err := json.Unmarshal(v, &r.PlatformID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_id":
			if err := json.Unmarshal(v, &r.ResourceID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_type":
			if err := json.Unmarshal(v, &r.ResourceType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "described_by":
			if err := json.Unmarshal(v, &r.DescribedBy); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_type":
			if err := json.Unmarshal(v, &r.IntegrationType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_id":
			if err := json.Unmarshal(v, &r.IntegrationID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		default:
		}
	}
	return nil
}

type WorkflowRunHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  WorkflowRun   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type WorkflowRunHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []WorkflowRunHit  `json:"hits"`
}

type WorkflowRunSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  WorkflowRunHits `json:"hits"`
}

type WorkflowRunPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWorkflowRunPaginator(filters []essdk.BoolFilter, limit *int64) (WorkflowRunPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_actions_repository_workflow_run", filters, limit)
	if err != nil {
		return WorkflowRunPaginator{}, err
	}

	p := WorkflowRunPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WorkflowRunPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WorkflowRunPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p WorkflowRunPaginator) NextPage(ctx context.Context) ([]WorkflowRun, error) {
	var response WorkflowRunSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []WorkflowRun
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWorkflowRunFilters = map[string]string{
	"actor_login":            "Actor.Login",
	"head_sha":               "HeadSHA",
	"html_url":               "HTMLURL",
	"triggering_actor_login": "TriggeringActor.Login",
	"url":                    "URL",
}

func ListWorkflowRun(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWorkflowRun")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkflowRun NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkflowRun NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkflowRun GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkflowRun GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkflowRun GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewWorkflowRunPaginator(essdk.BuildFilter(ctx, d.QueryContext, listWorkflowRunFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkflowRun NewWorkflowRunPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListWorkflowRun paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getWorkflowRunFilters = map[string]string{
	"actor_login":            "Actor.Login",
	"head_sha":               "HeadSHA",
	"html_url":               "HTMLURL",
	"triggering_actor_login": "TriggeringActor.Login",
	"url":                    "URL",
}

func GetWorkflowRun(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWorkflowRun")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewWorkflowRunPaginator(essdk.BuildFilter(ctx, d.QueryContext, getWorkflowRunFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: WorkflowRun =============================

// ==========================  START: AuditLog =============================

type AuditLog struct {
	ResourceID      string                     `json:"resource_id"`
	PlatformID      string                     `json:"platform_id"`
	Description     github.AuditLogDescription `json:"description"`
	DescribedBy     int                        `json:"described_by"`
	ResourceType    string                     `json:"resource_type"`
	IntegrationType string                     `json:"integration_type"`
	IntegrationID   string                     `json:"integration_id"`
}

func (r *AuditLog) UnmarshalJSON(b []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(b, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for k, v := range rawMsg {
		switch k {
		case "description":
			wrapper := githubDescriber.JSONAllFieldsMarshaller{
				Value: r.Description,
			}
			if err := json.Unmarshal(v, &wrapper); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
			var ok bool
			r.Description, ok = wrapper.Value.(github.AuditLogDescription)
			if !ok {
				return fmt.Errorf("unmarshalling type %T: %v", r, fmt.Errorf("expected type %T, got %T", r.Description, wrapper.Value))
			}
		case "platform_id":
			if err := json.Unmarshal(v, &r.PlatformID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_id":
			if err := json.Unmarshal(v, &r.ResourceID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_type":
			if err := json.Unmarshal(v, &r.ResourceType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "described_by":
			if err := json.Unmarshal(v, &r.DescribedBy); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_type":
			if err := json.Unmarshal(v, &r.IntegrationType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_id":
			if err := json.Unmarshal(v, &r.IntegrationID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		default:
		}
	}
	return nil
}

type AuditLogHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  AuditLog      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type AuditLogHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []AuditLogHit     `json:"hits"`
}

type AuditLogSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  AuditLogHits `json:"hits"`
}

type AuditLogPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAuditLogPaginator(filters []essdk.BoolFilter, limit *int64) (AuditLogPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_auditlog", filters, limit)
	if err != nil {
		return AuditLogPaginator{}, err
	}

	p := AuditLogPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AuditLogPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AuditLogPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AuditLogPaginator) NextPage(ctx context.Context) ([]AuditLog, error) {
	var response AuditLogSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AuditLog
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAuditLogFilters = map[string]string{
	"id":         "DocumentID",
	"user_login": "User",
}

func ListAuditLog(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAuditLog")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAuditLog NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAuditLog NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAuditLog GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAuditLog GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAuditLog GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAuditLogPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAuditLogFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAuditLog NewAuditLogPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAuditLog paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAuditLogFilters = map[string]string{
	"id":         "DocumentID",
	"user_login": "User",
}

func GetAuditLog(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAuditLog")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAuditLogPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAuditLogFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: AuditLog =============================

// ==========================  START: Blob =============================

type Blob struct {
	ResourceID      string                 `json:"resource_id"`
	PlatformID      string                 `json:"platform_id"`
	Description     github.BlobDescription `json:"description"`
	DescribedBy     int                    `json:"described_by"`
	ResourceType    string                 `json:"resource_type"`
	IntegrationType string                 `json:"integration_type"`
	IntegrationID   string                 `json:"integration_id"`
}

func (r *Blob) UnmarshalJSON(b []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(b, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for k, v := range rawMsg {
		switch k {
		case "description":
			wrapper := githubDescriber.JSONAllFieldsMarshaller{
				Value: r.Description,
			}
			if err := json.Unmarshal(v, &wrapper); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
			var ok bool
			r.Description, ok = wrapper.Value.(github.BlobDescription)
			if !ok {
				return fmt.Errorf("unmarshalling type %T: %v", r, fmt.Errorf("expected type %T, got %T", r.Description, wrapper.Value))
			}
		case "platform_id":
			if err := json.Unmarshal(v, &r.PlatformID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_id":
			if err := json.Unmarshal(v, &r.ResourceID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_type":
			if err := json.Unmarshal(v, &r.ResourceType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "described_by":
			if err := json.Unmarshal(v, &r.DescribedBy); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_type":
			if err := json.Unmarshal(v, &r.IntegrationType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_id":
			if err := json.Unmarshal(v, &r.IntegrationID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		default:
		}
	}
	return nil
}

type BlobHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Blob          `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type BlobHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []BlobHit         `json:"hits"`
}

type BlobSearchResponse struct {
	PitID string   `json:"pit_id"`
	Hits  BlobHits `json:"hits"`
}

type BlobPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewBlobPaginator(filters []essdk.BoolFilter, limit *int64) (BlobPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_blob", filters, limit)
	if err != nil {
		return BlobPaginator{}, err
	}

	p := BlobPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p BlobPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p BlobPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p BlobPaginator) NextPage(ctx context.Context) ([]Blob, error) {
	var response BlobSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Blob
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listBlobFilters = map[string]string{
	"blob_sha": "Sha",
	"node_id":  "NodeID",
}

func ListBlob(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListBlob")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListBlob NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListBlob NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListBlob GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListBlob GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListBlob GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewBlobPaginator(essdk.BuildFilter(ctx, d.QueryContext, listBlobFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListBlob NewBlobPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListBlob paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getBlobFilters = map[string]string{
	"blob_sha": "Sha",
	"node_id":  "NodeID",
}

func GetBlob(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetBlob")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewBlobPaginator(essdk.BuildFilter(ctx, d.QueryContext, getBlobFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Blob =============================

// ==========================  START: Branch =============================

type Branch struct {
	ResourceID      string                   `json:"resource_id"`
	PlatformID      string                   `json:"platform_id"`
	Description     github.BranchDescription `json:"description"`
	DescribedBy     int                      `json:"described_by"`
	ResourceType    string                   `json:"resource_type"`
	IntegrationType string                   `json:"integration_type"`
	IntegrationID   string                   `json:"integration_id"`
}

func (r *Branch) UnmarshalJSON(b []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(b, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for k, v := range rawMsg {
		switch k {
		case "description":
			wrapper := githubDescriber.JSONAllFieldsMarshaller{
				Value: r.Description,
			}
			if err := json.Unmarshal(v, &wrapper); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
			var ok bool
			r.Description, ok = wrapper.Value.(github.BranchDescription)
			if !ok {
				return fmt.Errorf("unmarshalling type %T: %v", r, fmt.Errorf("expected type %T, got %T", r.Description, wrapper.Value))
			}
		case "platform_id":
			if err := json.Unmarshal(v, &r.PlatformID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_id":
			if err := json.Unmarshal(v, &r.ResourceID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_type":
			if err := json.Unmarshal(v, &r.ResourceType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "described_by":
			if err := json.Unmarshal(v, &r.DescribedBy); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_type":
			if err := json.Unmarshal(v, &r.IntegrationType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_id":
			if err := json.Unmarshal(v, &r.IntegrationID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		default:
		}
	}
	return nil
}

type BranchHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Branch        `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type BranchHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []BranchHit       `json:"hits"`
}

type BranchSearchResponse struct {
	PitID string     `json:"pit_id"`
	Hits  BranchHits `json:"hits"`
}

type BranchPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewBranchPaginator(filters []essdk.BoolFilter, limit *int64) (BranchPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_branch", filters, limit)
	if err != nil {
		return BranchPaginator{}, err
	}

	p := BranchPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p BranchPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p BranchPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p BranchPaginator) NextPage(ctx context.Context) ([]Branch, error) {
	var response BranchSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Branch
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listBranchFilters = map[string]string{
	"commit": "Target.Commit",
}

func ListBranch(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListBranch")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListBranch NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListBranch NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListBranch GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListBranch GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListBranch GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewBranchPaginator(essdk.BuildFilter(ctx, d.QueryContext, listBranchFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListBranch NewBranchPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListBranch paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getBranchFilters = map[string]string{
	"commit": "Target.Commit",
}

func GetBranch(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetBranch")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewBranchPaginator(essdk.BuildFilter(ctx, d.QueryContext, getBranchFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Branch =============================

// ==========================  START: BranchProtection =============================

type BranchProtection struct {
	ResourceID      string                             `json:"resource_id"`
	PlatformID      string                             `json:"platform_id"`
	Description     github.BranchProtectionDescription `json:"description"`
	DescribedBy     int                                `json:"described_by"`
	ResourceType    string                             `json:"resource_type"`
	IntegrationType string                             `json:"integration_type"`
	IntegrationID   string                             `json:"integration_id"`
}

func (r *BranchProtection) UnmarshalJSON(b []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(b, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for k, v := range rawMsg {
		switch k {
		case "description":
			wrapper := githubDescriber.JSONAllFieldsMarshaller{
				Value: r.Description,
			}
			if err := json.Unmarshal(v, &wrapper); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
			var ok bool
			r.Description, ok = wrapper.Value.(github.BranchProtectionDescription)
			if !ok {
				return fmt.Errorf("unmarshalling type %T: %v", r, fmt.Errorf("expected type %T, got %T", r.Description, wrapper.Value))
			}
		case "platform_id":
			if err := json.Unmarshal(v, &r.PlatformID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_id":
			if err := json.Unmarshal(v, &r.ResourceID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_type":
			if err := json.Unmarshal(v, &r.ResourceType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "described_by":
			if err := json.Unmarshal(v, &r.DescribedBy); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_type":
			if err := json.Unmarshal(v, &r.IntegrationType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_id":
			if err := json.Unmarshal(v, &r.IntegrationID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		default:
		}
	}
	return nil
}

type BranchProtectionHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  BranchProtection `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type BranchProtectionHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []BranchProtectionHit `json:"hits"`
}

type BranchProtectionSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  BranchProtectionHits `json:"hits"`
}

type BranchProtectionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewBranchProtectionPaginator(filters []essdk.BoolFilter, limit *int64) (BranchProtectionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_branch_protection", filters, limit)
	if err != nil {
		return BranchProtectionPaginator{}, err
	}

	p := BranchProtectionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p BranchProtectionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p BranchProtectionPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p BranchProtectionPaginator) NextPage(ctx context.Context) ([]BranchProtection, error) {
	var response BranchProtectionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []BranchProtection
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listBranchProtectionFilters = map[string]string{}

func ListBranchProtection(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListBranchProtection")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListBranchProtection NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListBranchProtection NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListBranchProtection GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListBranchProtection GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListBranchProtection GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewBranchProtectionPaginator(essdk.BuildFilter(ctx, d.QueryContext, listBranchProtectionFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListBranchProtection NewBranchProtectionPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListBranchProtection paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getBranchProtectionFilters = map[string]string{}

func GetBranchProtection(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetBranchProtection")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewBranchProtectionPaginator(essdk.BuildFilter(ctx, d.QueryContext, getBranchProtectionFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: BranchProtection =============================

// ==========================  START: Commit =============================

type Commit struct {
	ResourceID      string                   `json:"resource_id"`
	PlatformID      string                   `json:"platform_id"`
	Description     github.CommitDescription `json:"description"`
	DescribedBy     int                      `json:"described_by"`
	ResourceType    string                   `json:"resource_type"`
	IntegrationType string                   `json:"integration_type"`
	IntegrationID   string                   `json:"integration_id"`
}

func (r *Commit) UnmarshalJSON(b []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(b, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for k, v := range rawMsg {
		switch k {
		case "description":
			wrapper := githubDescriber.JSONAllFieldsMarshaller{
				Value: r.Description,
			}
			if err := json.Unmarshal(v, &wrapper); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
			var ok bool
			r.Description, ok = wrapper.Value.(github.CommitDescription)
			if !ok {
				return fmt.Errorf("unmarshalling type %T: %v", r, fmt.Errorf("expected type %T, got %T", r.Description, wrapper.Value))
			}
		case "platform_id":
			if err := json.Unmarshal(v, &r.PlatformID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_id":
			if err := json.Unmarshal(v, &r.ResourceID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_type":
			if err := json.Unmarshal(v, &r.ResourceType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "described_by":
			if err := json.Unmarshal(v, &r.DescribedBy); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_type":
			if err := json.Unmarshal(v, &r.IntegrationType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_id":
			if err := json.Unmarshal(v, &r.IntegrationID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		default:
		}
	}
	return nil
}

type CommitHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Commit        `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type CommitHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []CommitHit       `json:"hits"`
}

type CommitSearchResponse struct {
	PitID string     `json:"pit_id"`
	Hits  CommitHits `json:"hits"`
}

type CommitPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCommitPaginator(filters []essdk.BoolFilter, limit *int64) (CommitPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_commit", filters, limit)
	if err != nil {
		return CommitPaginator{}, err
	}

	p := CommitPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CommitPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CommitPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CommitPaginator) NextPage(ctx context.Context) ([]Commit, error) {
	var response CommitSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Commit
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCommitFilters = map[string]string{}

func ListCommit(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCommit")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCommit NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCommit NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCommit GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCommit GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCommit GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCommitPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCommitFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCommit NewCommitPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCommit paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCommitFilters = map[string]string{}

func GetCommit(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCommit")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCommitPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCommitFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Commit =============================

// ==========================  START: CommunityProfile =============================

type CommunityProfile struct {
	ResourceID      string                             `json:"resource_id"`
	PlatformID      string                             `json:"platform_id"`
	Description     github.CommunityProfileDescription `json:"description"`
	DescribedBy     int                                `json:"described_by"`
	ResourceType    string                             `json:"resource_type"`
	IntegrationType string                             `json:"integration_type"`
	IntegrationID   string                             `json:"integration_id"`
}

func (r *CommunityProfile) UnmarshalJSON(b []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(b, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for k, v := range rawMsg {
		switch k {
		case "description":
			wrapper := githubDescriber.JSONAllFieldsMarshaller{
				Value: r.Description,
			}
			if err := json.Unmarshal(v, &wrapper); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
			var ok bool
			r.Description, ok = wrapper.Value.(github.CommunityProfileDescription)
			if !ok {
				return fmt.Errorf("unmarshalling type %T: %v", r, fmt.Errorf("expected type %T, got %T", r.Description, wrapper.Value))
			}
		case "platform_id":
			if err := json.Unmarshal(v, &r.PlatformID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_id":
			if err := json.Unmarshal(v, &r.ResourceID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_type":
			if err := json.Unmarshal(v, &r.ResourceType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "described_by":
			if err := json.Unmarshal(v, &r.DescribedBy); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_type":
			if err := json.Unmarshal(v, &r.IntegrationType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_id":
			if err := json.Unmarshal(v, &r.IntegrationID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		default:
		}
	}
	return nil
}

type CommunityProfileHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  CommunityProfile `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type CommunityProfileHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []CommunityProfileHit `json:"hits"`
}

type CommunityProfileSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  CommunityProfileHits `json:"hits"`
}

type CommunityProfilePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCommunityProfilePaginator(filters []essdk.BoolFilter, limit *int64) (CommunityProfilePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_communityprofile", filters, limit)
	if err != nil {
		return CommunityProfilePaginator{}, err
	}

	p := CommunityProfilePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CommunityProfilePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CommunityProfilePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CommunityProfilePaginator) NextPage(ctx context.Context) ([]CommunityProfile, error) {
	var response CommunityProfileSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CommunityProfile
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCommunityProfileFilters = map[string]string{}

func ListCommunityProfile(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCommunityProfile")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCommunityProfile NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCommunityProfile NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCommunityProfile GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCommunityProfile GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCommunityProfile GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCommunityProfilePaginator(essdk.BuildFilter(ctx, d.QueryContext, listCommunityProfileFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCommunityProfile NewCommunityProfilePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCommunityProfile paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCommunityProfileFilters = map[string]string{}

func GetCommunityProfile(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCommunityProfile")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCommunityProfilePaginator(essdk.BuildFilter(ctx, d.QueryContext, getCommunityProfileFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CommunityProfile =============================

// ==========================  START: GitIgnore =============================

type GitIgnore struct {
	ResourceID      string                      `json:"resource_id"`
	PlatformID      string                      `json:"platform_id"`
	Description     github.GitIgnoreDescription `json:"description"`
	DescribedBy     int                         `json:"described_by"`
	ResourceType    string                      `json:"resource_type"`
	IntegrationType string                      `json:"integration_type"`
	IntegrationID   string                      `json:"integration_id"`
}

func (r *GitIgnore) UnmarshalJSON(b []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(b, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for k, v := range rawMsg {
		switch k {
		case "description":
			wrapper := githubDescriber.JSONAllFieldsMarshaller{
				Value: r.Description,
			}
			if err := json.Unmarshal(v, &wrapper); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
			var ok bool
			r.Description, ok = wrapper.Value.(github.GitIgnoreDescription)
			if !ok {
				return fmt.Errorf("unmarshalling type %T: %v", r, fmt.Errorf("expected type %T, got %T", r.Description, wrapper.Value))
			}
		case "platform_id":
			if err := json.Unmarshal(v, &r.PlatformID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_id":
			if err := json.Unmarshal(v, &r.ResourceID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_type":
			if err := json.Unmarshal(v, &r.ResourceType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "described_by":
			if err := json.Unmarshal(v, &r.DescribedBy); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_type":
			if err := json.Unmarshal(v, &r.IntegrationType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_id":
			if err := json.Unmarshal(v, &r.IntegrationID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		default:
		}
	}
	return nil
}

type GitIgnoreHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  GitIgnore     `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type GitIgnoreHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []GitIgnoreHit    `json:"hits"`
}

type GitIgnoreSearchResponse struct {
	PitID string        `json:"pit_id"`
	Hits  GitIgnoreHits `json:"hits"`
}

type GitIgnorePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGitIgnorePaginator(filters []essdk.BoolFilter, limit *int64) (GitIgnorePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_gitignore", filters, limit)
	if err != nil {
		return GitIgnorePaginator{}, err
	}

	p := GitIgnorePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GitIgnorePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GitIgnorePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p GitIgnorePaginator) NextPage(ctx context.Context) ([]GitIgnore, error) {
	var response GitIgnoreSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GitIgnore
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGitIgnoreFilters = map[string]string{}

func ListGitIgnore(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGitIgnore")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListGitIgnore NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListGitIgnore NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListGitIgnore GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListGitIgnore GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListGitIgnore GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewGitIgnorePaginator(essdk.BuildFilter(ctx, d.QueryContext, listGitIgnoreFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListGitIgnore NewGitIgnorePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListGitIgnore paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getGitIgnoreFilters = map[string]string{}

func GetGitIgnore(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGitIgnore")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewGitIgnorePaginator(essdk.BuildFilter(ctx, d.QueryContext, getGitIgnoreFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: GitIgnore =============================

// ==========================  START: Gist =============================

type Gist struct {
	ResourceID      string                 `json:"resource_id"`
	PlatformID      string                 `json:"platform_id"`
	Description     github.GistDescription `json:"description"`
	DescribedBy     int                    `json:"described_by"`
	ResourceType    string                 `json:"resource_type"`
	IntegrationType string                 `json:"integration_type"`
	IntegrationID   string                 `json:"integration_id"`
}

func (r *Gist) UnmarshalJSON(b []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(b, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for k, v := range rawMsg {
		switch k {
		case "description":
			wrapper := githubDescriber.JSONAllFieldsMarshaller{
				Value: r.Description,
			}
			if err := json.Unmarshal(v, &wrapper); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
			var ok bool
			r.Description, ok = wrapper.Value.(github.GistDescription)
			if !ok {
				return fmt.Errorf("unmarshalling type %T: %v", r, fmt.Errorf("expected type %T, got %T", r.Description, wrapper.Value))
			}
		case "platform_id":
			if err := json.Unmarshal(v, &r.PlatformID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_id":
			if err := json.Unmarshal(v, &r.ResourceID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_type":
			if err := json.Unmarshal(v, &r.ResourceType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "described_by":
			if err := json.Unmarshal(v, &r.DescribedBy); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_type":
			if err := json.Unmarshal(v, &r.IntegrationType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_id":
			if err := json.Unmarshal(v, &r.IntegrationID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		default:
		}
	}
	return nil
}

type GistHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Gist          `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type GistHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []GistHit         `json:"hits"`
}

type GistSearchResponse struct {
	PitID string   `json:"pit_id"`
	Hits  GistHits `json:"hits"`
}

type GistPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGistPaginator(filters []essdk.BoolFilter, limit *int64) (GistPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_gist", filters, limit)
	if err != nil {
		return GistPaginator{}, err
	}

	p := GistPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GistPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GistPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p GistPaginator) NextPage(ctx context.Context) ([]Gist, error) {
	var response GistSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Gist
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGistFilters = map[string]string{}

func ListGist(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGist")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListGist NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListGist NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListGist GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListGist GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListGist GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewGistPaginator(essdk.BuildFilter(ctx, d.QueryContext, listGistFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListGist NewGistPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListGist paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getGistFilters = map[string]string{}

func GetGist(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGist")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewGistPaginator(essdk.BuildFilter(ctx, d.QueryContext, getGistFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Gist =============================

// ==========================  START: Organization =============================

type Organization struct {
	ResourceID      string                         `json:"resource_id"`
	PlatformID      string                         `json:"platform_id"`
	Description     github.OrganizationDescription `json:"description"`
	DescribedBy     int                            `json:"described_by"`
	ResourceType    string                         `json:"resource_type"`
	IntegrationType string                         `json:"integration_type"`
	IntegrationID   string                         `json:"integration_id"`
}

func (r *Organization) UnmarshalJSON(b []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(b, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for k, v := range rawMsg {
		switch k {
		case "description":
			wrapper := githubDescriber.JSONAllFieldsMarshaller{
				Value: r.Description,
			}
			if err := json.Unmarshal(v, &wrapper); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
			var ok bool
			r.Description, ok = wrapper.Value.(github.OrganizationDescription)
			if !ok {
				return fmt.Errorf("unmarshalling type %T: %v", r, fmt.Errorf("expected type %T, got %T", r.Description, wrapper.Value))
			}
		case "platform_id":
			if err := json.Unmarshal(v, &r.PlatformID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_id":
			if err := json.Unmarshal(v, &r.ResourceID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_type":
			if err := json.Unmarshal(v, &r.ResourceType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "described_by":
			if err := json.Unmarshal(v, &r.DescribedBy); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_type":
			if err := json.Unmarshal(v, &r.IntegrationType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_id":
			if err := json.Unmarshal(v, &r.IntegrationID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		default:
		}
	}
	return nil
}

type OrganizationHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Organization  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type OrganizationHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []OrganizationHit `json:"hits"`
}

type OrganizationSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  OrganizationHits `json:"hits"`
}

type OrganizationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewOrganizationPaginator(filters []essdk.BoolFilter, limit *int64) (OrganizationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_organization", filters, limit)
	if err != nil {
		return OrganizationPaginator{}, err
	}

	p := OrganizationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p OrganizationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p OrganizationPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p OrganizationPaginator) NextPage(ctx context.Context) ([]Organization, error) {
	var response OrganizationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Organization
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listOrganizationFilters = map[string]string{}

func ListOrganization(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListOrganization")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganization NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganization NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganization GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganization GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganization GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewOrganizationPaginator(essdk.BuildFilter(ctx, d.QueryContext, listOrganizationFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganization NewOrganizationPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListOrganization paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getOrganizationFilters = map[string]string{}

func GetOrganization(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetOrganization")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewOrganizationPaginator(essdk.BuildFilter(ctx, d.QueryContext, getOrganizationFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Organization =============================

// ==========================  START: OrgCollaborators =============================

type OrgCollaborators struct {
	ResourceID      string                             `json:"resource_id"`
	PlatformID      string                             `json:"platform_id"`
	Description     github.OrgCollaboratorsDescription `json:"description"`
	DescribedBy     int                                `json:"described_by"`
	ResourceType    string                             `json:"resource_type"`
	IntegrationType string                             `json:"integration_type"`
	IntegrationID   string                             `json:"integration_id"`
}

func (r *OrgCollaborators) UnmarshalJSON(b []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(b, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for k, v := range rawMsg {
		switch k {
		case "description":
			wrapper := githubDescriber.JSONAllFieldsMarshaller{
				Value: r.Description,
			}
			if err := json.Unmarshal(v, &wrapper); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
			var ok bool
			r.Description, ok = wrapper.Value.(github.OrgCollaboratorsDescription)
			if !ok {
				return fmt.Errorf("unmarshalling type %T: %v", r, fmt.Errorf("expected type %T, got %T", r.Description, wrapper.Value))
			}
		case "platform_id":
			if err := json.Unmarshal(v, &r.PlatformID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_id":
			if err := json.Unmarshal(v, &r.ResourceID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_type":
			if err := json.Unmarshal(v, &r.ResourceType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "described_by":
			if err := json.Unmarshal(v, &r.DescribedBy); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_type":
			if err := json.Unmarshal(v, &r.IntegrationType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_id":
			if err := json.Unmarshal(v, &r.IntegrationID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		default:
		}
	}
	return nil
}

type OrgCollaboratorsHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  OrgCollaborators `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type OrgCollaboratorsHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []OrgCollaboratorsHit `json:"hits"`
}

type OrgCollaboratorsSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  OrgCollaboratorsHits `json:"hits"`
}

type OrgCollaboratorsPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewOrgCollaboratorsPaginator(filters []essdk.BoolFilter, limit *int64) (OrgCollaboratorsPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_organization_collaborator", filters, limit)
	if err != nil {
		return OrgCollaboratorsPaginator{}, err
	}

	p := OrgCollaboratorsPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p OrgCollaboratorsPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p OrgCollaboratorsPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p OrgCollaboratorsPaginator) NextPage(ctx context.Context) ([]OrgCollaborators, error) {
	var response OrgCollaboratorsSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []OrgCollaborators
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listOrgCollaboratorsFilters = map[string]string{}

func ListOrgCollaborators(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListOrgCollaborators")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgCollaborators NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgCollaborators NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgCollaborators GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgCollaborators GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgCollaborators GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewOrgCollaboratorsPaginator(essdk.BuildFilter(ctx, d.QueryContext, listOrgCollaboratorsFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgCollaborators NewOrgCollaboratorsPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListOrgCollaborators paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getOrgCollaboratorsFilters = map[string]string{}

func GetOrgCollaborators(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetOrgCollaborators")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewOrgCollaboratorsPaginator(essdk.BuildFilter(ctx, d.QueryContext, getOrgCollaboratorsFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: OrgCollaborators =============================

// ==========================  START: OrgAlertDependabot =============================

type OrgAlertDependabot struct {
	ResourceID      string                               `json:"resource_id"`
	PlatformID      string                               `json:"platform_id"`
	Description     github.OrgAlertDependabotDescription `json:"description"`
	DescribedBy     int                                  `json:"described_by"`
	ResourceType    string                               `json:"resource_type"`
	IntegrationType string                               `json:"integration_type"`
	IntegrationID   string                               `json:"integration_id"`
}

func (r *OrgAlertDependabot) UnmarshalJSON(b []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(b, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for k, v := range rawMsg {
		switch k {
		case "description":
			wrapper := githubDescriber.JSONAllFieldsMarshaller{
				Value: r.Description,
			}
			if err := json.Unmarshal(v, &wrapper); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
			var ok bool
			r.Description, ok = wrapper.Value.(github.OrgAlertDependabotDescription)
			if !ok {
				return fmt.Errorf("unmarshalling type %T: %v", r, fmt.Errorf("expected type %T, got %T", r.Description, wrapper.Value))
			}
		case "platform_id":
			if err := json.Unmarshal(v, &r.PlatformID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_id":
			if err := json.Unmarshal(v, &r.ResourceID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_type":
			if err := json.Unmarshal(v, &r.ResourceType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "described_by":
			if err := json.Unmarshal(v, &r.DescribedBy); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_type":
			if err := json.Unmarshal(v, &r.IntegrationType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_id":
			if err := json.Unmarshal(v, &r.IntegrationID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		default:
		}
	}
	return nil
}

type OrgAlertDependabotHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  OrgAlertDependabot `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type OrgAlertDependabotHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []OrgAlertDependabotHit `json:"hits"`
}

type OrgAlertDependabotSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  OrgAlertDependabotHits `json:"hits"`
}

type OrgAlertDependabotPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewOrgAlertDependabotPaginator(filters []essdk.BoolFilter, limit *int64) (OrgAlertDependabotPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_organization_dependabotalert", filters, limit)
	if err != nil {
		return OrgAlertDependabotPaginator{}, err
	}

	p := OrgAlertDependabotPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p OrgAlertDependabotPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p OrgAlertDependabotPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p OrgAlertDependabotPaginator) NextPage(ctx context.Context) ([]OrgAlertDependabot, error) {
	var response OrgAlertDependabotSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []OrgAlertDependabot
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listOrgAlertDependabotFilters = map[string]string{
	"alert_number":                         "Number",
	"dependency_manifest_path":             "Dependency.ManifestPath",
	"dependency_package_ecosystem":         "Dependency.Package.Ecosystem",
	"dependency_package_name":              "Dependency.Package.Name",
	"dependency_scope":                     "Dependency.Scope",
	"security_advisory_cve_id":             "SecurityAdvisory.CVEID",
	"security_advisory_cvss_score":         "SecurityAdvisory.CVSS.Score",
	"security_advisory_cvss_vector_string": "SecurityAdvisory.CVSS.VectorString",
	"security_advisory_cwes":               "SecurityAdvisory.CWEs",
	"security_advisory_description":        "SecurityAdvisory.Description",
	"security_advisory_ghsa_id":            "SecurityAdvisory.GHSAID",
	"security_advisory_severity":           "SecurityAdvisory.Severity",
	"security_advisory_summary":            "SecurityAdvisory.Summary",
}

func ListOrgAlertDependabot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListOrgAlertDependabot")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgAlertDependabot NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgAlertDependabot NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgAlertDependabot GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgAlertDependabot GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgAlertDependabot GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewOrgAlertDependabotPaginator(essdk.BuildFilter(ctx, d.QueryContext, listOrgAlertDependabotFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgAlertDependabot NewOrgAlertDependabotPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListOrgAlertDependabot paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getOrgAlertDependabotFilters = map[string]string{
	"alert_number":                         "Number",
	"dependency_manifest_path":             "Dependency.ManifestPath",
	"dependency_package_ecosystem":         "Dependency.Package.Ecosystem",
	"dependency_package_name":              "Dependency.Package.Name",
	"dependency_scope":                     "Dependency.Scope",
	"security_advisory_cve_id":             "SecurityAdvisory.CVEID",
	"security_advisory_cvss_score":         "SecurityAdvisory.CVSS.Score",
	"security_advisory_cvss_vector_string": "SecurityAdvisory.CVSS.VectorString",
	"security_advisory_cwes":               "SecurityAdvisory.CWEs",
	"security_advisory_description":        "SecurityAdvisory.Description",
	"security_advisory_ghsa_id":            "SecurityAdvisory.GHSAID",
	"security_advisory_severity":           "SecurityAdvisory.Severity",
	"security_advisory_summary":            "SecurityAdvisory.Summary",
}

func GetOrgAlertDependabot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetOrgAlertDependabot")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewOrgAlertDependabotPaginator(essdk.BuildFilter(ctx, d.QueryContext, getOrgAlertDependabotFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: OrgAlertDependabot =============================

// ==========================  START: OrgExternalIdentity =============================

type OrgExternalIdentity struct {
	ResourceID      string                                `json:"resource_id"`
	PlatformID      string                                `json:"platform_id"`
	Description     github.OrgExternalIdentityDescription `json:"description"`
	DescribedBy     int                                   `json:"described_by"`
	ResourceType    string                                `json:"resource_type"`
	IntegrationType string                                `json:"integration_type"`
	IntegrationID   string                                `json:"integration_id"`
}

func (r *OrgExternalIdentity) UnmarshalJSON(b []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(b, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for k, v := range rawMsg {
		switch k {
		case "description":
			wrapper := githubDescriber.JSONAllFieldsMarshaller{
				Value: r.Description,
			}
			if err := json.Unmarshal(v, &wrapper); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
			var ok bool
			r.Description, ok = wrapper.Value.(github.OrgExternalIdentityDescription)
			if !ok {
				return fmt.Errorf("unmarshalling type %T: %v", r, fmt.Errorf("expected type %T, got %T", r.Description, wrapper.Value))
			}
		case "platform_id":
			if err := json.Unmarshal(v, &r.PlatformID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_id":
			if err := json.Unmarshal(v, &r.ResourceID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_type":
			if err := json.Unmarshal(v, &r.ResourceType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "described_by":
			if err := json.Unmarshal(v, &r.DescribedBy); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_type":
			if err := json.Unmarshal(v, &r.IntegrationType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_id":
			if err := json.Unmarshal(v, &r.IntegrationID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		default:
		}
	}
	return nil
}

type OrgExternalIdentityHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  OrgExternalIdentity `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type OrgExternalIdentityHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []OrgExternalIdentityHit `json:"hits"`
}

type OrgExternalIdentitySearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  OrgExternalIdentityHits `json:"hits"`
}

type OrgExternalIdentityPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewOrgExternalIdentityPaginator(filters []essdk.BoolFilter, limit *int64) (OrgExternalIdentityPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_organization_externalidentity", filters, limit)
	if err != nil {
		return OrgExternalIdentityPaginator{}, err
	}

	p := OrgExternalIdentityPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p OrgExternalIdentityPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p OrgExternalIdentityPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p OrgExternalIdentityPaginator) NextPage(ctx context.Context) ([]OrgExternalIdentity, error) {
	var response OrgExternalIdentitySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []OrgExternalIdentity
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listOrgExternalIdentityFilters = map[string]string{}

func ListOrgExternalIdentity(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListOrgExternalIdentity")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgExternalIdentity NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgExternalIdentity NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgExternalIdentity GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgExternalIdentity GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgExternalIdentity GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewOrgExternalIdentityPaginator(essdk.BuildFilter(ctx, d.QueryContext, listOrgExternalIdentityFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgExternalIdentity NewOrgExternalIdentityPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListOrgExternalIdentity paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getOrgExternalIdentityFilters = map[string]string{}

func GetOrgExternalIdentity(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetOrgExternalIdentity")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewOrgExternalIdentityPaginator(essdk.BuildFilter(ctx, d.QueryContext, getOrgExternalIdentityFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: OrgExternalIdentity =============================

// ==========================  START: OrgMembers =============================

type OrgMembers struct {
	ResourceID      string                       `json:"resource_id"`
	PlatformID      string                       `json:"platform_id"`
	Description     github.OrgMembersDescription `json:"description"`
	DescribedBy     int                          `json:"described_by"`
	ResourceType    string                       `json:"resource_type"`
	IntegrationType string                       `json:"integration_type"`
	IntegrationID   string                       `json:"integration_id"`
}

func (r *OrgMembers) UnmarshalJSON(b []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(b, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for k, v := range rawMsg {
		switch k {
		case "description":
			wrapper := githubDescriber.JSONAllFieldsMarshaller{
				Value: r.Description,
			}
			if err := json.Unmarshal(v, &wrapper); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
			var ok bool
			r.Description, ok = wrapper.Value.(github.OrgMembersDescription)
			if !ok {
				return fmt.Errorf("unmarshalling type %T: %v", r, fmt.Errorf("expected type %T, got %T", r.Description, wrapper.Value))
			}
		case "platform_id":
			if err := json.Unmarshal(v, &r.PlatformID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_id":
			if err := json.Unmarshal(v, &r.ResourceID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_type":
			if err := json.Unmarshal(v, &r.ResourceType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "described_by":
			if err := json.Unmarshal(v, &r.DescribedBy); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_type":
			if err := json.Unmarshal(v, &r.IntegrationType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_id":
			if err := json.Unmarshal(v, &r.IntegrationID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		default:
		}
	}
	return nil
}

type OrgMembersHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  OrgMembers    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type OrgMembersHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []OrgMembersHit   `json:"hits"`
}

type OrgMembersSearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  OrgMembersHits `json:"hits"`
}

type OrgMembersPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewOrgMembersPaginator(filters []essdk.BoolFilter, limit *int64) (OrgMembersPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_organization_member", filters, limit)
	if err != nil {
		return OrgMembersPaginator{}, err
	}

	p := OrgMembersPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p OrgMembersPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p OrgMembersPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p OrgMembersPaginator) NextPage(ctx context.Context) ([]OrgMembers, error) {
	var response OrgMembersSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []OrgMembers
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listOrgMembersFilters = map[string]string{}

func ListOrgMembers(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListOrgMembers")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgMembers NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgMembers NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgMembers GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgMembers GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgMembers GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewOrgMembersPaginator(essdk.BuildFilter(ctx, d.QueryContext, listOrgMembersFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgMembers NewOrgMembersPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListOrgMembers paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getOrgMembersFilters = map[string]string{}

func GetOrgMembers(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetOrgMembers")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewOrgMembersPaginator(essdk.BuildFilter(ctx, d.QueryContext, getOrgMembersFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: OrgMembers =============================

// ==========================  START: PullRequest =============================

type PullRequest struct {
	ResourceID      string                        `json:"resource_id"`
	PlatformID      string                        `json:"platform_id"`
	Description     github.PullRequestDescription `json:"description"`
	DescribedBy     int                           `json:"described_by"`
	ResourceType    string                        `json:"resource_type"`
	IntegrationType string                        `json:"integration_type"`
	IntegrationID   string                        `json:"integration_id"`
}

func (r *PullRequest) UnmarshalJSON(b []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(b, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for k, v := range rawMsg {
		switch k {
		case "description":
			wrapper := githubDescriber.JSONAllFieldsMarshaller{
				Value: r.Description,
			}
			if err := json.Unmarshal(v, &wrapper); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
			var ok bool
			r.Description, ok = wrapper.Value.(github.PullRequestDescription)
			if !ok {
				return fmt.Errorf("unmarshalling type %T: %v", r, fmt.Errorf("expected type %T, got %T", r.Description, wrapper.Value))
			}
		case "platform_id":
			if err := json.Unmarshal(v, &r.PlatformID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_id":
			if err := json.Unmarshal(v, &r.ResourceID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_type":
			if err := json.Unmarshal(v, &r.ResourceType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "described_by":
			if err := json.Unmarshal(v, &r.DescribedBy); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_type":
			if err := json.Unmarshal(v, &r.IntegrationType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_id":
			if err := json.Unmarshal(v, &r.IntegrationID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		default:
		}
	}
	return nil
}

type PullRequestHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  PullRequest   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type PullRequestHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []PullRequestHit  `json:"hits"`
}

type PullRequestSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  PullRequestHits `json:"hits"`
}

type PullRequestPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewPullRequestPaginator(filters []essdk.BoolFilter, limit *int64) (PullRequestPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_pullrequest", filters, limit)
	if err != nil {
		return PullRequestPaginator{}, err
	}

	p := PullRequestPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p PullRequestPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p PullRequestPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p PullRequestPaginator) NextPage(ctx context.Context) ([]PullRequest, error) {
	var response PullRequestSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []PullRequest
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listPullRequestFilters = map[string]string{
	"number":               "Number",
	"repository_full_name": "Repo.NameWithOwner",
}

func ListPullRequest(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListPullRequest")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListPullRequest NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListPullRequest NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListPullRequest GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListPullRequest GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListPullRequest GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewPullRequestPaginator(essdk.BuildFilter(ctx, d.QueryContext, listPullRequestFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListPullRequest NewPullRequestPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListPullRequest paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getPullRequestFilters = map[string]string{
	"number":               "Number",
	"repository_full_name": "Repo.NameWithOwner",
}

func GetPullRequest(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetPullRequest")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewPullRequestPaginator(essdk.BuildFilter(ctx, d.QueryContext, getPullRequestFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: PullRequest =============================

// ==========================  START: Repository =============================

type Repository struct {
	ResourceID      string                       `json:"resource_id"`
	PlatformID      string                       `json:"platform_id"`
	Description     github.RepositoryDescription `json:"description"`
	DescribedBy     int                          `json:"described_by"`
	ResourceType    string                       `json:"resource_type"`
	IntegrationType string                       `json:"integration_type"`
	IntegrationID   string                       `json:"integration_id"`
}

func (r *Repository) UnmarshalJSON(b []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(b, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for k, v := range rawMsg {
		switch k {
		case "description":
			wrapper := githubDescriber.JSONAllFieldsMarshaller{
				Value: r.Description,
			}
			if err := json.Unmarshal(v, &wrapper); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
			var ok bool
			r.Description, ok = wrapper.Value.(github.RepositoryDescription)
			if !ok {
				return fmt.Errorf("unmarshalling type %T: %v", r, fmt.Errorf("expected type %T, got %T", r.Description, wrapper.Value))
			}
		case "platform_id":
			if err := json.Unmarshal(v, &r.PlatformID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_id":
			if err := json.Unmarshal(v, &r.ResourceID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_type":
			if err := json.Unmarshal(v, &r.ResourceType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "described_by":
			if err := json.Unmarshal(v, &r.DescribedBy); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_type":
			if err := json.Unmarshal(v, &r.IntegrationType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_id":
			if err := json.Unmarshal(v, &r.IntegrationID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		default:
		}
	}
	return nil
}

type RepositoryHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Repository    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type RepositoryHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []RepositoryHit   `json:"hits"`
}

type RepositorySearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  RepositoryHits `json:"hits"`
}

type RepositoryPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRepositoryPaginator(filters []essdk.BoolFilter, limit *int64) (RepositoryPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_repository", filters, limit)
	if err != nil {
		return RepositoryPaginator{}, err
	}

	p := RepositoryPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RepositoryPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RepositoryPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RepositoryPaginator) NextPage(ctx context.Context) ([]Repository, error) {
	var response RepositorySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Repository
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRepositoryFilters = map[string]string{}

func ListRepository(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRepository")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepository NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepository NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepository GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepository GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepository GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRepositoryPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRepositoryFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepository NewRepositoryPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRepository paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRepositoryFilters = map[string]string{}

func GetRepository(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRepository")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRepositoryPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRepositoryFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Repository =============================

// ==========================  START: RepoCollaborators =============================

type RepoCollaborators struct {
	ResourceID      string                              `json:"resource_id"`
	PlatformID      string                              `json:"platform_id"`
	Description     github.RepoCollaboratorsDescription `json:"description"`
	DescribedBy     int                                 `json:"described_by"`
	ResourceType    string                              `json:"resource_type"`
	IntegrationType string                              `json:"integration_type"`
	IntegrationID   string                              `json:"integration_id"`
}

func (r *RepoCollaborators) UnmarshalJSON(b []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(b, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for k, v := range rawMsg {
		switch k {
		case "description":
			wrapper := githubDescriber.JSONAllFieldsMarshaller{
				Value: r.Description,
			}
			if err := json.Unmarshal(v, &wrapper); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
			var ok bool
			r.Description, ok = wrapper.Value.(github.RepoCollaboratorsDescription)
			if !ok {
				return fmt.Errorf("unmarshalling type %T: %v", r, fmt.Errorf("expected type %T, got %T", r.Description, wrapper.Value))
			}
		case "platform_id":
			if err := json.Unmarshal(v, &r.PlatformID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_id":
			if err := json.Unmarshal(v, &r.ResourceID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_type":
			if err := json.Unmarshal(v, &r.ResourceType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "described_by":
			if err := json.Unmarshal(v, &r.DescribedBy); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_type":
			if err := json.Unmarshal(v, &r.IntegrationType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_id":
			if err := json.Unmarshal(v, &r.IntegrationID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		default:
		}
	}
	return nil
}

type RepoCollaboratorsHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  RepoCollaborators `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type RepoCollaboratorsHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []RepoCollaboratorsHit `json:"hits"`
}

type RepoCollaboratorsSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  RepoCollaboratorsHits `json:"hits"`
}

type RepoCollaboratorsPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRepoCollaboratorsPaginator(filters []essdk.BoolFilter, limit *int64) (RepoCollaboratorsPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_repository_collaborator", filters, limit)
	if err != nil {
		return RepoCollaboratorsPaginator{}, err
	}

	p := RepoCollaboratorsPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RepoCollaboratorsPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RepoCollaboratorsPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RepoCollaboratorsPaginator) NextPage(ctx context.Context) ([]RepoCollaborators, error) {
	var response RepoCollaboratorsSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RepoCollaborators
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRepoCollaboratorsFilters = map[string]string{}

func ListRepoCollaborators(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRepoCollaborators")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoCollaborators NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoCollaborators NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoCollaborators GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoCollaborators GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoCollaborators GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRepoCollaboratorsPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRepoCollaboratorsFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoCollaborators NewRepoCollaboratorsPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRepoCollaborators paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRepoCollaboratorsFilters = map[string]string{}

func GetRepoCollaborators(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRepoCollaborators")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRepoCollaboratorsPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRepoCollaboratorsFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RepoCollaborators =============================

// ==========================  START: RepoAlertDependabot =============================

type RepoAlertDependabot struct {
	ResourceID      string                                `json:"resource_id"`
	PlatformID      string                                `json:"platform_id"`
	Description     github.RepoAlertDependabotDescription `json:"description"`
	DescribedBy     int                                   `json:"described_by"`
	ResourceType    string                                `json:"resource_type"`
	IntegrationType string                                `json:"integration_type"`
	IntegrationID   string                                `json:"integration_id"`
}

func (r *RepoAlertDependabot) UnmarshalJSON(b []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(b, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for k, v := range rawMsg {
		switch k {
		case "description":
			wrapper := githubDescriber.JSONAllFieldsMarshaller{
				Value: r.Description,
			}
			if err := json.Unmarshal(v, &wrapper); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
			var ok bool
			r.Description, ok = wrapper.Value.(github.RepoAlertDependabotDescription)
			if !ok {
				return fmt.Errorf("unmarshalling type %T: %v", r, fmt.Errorf("expected type %T, got %T", r.Description, wrapper.Value))
			}
		case "platform_id":
			if err := json.Unmarshal(v, &r.PlatformID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_id":
			if err := json.Unmarshal(v, &r.ResourceID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_type":
			if err := json.Unmarshal(v, &r.ResourceType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "described_by":
			if err := json.Unmarshal(v, &r.DescribedBy); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_type":
			if err := json.Unmarshal(v, &r.IntegrationType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_id":
			if err := json.Unmarshal(v, &r.IntegrationID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		default:
		}
	}
	return nil
}

type RepoAlertDependabotHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  RepoAlertDependabot `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type RepoAlertDependabotHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []RepoAlertDependabotHit `json:"hits"`
}

type RepoAlertDependabotSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  RepoAlertDependabotHits `json:"hits"`
}

type RepoAlertDependabotPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRepoAlertDependabotPaginator(filters []essdk.BoolFilter, limit *int64) (RepoAlertDependabotPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_repository_dependabotalert", filters, limit)
	if err != nil {
		return RepoAlertDependabotPaginator{}, err
	}

	p := RepoAlertDependabotPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RepoAlertDependabotPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RepoAlertDependabotPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RepoAlertDependabotPaginator) NextPage(ctx context.Context) ([]RepoAlertDependabot, error) {
	var response RepoAlertDependabotSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RepoAlertDependabot
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRepoAlertDependabotFilters = map[string]string{}

func ListRepoAlertDependabot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRepoAlertDependabot")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoAlertDependabot NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoAlertDependabot NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoAlertDependabot GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoAlertDependabot GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoAlertDependabot GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRepoAlertDependabotPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRepoAlertDependabotFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoAlertDependabot NewRepoAlertDependabotPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRepoAlertDependabot paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRepoAlertDependabotFilters = map[string]string{}

func GetRepoAlertDependabot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRepoAlertDependabot")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRepoAlertDependabotPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRepoAlertDependabotFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RepoAlertDependabot =============================

// ==========================  START: RepoDeployment =============================

type RepoDeployment struct {
	ResourceID      string                           `json:"resource_id"`
	PlatformID      string                           `json:"platform_id"`
	Description     github.RepoDeploymentDescription `json:"description"`
	DescribedBy     int                              `json:"described_by"`
	ResourceType    string                           `json:"resource_type"`
	IntegrationType string                           `json:"integration_type"`
	IntegrationID   string                           `json:"integration_id"`
}

func (r *RepoDeployment) UnmarshalJSON(b []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(b, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for k, v := range rawMsg {
		switch k {
		case "description":
			wrapper := githubDescriber.JSONAllFieldsMarshaller{
				Value: r.Description,
			}
			if err := json.Unmarshal(v, &wrapper); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
			var ok bool
			r.Description, ok = wrapper.Value.(github.RepoDeploymentDescription)
			if !ok {
				return fmt.Errorf("unmarshalling type %T: %v", r, fmt.Errorf("expected type %T, got %T", r.Description, wrapper.Value))
			}
		case "platform_id":
			if err := json.Unmarshal(v, &r.PlatformID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_id":
			if err := json.Unmarshal(v, &r.ResourceID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_type":
			if err := json.Unmarshal(v, &r.ResourceType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "described_by":
			if err := json.Unmarshal(v, &r.DescribedBy); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_type":
			if err := json.Unmarshal(v, &r.IntegrationType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_id":
			if err := json.Unmarshal(v, &r.IntegrationID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		default:
		}
	}
	return nil
}

type RepoDeploymentHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  RepoDeployment `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type RepoDeploymentHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []RepoDeploymentHit `json:"hits"`
}

type RepoDeploymentSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  RepoDeploymentHits `json:"hits"`
}

type RepoDeploymentPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRepoDeploymentPaginator(filters []essdk.BoolFilter, limit *int64) (RepoDeploymentPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_repository_deployment", filters, limit)
	if err != nil {
		return RepoDeploymentPaginator{}, err
	}

	p := RepoDeploymentPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RepoDeploymentPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RepoDeploymentPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RepoDeploymentPaginator) NextPage(ctx context.Context) ([]RepoDeployment, error) {
	var response RepoDeploymentSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RepoDeployment
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRepoDeploymentFilters = map[string]string{}

func ListRepoDeployment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRepoDeployment")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoDeployment NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoDeployment NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoDeployment GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoDeployment GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoDeployment GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRepoDeploymentPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRepoDeploymentFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoDeployment NewRepoDeploymentPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRepoDeployment paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRepoDeploymentFilters = map[string]string{}

func GetRepoDeployment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRepoDeployment")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRepoDeploymentPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRepoDeploymentFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RepoDeployment =============================

// ==========================  START: RepoEnvironment =============================

type RepoEnvironment struct {
	ResourceID      string                            `json:"resource_id"`
	PlatformID      string                            `json:"platform_id"`
	Description     github.RepoEnvironmentDescription `json:"description"`
	DescribedBy     int                               `json:"described_by"`
	ResourceType    string                            `json:"resource_type"`
	IntegrationType string                            `json:"integration_type"`
	IntegrationID   string                            `json:"integration_id"`
}

func (r *RepoEnvironment) UnmarshalJSON(b []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(b, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for k, v := range rawMsg {
		switch k {
		case "description":
			wrapper := githubDescriber.JSONAllFieldsMarshaller{
				Value: r.Description,
			}
			if err := json.Unmarshal(v, &wrapper); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
			var ok bool
			r.Description, ok = wrapper.Value.(github.RepoEnvironmentDescription)
			if !ok {
				return fmt.Errorf("unmarshalling type %T: %v", r, fmt.Errorf("expected type %T, got %T", r.Description, wrapper.Value))
			}
		case "platform_id":
			if err := json.Unmarshal(v, &r.PlatformID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_id":
			if err := json.Unmarshal(v, &r.ResourceID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_type":
			if err := json.Unmarshal(v, &r.ResourceType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "described_by":
			if err := json.Unmarshal(v, &r.DescribedBy); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_type":
			if err := json.Unmarshal(v, &r.IntegrationType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_id":
			if err := json.Unmarshal(v, &r.IntegrationID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		default:
		}
	}
	return nil
}

type RepoEnvironmentHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  RepoEnvironment `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type RepoEnvironmentHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []RepoEnvironmentHit `json:"hits"`
}

type RepoEnvironmentSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  RepoEnvironmentHits `json:"hits"`
}

type RepoEnvironmentPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRepoEnvironmentPaginator(filters []essdk.BoolFilter, limit *int64) (RepoEnvironmentPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_repository_environment", filters, limit)
	if err != nil {
		return RepoEnvironmentPaginator{}, err
	}

	p := RepoEnvironmentPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RepoEnvironmentPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RepoEnvironmentPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RepoEnvironmentPaginator) NextPage(ctx context.Context) ([]RepoEnvironment, error) {
	var response RepoEnvironmentSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RepoEnvironment
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRepoEnvironmentFilters = map[string]string{}

func ListRepoEnvironment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRepoEnvironment")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoEnvironment NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoEnvironment NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoEnvironment GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoEnvironment GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoEnvironment GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRepoEnvironmentPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRepoEnvironmentFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoEnvironment NewRepoEnvironmentPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRepoEnvironment paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRepoEnvironmentFilters = map[string]string{}

func GetRepoEnvironment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRepoEnvironment")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRepoEnvironmentPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRepoEnvironmentFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RepoEnvironment =============================

// ==========================  START: RepoRuleSet =============================

type RepoRuleSet struct {
	ResourceID      string                        `json:"resource_id"`
	PlatformID      string                        `json:"platform_id"`
	Description     github.RepoRuleSetDescription `json:"description"`
	DescribedBy     int                           `json:"described_by"`
	ResourceType    string                        `json:"resource_type"`
	IntegrationType string                        `json:"integration_type"`
	IntegrationID   string                        `json:"integration_id"`
}

func (r *RepoRuleSet) UnmarshalJSON(b []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(b, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for k, v := range rawMsg {
		switch k {
		case "description":
			wrapper := githubDescriber.JSONAllFieldsMarshaller{
				Value: r.Description,
			}
			if err := json.Unmarshal(v, &wrapper); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
			var ok bool
			r.Description, ok = wrapper.Value.(github.RepoRuleSetDescription)
			if !ok {
				return fmt.Errorf("unmarshalling type %T: %v", r, fmt.Errorf("expected type %T, got %T", r.Description, wrapper.Value))
			}
		case "platform_id":
			if err := json.Unmarshal(v, &r.PlatformID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_id":
			if err := json.Unmarshal(v, &r.ResourceID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_type":
			if err := json.Unmarshal(v, &r.ResourceType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "described_by":
			if err := json.Unmarshal(v, &r.DescribedBy); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_type":
			if err := json.Unmarshal(v, &r.IntegrationType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_id":
			if err := json.Unmarshal(v, &r.IntegrationID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		default:
		}
	}
	return nil
}

type RepoRuleSetHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  RepoRuleSet   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type RepoRuleSetHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []RepoRuleSetHit  `json:"hits"`
}

type RepoRuleSetSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  RepoRuleSetHits `json:"hits"`
}

type RepoRuleSetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRepoRuleSetPaginator(filters []essdk.BoolFilter, limit *int64) (RepoRuleSetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_repository_ruleset", filters, limit)
	if err != nil {
		return RepoRuleSetPaginator{}, err
	}

	p := RepoRuleSetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RepoRuleSetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RepoRuleSetPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RepoRuleSetPaginator) NextPage(ctx context.Context) ([]RepoRuleSet, error) {
	var response RepoRuleSetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RepoRuleSet
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRepoRuleSetFilters = map[string]string{}

func ListRepoRuleSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRepoRuleSet")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoRuleSet NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoRuleSet NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoRuleSet GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoRuleSet GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoRuleSet GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRepoRuleSetPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRepoRuleSetFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoRuleSet NewRepoRuleSetPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRepoRuleSet paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRepoRuleSetFilters = map[string]string{}

func GetRepoRuleSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRepoRuleSet")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRepoRuleSetPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRepoRuleSetFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RepoRuleSet =============================

// ==========================  START: RepoSBOM =============================

type RepoSBOM struct {
	ResourceID      string                     `json:"resource_id"`
	PlatformID      string                     `json:"platform_id"`
	Description     github.RepoSBOMDescription `json:"description"`
	DescribedBy     int                        `json:"described_by"`
	ResourceType    string                     `json:"resource_type"`
	IntegrationType string                     `json:"integration_type"`
	IntegrationID   string                     `json:"integration_id"`
}

func (r *RepoSBOM) UnmarshalJSON(b []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(b, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for k, v := range rawMsg {
		switch k {
		case "description":
			wrapper := githubDescriber.JSONAllFieldsMarshaller{
				Value: r.Description,
			}
			if err := json.Unmarshal(v, &wrapper); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
			var ok bool
			r.Description, ok = wrapper.Value.(github.RepoSBOMDescription)
			if !ok {
				return fmt.Errorf("unmarshalling type %T: %v", r, fmt.Errorf("expected type %T, got %T", r.Description, wrapper.Value))
			}
		case "platform_id":
			if err := json.Unmarshal(v, &r.PlatformID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_id":
			if err := json.Unmarshal(v, &r.ResourceID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_type":
			if err := json.Unmarshal(v, &r.ResourceType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "described_by":
			if err := json.Unmarshal(v, &r.DescribedBy); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_type":
			if err := json.Unmarshal(v, &r.IntegrationType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_id":
			if err := json.Unmarshal(v, &r.IntegrationID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		default:
		}
	}
	return nil
}

type RepoSBOMHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  RepoSBOM      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type RepoSBOMHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []RepoSBOMHit     `json:"hits"`
}

type RepoSBOMSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  RepoSBOMHits `json:"hits"`
}

type RepoSBOMPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRepoSBOMPaginator(filters []essdk.BoolFilter, limit *int64) (RepoSBOMPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_repository_sbom", filters, limit)
	if err != nil {
		return RepoSBOMPaginator{}, err
	}

	p := RepoSBOMPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RepoSBOMPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RepoSBOMPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RepoSBOMPaginator) NextPage(ctx context.Context) ([]RepoSBOM, error) {
	var response RepoSBOMSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RepoSBOM
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRepoSBOMFilters = map[string]string{
	"spdx_id":      "SPDXID",
	"spdx_version": "SPDXVersion",
}

func ListRepoSBOM(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRepoSBOM")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoSBOM NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoSBOM NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoSBOM GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoSBOM GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoSBOM GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRepoSBOMPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRepoSBOMFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoSBOM NewRepoSBOMPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRepoSBOM paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRepoSBOMFilters = map[string]string{
	"spdx_id":      "SPDXID",
	"spdx_version": "SPDXVersion",
}

func GetRepoSBOM(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRepoSBOM")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRepoSBOMPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRepoSBOMFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RepoSBOM =============================

// ==========================  START: RepoVulnerabilityAlert =============================

type RepoVulnerabilityAlert struct {
	ResourceID      string                                   `json:"resource_id"`
	PlatformID      string                                   `json:"platform_id"`
	Description     github.RepoVulnerabilityAlertDescription `json:"description"`
	DescribedBy     int                                      `json:"described_by"`
	ResourceType    string                                   `json:"resource_type"`
	IntegrationType string                                   `json:"integration_type"`
	IntegrationID   string                                   `json:"integration_id"`
}

func (r *RepoVulnerabilityAlert) UnmarshalJSON(b []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(b, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for k, v := range rawMsg {
		switch k {
		case "description":
			wrapper := githubDescriber.JSONAllFieldsMarshaller{
				Value: r.Description,
			}
			if err := json.Unmarshal(v, &wrapper); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
			var ok bool
			r.Description, ok = wrapper.Value.(github.RepoVulnerabilityAlertDescription)
			if !ok {
				return fmt.Errorf("unmarshalling type %T: %v", r, fmt.Errorf("expected type %T, got %T", r.Description, wrapper.Value))
			}
		case "platform_id":
			if err := json.Unmarshal(v, &r.PlatformID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_id":
			if err := json.Unmarshal(v, &r.ResourceID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_type":
			if err := json.Unmarshal(v, &r.ResourceType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "described_by":
			if err := json.Unmarshal(v, &r.DescribedBy); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_type":
			if err := json.Unmarshal(v, &r.IntegrationType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_id":
			if err := json.Unmarshal(v, &r.IntegrationID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		default:
		}
	}
	return nil
}

type RepoVulnerabilityAlertHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  RepoVulnerabilityAlert `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type RepoVulnerabilityAlertHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []RepoVulnerabilityAlertHit `json:"hits"`
}

type RepoVulnerabilityAlertSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  RepoVulnerabilityAlertHits `json:"hits"`
}

type RepoVulnerabilityAlertPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRepoVulnerabilityAlertPaginator(filters []essdk.BoolFilter, limit *int64) (RepoVulnerabilityAlertPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_repository_vulnerabilityalert", filters, limit)
	if err != nil {
		return RepoVulnerabilityAlertPaginator{}, err
	}

	p := RepoVulnerabilityAlertPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RepoVulnerabilityAlertPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RepoVulnerabilityAlertPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RepoVulnerabilityAlertPaginator) NextPage(ctx context.Context) ([]RepoVulnerabilityAlert, error) {
	var response RepoVulnerabilityAlertSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RepoVulnerabilityAlert
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRepoVulnerabilityAlertFilters = map[string]string{}

func ListRepoVulnerabilityAlert(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRepoVulnerabilityAlert")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoVulnerabilityAlert NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoVulnerabilityAlert NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoVulnerabilityAlert GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoVulnerabilityAlert GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoVulnerabilityAlert GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRepoVulnerabilityAlertPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRepoVulnerabilityAlertFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoVulnerabilityAlert NewRepoVulnerabilityAlertPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRepoVulnerabilityAlert paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRepoVulnerabilityAlertFilters = map[string]string{}

func GetRepoVulnerabilityAlert(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRepoVulnerabilityAlert")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRepoVulnerabilityAlertPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRepoVulnerabilityAlertFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RepoVulnerabilityAlert =============================

// ==========================  START: Star =============================

type Star struct {
	ResourceID      string                 `json:"resource_id"`
	PlatformID      string                 `json:"platform_id"`
	Description     github.StarDescription `json:"description"`
	DescribedBy     int                    `json:"described_by"`
	ResourceType    string                 `json:"resource_type"`
	IntegrationType string                 `json:"integration_type"`
	IntegrationID   string                 `json:"integration_id"`
}

func (r *Star) UnmarshalJSON(b []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(b, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for k, v := range rawMsg {
		switch k {
		case "description":
			wrapper := githubDescriber.JSONAllFieldsMarshaller{
				Value: r.Description,
			}
			if err := json.Unmarshal(v, &wrapper); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
			var ok bool
			r.Description, ok = wrapper.Value.(github.StarDescription)
			if !ok {
				return fmt.Errorf("unmarshalling type %T: %v", r, fmt.Errorf("expected type %T, got %T", r.Description, wrapper.Value))
			}
		case "platform_id":
			if err := json.Unmarshal(v, &r.PlatformID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_id":
			if err := json.Unmarshal(v, &r.ResourceID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_type":
			if err := json.Unmarshal(v, &r.ResourceType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "described_by":
			if err := json.Unmarshal(v, &r.DescribedBy); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_type":
			if err := json.Unmarshal(v, &r.IntegrationType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_id":
			if err := json.Unmarshal(v, &r.IntegrationID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		default:
		}
	}
	return nil
}

type StarHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Star          `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type StarHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []StarHit         `json:"hits"`
}

type StarSearchResponse struct {
	PitID string   `json:"pit_id"`
	Hits  StarHits `json:"hits"`
}

type StarPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewStarPaginator(filters []essdk.BoolFilter, limit *int64) (StarPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_star", filters, limit)
	if err != nil {
		return StarPaginator{}, err
	}

	p := StarPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p StarPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p StarPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p StarPaginator) NextPage(ctx context.Context) ([]Star, error) {
	var response StarSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Star
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listStarFilters = map[string]string{}

func ListStar(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListStar")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListStar NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListStar NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListStar GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListStar GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListStar GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewStarPaginator(essdk.BuildFilter(ctx, d.QueryContext, listStarFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListStar NewStarPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListStar paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getStarFilters = map[string]string{}

func GetStar(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetStar")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewStarPaginator(essdk.BuildFilter(ctx, d.QueryContext, getStarFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Star =============================

// ==========================  START: Issue =============================

type Issue struct {
	ResourceID      string                  `json:"resource_id"`
	PlatformID      string                  `json:"platform_id"`
	Description     github.IssueDescription `json:"description"`
	DescribedBy     int                     `json:"described_by"`
	ResourceType    string                  `json:"resource_type"`
	IntegrationType string                  `json:"integration_type"`
	IntegrationID   string                  `json:"integration_id"`
}

func (r *Issue) UnmarshalJSON(b []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(b, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for k, v := range rawMsg {
		switch k {
		case "description":
			wrapper := githubDescriber.JSONAllFieldsMarshaller{
				Value: r.Description,
			}
			if err := json.Unmarshal(v, &wrapper); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
			var ok bool
			r.Description, ok = wrapper.Value.(github.IssueDescription)
			if !ok {
				return fmt.Errorf("unmarshalling type %T: %v", r, fmt.Errorf("expected type %T, got %T", r.Description, wrapper.Value))
			}
		case "platform_id":
			if err := json.Unmarshal(v, &r.PlatformID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_id":
			if err := json.Unmarshal(v, &r.ResourceID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_type":
			if err := json.Unmarshal(v, &r.ResourceType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "described_by":
			if err := json.Unmarshal(v, &r.DescribedBy); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_type":
			if err := json.Unmarshal(v, &r.IntegrationType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_id":
			if err := json.Unmarshal(v, &r.IntegrationID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		default:
		}
	}
	return nil
}

type IssueHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Issue         `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type IssueHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []IssueHit        `json:"hits"`
}

type IssueSearchResponse struct {
	PitID string    `json:"pit_id"`
	Hits  IssueHits `json:"hits"`
}

type IssuePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIssuePaginator(filters []essdk.BoolFilter, limit *int64) (IssuePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_issue", filters, limit)
	if err != nil {
		return IssuePaginator{}, err
	}

	p := IssuePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IssuePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IssuePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p IssuePaginator) NextPage(ctx context.Context) ([]Issue, error) {
	var response IssueSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Issue
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIssueFilters = map[string]string{
	"repository_full_name": "Repo.NameWithOwner",
}

func ListIssue(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIssue")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListIssue NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListIssue NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListIssue GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListIssue GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListIssue GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewIssuePaginator(essdk.BuildFilter(ctx, d.QueryContext, listIssueFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListIssue NewIssuePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListIssue paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getIssueFilters = map[string]string{
	"repository_full_name": "Repo.NameWithOwner",
}

func GetIssue(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIssue")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewIssuePaginator(essdk.BuildFilter(ctx, d.QueryContext, getIssueFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Issue =============================

// ==========================  START: IssueComment =============================

type IssueComment struct {
	ResourceID      string                         `json:"resource_id"`
	PlatformID      string                         `json:"platform_id"`
	Description     github.IssueCommentDescription `json:"description"`
	DescribedBy     int                            `json:"described_by"`
	ResourceType    string                         `json:"resource_type"`
	IntegrationType string                         `json:"integration_type"`
	IntegrationID   string                         `json:"integration_id"`
}

func (r *IssueComment) UnmarshalJSON(b []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(b, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for k, v := range rawMsg {
		switch k {
		case "description":
			wrapper := githubDescriber.JSONAllFieldsMarshaller{
				Value: r.Description,
			}
			if err := json.Unmarshal(v, &wrapper); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
			var ok bool
			r.Description, ok = wrapper.Value.(github.IssueCommentDescription)
			if !ok {
				return fmt.Errorf("unmarshalling type %T: %v", r, fmt.Errorf("expected type %T, got %T", r.Description, wrapper.Value))
			}
		case "platform_id":
			if err := json.Unmarshal(v, &r.PlatformID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_id":
			if err := json.Unmarshal(v, &r.ResourceID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_type":
			if err := json.Unmarshal(v, &r.ResourceType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "described_by":
			if err := json.Unmarshal(v, &r.DescribedBy); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_type":
			if err := json.Unmarshal(v, &r.IntegrationType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_id":
			if err := json.Unmarshal(v, &r.IntegrationID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		default:
		}
	}
	return nil
}

type IssueCommentHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  IssueComment  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type IssueCommentHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []IssueCommentHit `json:"hits"`
}

type IssueCommentSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  IssueCommentHits `json:"hits"`
}

type IssueCommentPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIssueCommentPaginator(filters []essdk.BoolFilter, limit *int64) (IssueCommentPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_issue_comment", filters, limit)
	if err != nil {
		return IssueCommentPaginator{}, err
	}

	p := IssueCommentPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IssueCommentPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IssueCommentPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p IssueCommentPaginator) NextPage(ctx context.Context) ([]IssueComment, error) {
	var response IssueCommentSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []IssueComment
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIssueCommentFilters = map[string]string{}

func ListIssueComment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIssueComment")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListIssueComment NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListIssueComment NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListIssueComment GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListIssueComment GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListIssueComment GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewIssueCommentPaginator(essdk.BuildFilter(ctx, d.QueryContext, listIssueCommentFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListIssueComment NewIssueCommentPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListIssueComment paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getIssueCommentFilters = map[string]string{}

func GetIssueComment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIssueComment")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewIssueCommentPaginator(essdk.BuildFilter(ctx, d.QueryContext, getIssueCommentFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: IssueComment =============================

// ==========================  START: License =============================

type License struct {
	ResourceID      string                    `json:"resource_id"`
	PlatformID      string                    `json:"platform_id"`
	Description     github.LicenseDescription `json:"description"`
	DescribedBy     int                       `json:"described_by"`
	ResourceType    string                    `json:"resource_type"`
	IntegrationType string                    `json:"integration_type"`
	IntegrationID   string                    `json:"integration_id"`
}

func (r *License) UnmarshalJSON(b []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(b, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for k, v := range rawMsg {
		switch k {
		case "description":
			wrapper := githubDescriber.JSONAllFieldsMarshaller{
				Value: r.Description,
			}
			if err := json.Unmarshal(v, &wrapper); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
			var ok bool
			r.Description, ok = wrapper.Value.(github.LicenseDescription)
			if !ok {
				return fmt.Errorf("unmarshalling type %T: %v", r, fmt.Errorf("expected type %T, got %T", r.Description, wrapper.Value))
			}
		case "platform_id":
			if err := json.Unmarshal(v, &r.PlatformID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_id":
			if err := json.Unmarshal(v, &r.ResourceID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_type":
			if err := json.Unmarshal(v, &r.ResourceType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "described_by":
			if err := json.Unmarshal(v, &r.DescribedBy); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_type":
			if err := json.Unmarshal(v, &r.IntegrationType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_id":
			if err := json.Unmarshal(v, &r.IntegrationID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		default:
		}
	}
	return nil
}

type LicenseHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  License       `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type LicenseHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []LicenseHit      `json:"hits"`
}

type LicenseSearchResponse struct {
	PitID string      `json:"pit_id"`
	Hits  LicenseHits `json:"hits"`
}

type LicensePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLicensePaginator(filters []essdk.BoolFilter, limit *int64) (LicensePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_license", filters, limit)
	if err != nil {
		return LicensePaginator{}, err
	}

	p := LicensePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LicensePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LicensePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p LicensePaginator) NextPage(ctx context.Context) ([]License, error) {
	var response LicenseSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []License
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLicenseFilters = map[string]string{}

func ListLicense(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLicense")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListLicense NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListLicense NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListLicense GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListLicense GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListLicense GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewLicensePaginator(essdk.BuildFilter(ctx, d.QueryContext, listLicenseFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListLicense NewLicensePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListLicense paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getLicenseFilters = map[string]string{}

func GetLicense(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLicense")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewLicensePaginator(essdk.BuildFilter(ctx, d.QueryContext, getLicenseFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: License =============================

// ==========================  START: SearchCode =============================

type SearchCode struct {
	ResourceID      string                       `json:"resource_id"`
	PlatformID      string                       `json:"platform_id"`
	Description     github.SearchCodeDescription `json:"description"`
	DescribedBy     int                          `json:"described_by"`
	ResourceType    string                       `json:"resource_type"`
	IntegrationType string                       `json:"integration_type"`
	IntegrationID   string                       `json:"integration_id"`
}

func (r *SearchCode) UnmarshalJSON(b []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(b, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for k, v := range rawMsg {
		switch k {
		case "description":
			wrapper := githubDescriber.JSONAllFieldsMarshaller{
				Value: r.Description,
			}
			if err := json.Unmarshal(v, &wrapper); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
			var ok bool
			r.Description, ok = wrapper.Value.(github.SearchCodeDescription)
			if !ok {
				return fmt.Errorf("unmarshalling type %T: %v", r, fmt.Errorf("expected type %T, got %T", r.Description, wrapper.Value))
			}
		case "platform_id":
			if err := json.Unmarshal(v, &r.PlatformID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_id":
			if err := json.Unmarshal(v, &r.ResourceID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_type":
			if err := json.Unmarshal(v, &r.ResourceType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "described_by":
			if err := json.Unmarshal(v, &r.DescribedBy); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_type":
			if err := json.Unmarshal(v, &r.IntegrationType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_id":
			if err := json.Unmarshal(v, &r.IntegrationID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		default:
		}
	}
	return nil
}

type SearchCodeHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  SearchCode    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type SearchCodeHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []SearchCodeHit   `json:"hits"`
}

type SearchCodeSearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  SearchCodeHits `json:"hits"`
}

type SearchCodePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSearchCodePaginator(filters []essdk.BoolFilter, limit *int64) (SearchCodePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_search_code", filters, limit)
	if err != nil {
		return SearchCodePaginator{}, err
	}

	p := SearchCodePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SearchCodePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SearchCodePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SearchCodePaginator) NextPage(ctx context.Context) ([]SearchCode, error) {
	var response SearchCodeSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SearchCode
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSearchCodeFilters = map[string]string{
	"sha": "SHA",
}

func ListSearchCode(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSearchCode")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSearchCode NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSearchCode NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSearchCode GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSearchCode GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSearchCode GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSearchCodePaginator(essdk.BuildFilter(ctx, d.QueryContext, listSearchCodeFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSearchCode NewSearchCodePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSearchCode paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSearchCodeFilters = map[string]string{
	"sha": "SHA",
}

func GetSearchCode(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSearchCode")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSearchCodePaginator(essdk.BuildFilter(ctx, d.QueryContext, getSearchCodeFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SearchCode =============================

// ==========================  START: SearchCommit =============================

type SearchCommit struct {
	ResourceID      string                         `json:"resource_id"`
	PlatformID      string                         `json:"platform_id"`
	Description     github.SearchCommitDescription `json:"description"`
	DescribedBy     int                            `json:"described_by"`
	ResourceType    string                         `json:"resource_type"`
	IntegrationType string                         `json:"integration_type"`
	IntegrationID   string                         `json:"integration_id"`
}

func (r *SearchCommit) UnmarshalJSON(b []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(b, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for k, v := range rawMsg {
		switch k {
		case "description":
			wrapper := githubDescriber.JSONAllFieldsMarshaller{
				Value: r.Description,
			}
			if err := json.Unmarshal(v, &wrapper); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
			var ok bool
			r.Description, ok = wrapper.Value.(github.SearchCommitDescription)
			if !ok {
				return fmt.Errorf("unmarshalling type %T: %v", r, fmt.Errorf("expected type %T, got %T", r.Description, wrapper.Value))
			}
		case "platform_id":
			if err := json.Unmarshal(v, &r.PlatformID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_id":
			if err := json.Unmarshal(v, &r.ResourceID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_type":
			if err := json.Unmarshal(v, &r.ResourceType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "described_by":
			if err := json.Unmarshal(v, &r.DescribedBy); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_type":
			if err := json.Unmarshal(v, &r.IntegrationType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_id":
			if err := json.Unmarshal(v, &r.IntegrationID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		default:
		}
	}
	return nil
}

type SearchCommitHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  SearchCommit  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type SearchCommitHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []SearchCommitHit `json:"hits"`
}

type SearchCommitSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  SearchCommitHits `json:"hits"`
}

type SearchCommitPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSearchCommitPaginator(filters []essdk.BoolFilter, limit *int64) (SearchCommitPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_search_commit", filters, limit)
	if err != nil {
		return SearchCommitPaginator{}, err
	}

	p := SearchCommitPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SearchCommitPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SearchCommitPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SearchCommitPaginator) NextPage(ctx context.Context) ([]SearchCommit, error) {
	var response SearchCommitSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SearchCommit
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSearchCommitFilters = map[string]string{
	"sha": "SHA",
	"url": "URL",
}

func ListSearchCommit(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSearchCommit")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSearchCommit NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSearchCommit NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSearchCommit GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSearchCommit GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSearchCommit GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSearchCommitPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSearchCommitFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSearchCommit NewSearchCommitPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSearchCommit paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSearchCommitFilters = map[string]string{
	"sha": "SHA",
	"url": "URL",
}

func GetSearchCommit(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSearchCommit")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSearchCommitPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSearchCommitFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SearchCommit =============================

// ==========================  START: SearchIssue =============================

type SearchIssue struct {
	ResourceID      string                        `json:"resource_id"`
	PlatformID      string                        `json:"platform_id"`
	Description     github.SearchIssueDescription `json:"description"`
	DescribedBy     int                           `json:"described_by"`
	ResourceType    string                        `json:"resource_type"`
	IntegrationType string                        `json:"integration_type"`
	IntegrationID   string                        `json:"integration_id"`
}

func (r *SearchIssue) UnmarshalJSON(b []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(b, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for k, v := range rawMsg {
		switch k {
		case "description":
			wrapper := githubDescriber.JSONAllFieldsMarshaller{
				Value: r.Description,
			}
			if err := json.Unmarshal(v, &wrapper); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
			var ok bool
			r.Description, ok = wrapper.Value.(github.SearchIssueDescription)
			if !ok {
				return fmt.Errorf("unmarshalling type %T: %v", r, fmt.Errorf("expected type %T, got %T", r.Description, wrapper.Value))
			}
		case "platform_id":
			if err := json.Unmarshal(v, &r.PlatformID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_id":
			if err := json.Unmarshal(v, &r.ResourceID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_type":
			if err := json.Unmarshal(v, &r.ResourceType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "described_by":
			if err := json.Unmarshal(v, &r.DescribedBy); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_type":
			if err := json.Unmarshal(v, &r.IntegrationType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_id":
			if err := json.Unmarshal(v, &r.IntegrationID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		default:
		}
	}
	return nil
}

type SearchIssueHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  SearchIssue   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type SearchIssueHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []SearchIssueHit  `json:"hits"`
}

type SearchIssueSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  SearchIssueHits `json:"hits"`
}

type SearchIssuePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSearchIssuePaginator(filters []essdk.BoolFilter, limit *int64) (SearchIssuePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_search_issue", filters, limit)
	if err != nil {
		return SearchIssuePaginator{}, err
	}

	p := SearchIssuePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SearchIssuePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SearchIssuePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SearchIssuePaginator) NextPage(ctx context.Context) ([]SearchIssue, error) {
	var response SearchIssueSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SearchIssue
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSearchIssueFilters = map[string]string{}

func ListSearchIssue(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSearchIssue")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSearchIssue NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSearchIssue NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSearchIssue GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSearchIssue GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSearchIssue GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSearchIssuePaginator(essdk.BuildFilter(ctx, d.QueryContext, listSearchIssueFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSearchIssue NewSearchIssuePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSearchIssue paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSearchIssueFilters = map[string]string{}

func GetSearchIssue(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSearchIssue")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSearchIssuePaginator(essdk.BuildFilter(ctx, d.QueryContext, getSearchIssueFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SearchIssue =============================

// ==========================  START: Stargazer =============================

type Stargazer struct {
	ResourceID      string                      `json:"resource_id"`
	PlatformID      string                      `json:"platform_id"`
	Description     github.StargazerDescription `json:"description"`
	DescribedBy     int                         `json:"described_by"`
	ResourceType    string                      `json:"resource_type"`
	IntegrationType string                      `json:"integration_type"`
	IntegrationID   string                      `json:"integration_id"`
}

func (r *Stargazer) UnmarshalJSON(b []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(b, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for k, v := range rawMsg {
		switch k {
		case "description":
			wrapper := githubDescriber.JSONAllFieldsMarshaller{
				Value: r.Description,
			}
			if err := json.Unmarshal(v, &wrapper); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
			var ok bool
			r.Description, ok = wrapper.Value.(github.StargazerDescription)
			if !ok {
				return fmt.Errorf("unmarshalling type %T: %v", r, fmt.Errorf("expected type %T, got %T", r.Description, wrapper.Value))
			}
		case "platform_id":
			if err := json.Unmarshal(v, &r.PlatformID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_id":
			if err := json.Unmarshal(v, &r.ResourceID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_type":
			if err := json.Unmarshal(v, &r.ResourceType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "described_by":
			if err := json.Unmarshal(v, &r.DescribedBy); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_type":
			if err := json.Unmarshal(v, &r.IntegrationType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_id":
			if err := json.Unmarshal(v, &r.IntegrationID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		default:
		}
	}
	return nil
}

type StargazerHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Stargazer     `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type StargazerHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []StargazerHit    `json:"hits"`
}

type StargazerSearchResponse struct {
	PitID string        `json:"pit_id"`
	Hits  StargazerHits `json:"hits"`
}

type StargazerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewStargazerPaginator(filters []essdk.BoolFilter, limit *int64) (StargazerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_stargazer", filters, limit)
	if err != nil {
		return StargazerPaginator{}, err
	}

	p := StargazerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p StargazerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p StargazerPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p StargazerPaginator) NextPage(ctx context.Context) ([]Stargazer, error) {
	var response StargazerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Stargazer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listStargazerFilters = map[string]string{}

func ListStargazer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListStargazer")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListStargazer NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListStargazer NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListStargazer GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListStargazer GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListStargazer GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewStargazerPaginator(essdk.BuildFilter(ctx, d.QueryContext, listStargazerFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListStargazer NewStargazerPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListStargazer paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getStargazerFilters = map[string]string{}

func GetStargazer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetStargazer")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewStargazerPaginator(essdk.BuildFilter(ctx, d.QueryContext, getStargazerFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Stargazer =============================

// ==========================  START: Tag =============================

type Tag struct {
	ResourceID      string                `json:"resource_id"`
	PlatformID      string                `json:"platform_id"`
	Description     github.TagDescription `json:"description"`
	DescribedBy     int                   `json:"described_by"`
	ResourceType    string                `json:"resource_type"`
	IntegrationType string                `json:"integration_type"`
	IntegrationID   string                `json:"integration_id"`
}

func (r *Tag) UnmarshalJSON(b []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(b, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for k, v := range rawMsg {
		switch k {
		case "description":
			wrapper := githubDescriber.JSONAllFieldsMarshaller{
				Value: r.Description,
			}
			if err := json.Unmarshal(v, &wrapper); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
			var ok bool
			r.Description, ok = wrapper.Value.(github.TagDescription)
			if !ok {
				return fmt.Errorf("unmarshalling type %T: %v", r, fmt.Errorf("expected type %T, got %T", r.Description, wrapper.Value))
			}
		case "platform_id":
			if err := json.Unmarshal(v, &r.PlatformID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_id":
			if err := json.Unmarshal(v, &r.ResourceID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_type":
			if err := json.Unmarshal(v, &r.ResourceType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "described_by":
			if err := json.Unmarshal(v, &r.DescribedBy); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_type":
			if err := json.Unmarshal(v, &r.IntegrationType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_id":
			if err := json.Unmarshal(v, &r.IntegrationID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		default:
		}
	}
	return nil
}

type TagHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Tag           `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type TagHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []TagHit          `json:"hits"`
}

type TagSearchResponse struct {
	PitID string  `json:"pit_id"`
	Hits  TagHits `json:"hits"`
}

type TagPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewTagPaginator(filters []essdk.BoolFilter, limit *int64) (TagPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_tag", filters, limit)
	if err != nil {
		return TagPaginator{}, err
	}

	p := TagPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p TagPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p TagPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p TagPaginator) NextPage(ctx context.Context) ([]Tag, error) {
	var response TagSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Tag
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listTagFilters = map[string]string{}

func ListTag(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListTag")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListTag NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListTag NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListTag GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListTag GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListTag GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewTagPaginator(essdk.BuildFilter(ctx, d.QueryContext, listTagFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListTag NewTagPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListTag paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getTagFilters = map[string]string{}

func GetTag(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetTag")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewTagPaginator(essdk.BuildFilter(ctx, d.QueryContext, getTagFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Tag =============================

// ==========================  START: Team =============================

type Team struct {
	ResourceID      string                 `json:"resource_id"`
	PlatformID      string                 `json:"platform_id"`
	Description     github.TeamDescription `json:"description"`
	DescribedBy     int                    `json:"described_by"`
	ResourceType    string                 `json:"resource_type"`
	IntegrationType string                 `json:"integration_type"`
	IntegrationID   string                 `json:"integration_id"`
}

func (r *Team) UnmarshalJSON(b []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(b, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for k, v := range rawMsg {
		switch k {
		case "description":
			wrapper := githubDescriber.JSONAllFieldsMarshaller{
				Value: r.Description,
			}
			if err := json.Unmarshal(v, &wrapper); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
			var ok bool
			r.Description, ok = wrapper.Value.(github.TeamDescription)
			if !ok {
				return fmt.Errorf("unmarshalling type %T: %v", r, fmt.Errorf("expected type %T, got %T", r.Description, wrapper.Value))
			}
		case "platform_id":
			if err := json.Unmarshal(v, &r.PlatformID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_id":
			if err := json.Unmarshal(v, &r.ResourceID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_type":
			if err := json.Unmarshal(v, &r.ResourceType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "described_by":
			if err := json.Unmarshal(v, &r.DescribedBy); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_type":
			if err := json.Unmarshal(v, &r.IntegrationType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_id":
			if err := json.Unmarshal(v, &r.IntegrationID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		default:
		}
	}
	return nil
}

type TeamHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Team          `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type TeamHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []TeamHit         `json:"hits"`
}

type TeamSearchResponse struct {
	PitID string   `json:"pit_id"`
	Hits  TeamHits `json:"hits"`
}

type TeamPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewTeamPaginator(filters []essdk.BoolFilter, limit *int64) (TeamPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_team", filters, limit)
	if err != nil {
		return TeamPaginator{}, err
	}

	p := TeamPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p TeamPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p TeamPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p TeamPaginator) NextPage(ctx context.Context) ([]Team, error) {
	var response TeamSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Team
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listTeamFilters = map[string]string{}

func ListTeam(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListTeam")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeam NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeam NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeam GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeam GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeam GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewTeamPaginator(essdk.BuildFilter(ctx, d.QueryContext, listTeamFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeam NewTeamPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListTeam paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getTeamFilters = map[string]string{}

func GetTeam(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetTeam")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewTeamPaginator(essdk.BuildFilter(ctx, d.QueryContext, getTeamFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Team =============================

// ==========================  START: TeamMembers =============================

type TeamMembers struct {
	ResourceID      string                        `json:"resource_id"`
	PlatformID      string                        `json:"platform_id"`
	Description     github.TeamMembersDescription `json:"description"`
	DescribedBy     int                           `json:"described_by"`
	ResourceType    string                        `json:"resource_type"`
	IntegrationType string                        `json:"integration_type"`
	IntegrationID   string                        `json:"integration_id"`
}

func (r *TeamMembers) UnmarshalJSON(b []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(b, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for k, v := range rawMsg {
		switch k {
		case "description":
			wrapper := githubDescriber.JSONAllFieldsMarshaller{
				Value: r.Description,
			}
			if err := json.Unmarshal(v, &wrapper); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
			var ok bool
			r.Description, ok = wrapper.Value.(github.TeamMembersDescription)
			if !ok {
				return fmt.Errorf("unmarshalling type %T: %v", r, fmt.Errorf("expected type %T, got %T", r.Description, wrapper.Value))
			}
		case "platform_id":
			if err := json.Unmarshal(v, &r.PlatformID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_id":
			if err := json.Unmarshal(v, &r.ResourceID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_type":
			if err := json.Unmarshal(v, &r.ResourceType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "described_by":
			if err := json.Unmarshal(v, &r.DescribedBy); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_type":
			if err := json.Unmarshal(v, &r.IntegrationType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_id":
			if err := json.Unmarshal(v, &r.IntegrationID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		default:
		}
	}
	return nil
}

type TeamMembersHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  TeamMembers   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type TeamMembersHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []TeamMembersHit  `json:"hits"`
}

type TeamMembersSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  TeamMembersHits `json:"hits"`
}

type TeamMembersPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewTeamMembersPaginator(filters []essdk.BoolFilter, limit *int64) (TeamMembersPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_team_member", filters, limit)
	if err != nil {
		return TeamMembersPaginator{}, err
	}

	p := TeamMembersPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p TeamMembersPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p TeamMembersPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p TeamMembersPaginator) NextPage(ctx context.Context) ([]TeamMembers, error) {
	var response TeamMembersSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []TeamMembers
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listTeamMembersFilters = map[string]string{}

func ListTeamMembers(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListTeamMembers")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeamMembers NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeamMembers NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeamMembers GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeamMembers GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeamMembers GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewTeamMembersPaginator(essdk.BuildFilter(ctx, d.QueryContext, listTeamMembersFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeamMembers NewTeamMembersPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListTeamMembers paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getTeamMembersFilters = map[string]string{}

func GetTeamMembers(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetTeamMembers")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewTeamMembersPaginator(essdk.BuildFilter(ctx, d.QueryContext, getTeamMembersFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: TeamMembers =============================

// ==========================  START: TeamRepository =============================

type TeamRepository struct {
	ResourceID      string                           `json:"resource_id"`
	PlatformID      string                           `json:"platform_id"`
	Description     github.TeamRepositoryDescription `json:"description"`
	DescribedBy     int                              `json:"described_by"`
	ResourceType    string                           `json:"resource_type"`
	IntegrationType string                           `json:"integration_type"`
	IntegrationID   string                           `json:"integration_id"`
}

func (r *TeamRepository) UnmarshalJSON(b []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(b, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for k, v := range rawMsg {
		switch k {
		case "description":
			wrapper := githubDescriber.JSONAllFieldsMarshaller{
				Value: r.Description,
			}
			if err := json.Unmarshal(v, &wrapper); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
			var ok bool
			r.Description, ok = wrapper.Value.(github.TeamRepositoryDescription)
			if !ok {
				return fmt.Errorf("unmarshalling type %T: %v", r, fmt.Errorf("expected type %T, got %T", r.Description, wrapper.Value))
			}
		case "platform_id":
			if err := json.Unmarshal(v, &r.PlatformID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_id":
			if err := json.Unmarshal(v, &r.ResourceID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_type":
			if err := json.Unmarshal(v, &r.ResourceType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "described_by":
			if err := json.Unmarshal(v, &r.DescribedBy); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_type":
			if err := json.Unmarshal(v, &r.IntegrationType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_id":
			if err := json.Unmarshal(v, &r.IntegrationID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		default:
		}
	}
	return nil
}

type TeamRepositoryHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  TeamRepository `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type TeamRepositoryHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []TeamRepositoryHit `json:"hits"`
}

type TeamRepositorySearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  TeamRepositoryHits `json:"hits"`
}

type TeamRepositoryPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewTeamRepositoryPaginator(filters []essdk.BoolFilter, limit *int64) (TeamRepositoryPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_team_repository", filters, limit)
	if err != nil {
		return TeamRepositoryPaginator{}, err
	}

	p := TeamRepositoryPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p TeamRepositoryPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p TeamRepositoryPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p TeamRepositoryPaginator) NextPage(ctx context.Context) ([]TeamRepository, error) {
	var response TeamRepositorySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []TeamRepository
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listTeamRepositoryFilters = map[string]string{}

func ListTeamRepository(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListTeamRepository")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeamRepository NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeamRepository NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeamRepository GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeamRepository GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeamRepository GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewTeamRepositoryPaginator(essdk.BuildFilter(ctx, d.QueryContext, listTeamRepositoryFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeamRepository NewTeamRepositoryPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListTeamRepository paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getTeamRepositoryFilters = map[string]string{}

func GetTeamRepository(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetTeamRepository")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewTeamRepositoryPaginator(essdk.BuildFilter(ctx, d.QueryContext, getTeamRepositoryFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: TeamRepository =============================

// ==========================  START: TrafficViewDaily =============================

type TrafficViewDaily struct {
	ResourceID      string                             `json:"resource_id"`
	PlatformID      string                             `json:"platform_id"`
	Description     github.TrafficViewDailyDescription `json:"description"`
	DescribedBy     int                                `json:"described_by"`
	ResourceType    string                             `json:"resource_type"`
	IntegrationType string                             `json:"integration_type"`
	IntegrationID   string                             `json:"integration_id"`
}

func (r *TrafficViewDaily) UnmarshalJSON(b []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(b, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for k, v := range rawMsg {
		switch k {
		case "description":
			wrapper := githubDescriber.JSONAllFieldsMarshaller{
				Value: r.Description,
			}
			if err := json.Unmarshal(v, &wrapper); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
			var ok bool
			r.Description, ok = wrapper.Value.(github.TrafficViewDailyDescription)
			if !ok {
				return fmt.Errorf("unmarshalling type %T: %v", r, fmt.Errorf("expected type %T, got %T", r.Description, wrapper.Value))
			}
		case "platform_id":
			if err := json.Unmarshal(v, &r.PlatformID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_id":
			if err := json.Unmarshal(v, &r.ResourceID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_type":
			if err := json.Unmarshal(v, &r.ResourceType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "described_by":
			if err := json.Unmarshal(v, &r.DescribedBy); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_type":
			if err := json.Unmarshal(v, &r.IntegrationType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_id":
			if err := json.Unmarshal(v, &r.IntegrationID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		default:
		}
	}
	return nil
}

type TrafficViewDailyHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  TrafficViewDaily `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type TrafficViewDailyHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []TrafficViewDailyHit `json:"hits"`
}

type TrafficViewDailySearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  TrafficViewDailyHits `json:"hits"`
}

type TrafficViewDailyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewTrafficViewDailyPaginator(filters []essdk.BoolFilter, limit *int64) (TrafficViewDailyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_traffic_view_daily", filters, limit)
	if err != nil {
		return TrafficViewDailyPaginator{}, err
	}

	p := TrafficViewDailyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p TrafficViewDailyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p TrafficViewDailyPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p TrafficViewDailyPaginator) NextPage(ctx context.Context) ([]TrafficViewDaily, error) {
	var response TrafficViewDailySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []TrafficViewDaily
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listTrafficViewDailyFilters = map[string]string{}

func ListTrafficViewDaily(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListTrafficViewDaily")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListTrafficViewDaily NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListTrafficViewDaily NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListTrafficViewDaily GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListTrafficViewDaily GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListTrafficViewDaily GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewTrafficViewDailyPaginator(essdk.BuildFilter(ctx, d.QueryContext, listTrafficViewDailyFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListTrafficViewDaily NewTrafficViewDailyPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListTrafficViewDaily paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getTrafficViewDailyFilters = map[string]string{}

func GetTrafficViewDaily(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetTrafficViewDaily")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewTrafficViewDailyPaginator(essdk.BuildFilter(ctx, d.QueryContext, getTrafficViewDailyFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: TrafficViewDaily =============================

// ==========================  START: TrafficViewWeekly =============================

type TrafficViewWeekly struct {
	ResourceID      string                              `json:"resource_id"`
	PlatformID      string                              `json:"platform_id"`
	Description     github.TrafficViewWeeklyDescription `json:"description"`
	DescribedBy     int                                 `json:"described_by"`
	ResourceType    string                              `json:"resource_type"`
	IntegrationType string                              `json:"integration_type"`
	IntegrationID   string                              `json:"integration_id"`
}

func (r *TrafficViewWeekly) UnmarshalJSON(b []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(b, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for k, v := range rawMsg {
		switch k {
		case "description":
			wrapper := githubDescriber.JSONAllFieldsMarshaller{
				Value: r.Description,
			}
			if err := json.Unmarshal(v, &wrapper); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
			var ok bool
			r.Description, ok = wrapper.Value.(github.TrafficViewWeeklyDescription)
			if !ok {
				return fmt.Errorf("unmarshalling type %T: %v", r, fmt.Errorf("expected type %T, got %T", r.Description, wrapper.Value))
			}
		case "platform_id":
			if err := json.Unmarshal(v, &r.PlatformID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_id":
			if err := json.Unmarshal(v, &r.ResourceID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_type":
			if err := json.Unmarshal(v, &r.ResourceType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "described_by":
			if err := json.Unmarshal(v, &r.DescribedBy); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_type":
			if err := json.Unmarshal(v, &r.IntegrationType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_id":
			if err := json.Unmarshal(v, &r.IntegrationID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		default:
		}
	}
	return nil
}

type TrafficViewWeeklyHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  TrafficViewWeekly `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type TrafficViewWeeklyHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []TrafficViewWeeklyHit `json:"hits"`
}

type TrafficViewWeeklySearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  TrafficViewWeeklyHits `json:"hits"`
}

type TrafficViewWeeklyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewTrafficViewWeeklyPaginator(filters []essdk.BoolFilter, limit *int64) (TrafficViewWeeklyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_traffic_view_weekly", filters, limit)
	if err != nil {
		return TrafficViewWeeklyPaginator{}, err
	}

	p := TrafficViewWeeklyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p TrafficViewWeeklyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p TrafficViewWeeklyPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p TrafficViewWeeklyPaginator) NextPage(ctx context.Context) ([]TrafficViewWeekly, error) {
	var response TrafficViewWeeklySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []TrafficViewWeekly
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listTrafficViewWeeklyFilters = map[string]string{}

func ListTrafficViewWeekly(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListTrafficViewWeekly")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListTrafficViewWeekly NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListTrafficViewWeekly NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListTrafficViewWeekly GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListTrafficViewWeekly GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListTrafficViewWeekly GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewTrafficViewWeeklyPaginator(essdk.BuildFilter(ctx, d.QueryContext, listTrafficViewWeeklyFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListTrafficViewWeekly NewTrafficViewWeeklyPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListTrafficViewWeekly paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getTrafficViewWeeklyFilters = map[string]string{}

func GetTrafficViewWeekly(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetTrafficViewWeekly")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewTrafficViewWeeklyPaginator(essdk.BuildFilter(ctx, d.QueryContext, getTrafficViewWeeklyFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: TrafficViewWeekly =============================

// ==========================  START: Tree =============================

type Tree struct {
	ResourceID      string                 `json:"resource_id"`
	PlatformID      string                 `json:"platform_id"`
	Description     github.TreeDescription `json:"description"`
	DescribedBy     int                    `json:"described_by"`
	ResourceType    string                 `json:"resource_type"`
	IntegrationType string                 `json:"integration_type"`
	IntegrationID   string                 `json:"integration_id"`
}

func (r *Tree) UnmarshalJSON(b []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(b, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for k, v := range rawMsg {
		switch k {
		case "description":
			wrapper := githubDescriber.JSONAllFieldsMarshaller{
				Value: r.Description,
			}
			if err := json.Unmarshal(v, &wrapper); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
			var ok bool
			r.Description, ok = wrapper.Value.(github.TreeDescription)
			if !ok {
				return fmt.Errorf("unmarshalling type %T: %v", r, fmt.Errorf("expected type %T, got %T", r.Description, wrapper.Value))
			}
		case "platform_id":
			if err := json.Unmarshal(v, &r.PlatformID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_id":
			if err := json.Unmarshal(v, &r.ResourceID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_type":
			if err := json.Unmarshal(v, &r.ResourceType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "described_by":
			if err := json.Unmarshal(v, &r.DescribedBy); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_type":
			if err := json.Unmarshal(v, &r.IntegrationType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_id":
			if err := json.Unmarshal(v, &r.IntegrationID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		default:
		}
	}
	return nil
}

type TreeHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Tree          `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type TreeHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []TreeHit         `json:"hits"`
}

type TreeSearchResponse struct {
	PitID string   `json:"pit_id"`
	Hits  TreeHits `json:"hits"`
}

type TreePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewTreePaginator(filters []essdk.BoolFilter, limit *int64) (TreePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_tree", filters, limit)
	if err != nil {
		return TreePaginator{}, err
	}

	p := TreePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p TreePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p TreePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p TreePaginator) NextPage(ctx context.Context) ([]Tree, error) {
	var response TreeSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Tree
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listTreeFilters = map[string]string{
	"mode": "TreeEntry.Mode",
	"path": "TreeEntry.Path",
	"sha":  "TreeEntry.SHA",
	"size": "TreeEntry.Size",
	"type": "TreeEntry.Type",
	"url":  "TreeEntry.URL",
}

func ListTree(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListTree")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListTree NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListTree NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListTree GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListTree GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListTree GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewTreePaginator(essdk.BuildFilter(ctx, d.QueryContext, listTreeFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListTree NewTreePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListTree paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getTreeFilters = map[string]string{
	"mode": "TreeEntry.Mode",
	"path": "TreeEntry.Path",
	"sha":  "TreeEntry.SHA",
	"size": "TreeEntry.Size",
	"type": "TreeEntry.Type",
	"url":  "TreeEntry.URL",
}

func GetTree(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetTree")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewTreePaginator(essdk.BuildFilter(ctx, d.QueryContext, getTreeFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Tree =============================

// ==========================  START: User =============================

type User struct {
	ResourceID      string                 `json:"resource_id"`
	PlatformID      string                 `json:"platform_id"`
	Description     github.UserDescription `json:"description"`
	DescribedBy     int                    `json:"described_by"`
	ResourceType    string                 `json:"resource_type"`
	IntegrationType string                 `json:"integration_type"`
	IntegrationID   string                 `json:"integration_id"`
}

func (r *User) UnmarshalJSON(b []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(b, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for k, v := range rawMsg {
		switch k {
		case "description":
			wrapper := githubDescriber.JSONAllFieldsMarshaller{
				Value: r.Description,
			}
			if err := json.Unmarshal(v, &wrapper); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
			var ok bool
			r.Description, ok = wrapper.Value.(github.UserDescription)
			if !ok {
				return fmt.Errorf("unmarshalling type %T: %v", r, fmt.Errorf("expected type %T, got %T", r.Description, wrapper.Value))
			}
		case "platform_id":
			if err := json.Unmarshal(v, &r.PlatformID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_id":
			if err := json.Unmarshal(v, &r.ResourceID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_type":
			if err := json.Unmarshal(v, &r.ResourceType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "described_by":
			if err := json.Unmarshal(v, &r.DescribedBy); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_type":
			if err := json.Unmarshal(v, &r.IntegrationType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_id":
			if err := json.Unmarshal(v, &r.IntegrationID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		default:
		}
	}
	return nil
}

type UserHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  User          `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type UserHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []UserHit         `json:"hits"`
}

type UserSearchResponse struct {
	PitID string   `json:"pit_id"`
	Hits  UserHits `json:"hits"`
}

type UserPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewUserPaginator(filters []essdk.BoolFilter, limit *int64) (UserPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "githubuser", filters, limit)
	if err != nil {
		return UserPaginator{}, err
	}

	p := UserPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p UserPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p UserPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p UserPaginator) NextPage(ctx context.Context) ([]User, error) {
	var response UserSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []User
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listUserFilters = map[string]string{
	"email":   "Email",
	"id":      "Id",
	"login":   "Login",
	"name":    "Name",
	"node_id": "NodeId",
	"url":     "Url",
}

func ListUser(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListUser")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListUser NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListUser NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListUser GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListUser GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListUser GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewUserPaginator(essdk.BuildFilter(ctx, d.QueryContext, listUserFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListUser NewUserPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListUser paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getUserFilters = map[string]string{
	"email":   "Email",
	"id":      "Id",
	"login":   "Login",
	"name":    "Name",
	"node_id": "NodeId",
	"url":     "Url",
}

func GetUser(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetUser")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewUserPaginator(essdk.BuildFilter(ctx, d.QueryContext, getUserFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: User =============================

// ==========================  START: Workflow =============================

type Workflow struct {
	ResourceID      string                     `json:"resource_id"`
	PlatformID      string                     `json:"platform_id"`
	Description     github.WorkflowDescription `json:"description"`
	DescribedBy     int                        `json:"described_by"`
	ResourceType    string                     `json:"resource_type"`
	IntegrationType string                     `json:"integration_type"`
	IntegrationID   string                     `json:"integration_id"`
}

func (r *Workflow) UnmarshalJSON(b []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(b, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for k, v := range rawMsg {
		switch k {
		case "description":
			wrapper := githubDescriber.JSONAllFieldsMarshaller{
				Value: r.Description,
			}
			if err := json.Unmarshal(v, &wrapper); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
			var ok bool
			r.Description, ok = wrapper.Value.(github.WorkflowDescription)
			if !ok {
				return fmt.Errorf("unmarshalling type %T: %v", r, fmt.Errorf("expected type %T, got %T", r.Description, wrapper.Value))
			}
		case "platform_id":
			if err := json.Unmarshal(v, &r.PlatformID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_id":
			if err := json.Unmarshal(v, &r.ResourceID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "resource_type":
			if err := json.Unmarshal(v, &r.ResourceType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "described_by":
			if err := json.Unmarshal(v, &r.DescribedBy); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_type":
			if err := json.Unmarshal(v, &r.IntegrationType); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		case "integration_id":
			if err := json.Unmarshal(v, &r.IntegrationID); err != nil {
				return fmt.Errorf("unmarshalling type %T: %v", r, err)
			}
		default:
		}
	}
	return nil
}

type WorkflowHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Workflow      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type WorkflowHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []WorkflowHit     `json:"hits"`
}

type WorkflowSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  WorkflowHits `json:"hits"`
}

type WorkflowPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWorkflowPaginator(filters []essdk.BoolFilter, limit *int64) (WorkflowPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "githubworkflow", filters, limit)
	if err != nil {
		return WorkflowPaginator{}, err
	}

	p := WorkflowPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WorkflowPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WorkflowPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p WorkflowPaginator) NextPage(ctx context.Context) ([]Workflow, error) {
	var response WorkflowSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Workflow
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWorkflowFilters = map[string]string{}

func ListWorkflow(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWorkflow")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkflow NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkflow NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkflow GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkflow GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkflow GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewWorkflowPaginator(essdk.BuildFilter(ctx, d.QueryContext, listWorkflowFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkflow NewWorkflowPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListWorkflow paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getWorkflowFilters = map[string]string{}

func GetWorkflow(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWorkflow")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewWorkflowPaginator(essdk.BuildFilter(ctx, d.QueryContext, getWorkflowFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Workflow =============================
