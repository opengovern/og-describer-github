// Code is generated by go generate. DO NOT EDIT.
package opengovernance

import (
	"context"
	"encoding/json"
	"fmt"
	githubDescriber "github.com/opengovern/og-describer-github/provider/describer"
	github "github.com/opengovern/og-describer-github/provider/model"
	essdk "github.com/opengovern/og-util/pkg/opengovernance-es-sdk"
	steampipesdk "github.com/opengovern/og-util/pkg/steampipe"
	"github.com/turbot/steampipe-plugin-sdk/v5/plugin"
	"runtime"
)

type Client struct {
	essdk.Client
}

// ==========================  START: Artifact =============================

type Artifact struct {
	ResourceID      string                     `json:"resource_id"`
	PlatformID      string                     `json:"platform_id"`
	Description     github.ArtifactDescription `json:"description"`
	Metadata        github.Metadata            `json:"metadata"`
	DescribedBy     string                     `json:"described_by"`
	ResourceType    string                     `json:"resource_type"`
	IntegrationType string                     `json:"integration_type"`
	IntegrationID   string                     `json:"integration_id"`
}

type ArtifactHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Artifact      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ArtifactHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []ArtifactHit     `json:"hits"`
}

type ArtifactSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  ArtifactHits `json:"hits"`
}

type ArtifactPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewArtifactPaginator(filters []essdk.BoolFilter, limit *int64) (ArtifactPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_actions_artifact", filters, limit)
	if err != nil {
		return ArtifactPaginator{}, err
	}

	p := ArtifactPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ArtifactPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ArtifactPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ArtifactPaginator) NextPage(ctx context.Context) ([]Artifact, error) {
	var response ArtifactSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Artifact
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listArtifactFilters = map[string]string{
	"archive_download_url": "Description.ArchiveDownloadURL",
	"expired":              "Description.Expired",
	"id":                   "Description.ID",
	"name":                 "Description.Name",
	"node_id":              "Description.NodeID",
	"repository_full_name": "Description.RepoFullName",
	"size_in_bytes":        "Description.SizeInBytes",
}

func ListArtifact(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListArtifact")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListArtifact NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListArtifact NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListArtifact GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListArtifact GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListArtifact GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewArtifactPaginator(essdk.BuildFilter(ctx, d.QueryContext, listArtifactFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListArtifact NewArtifactPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListArtifact paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getArtifactFilters = map[string]string{
	"archive_download_url": "Description.ArchiveDownloadURL",
	"expired":              "Description.Expired",
	"id":                   "Description.ID",
	"name":                 "Description.Name",
	"node_id":              "Description.NodeID",
	"repository_full_name": "Description.RepoFullName",
	"size_in_bytes":        "Description.SizeInBytes",
}

func GetArtifact(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetArtifact")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewArtifactPaginator(essdk.BuildFilter(ctx, d.QueryContext, getArtifactFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Artifact =============================

// ==========================  START: Runner =============================

type Runner struct {
	ResourceID      string                   `json:"resource_id"`
	PlatformID      string                   `json:"platform_id"`
	Description     github.RunnerDescription `json:"description"`
	Metadata        github.Metadata          `json:"metadata"`
	DescribedBy     string                   `json:"described_by"`
	ResourceType    string                   `json:"resource_type"`
	IntegrationType string                   `json:"integration_type"`
	IntegrationID   string                   `json:"integration_id"`
}

type RunnerHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Runner        `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type RunnerHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []RunnerHit       `json:"hits"`
}

type RunnerSearchResponse struct {
	PitID string     `json:"pit_id"`
	Hits  RunnerHits `json:"hits"`
}

type RunnerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRunnerPaginator(filters []essdk.BoolFilter, limit *int64) (RunnerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_actions_repository_runner", filters, limit)
	if err != nil {
		return RunnerPaginator{}, err
	}

	p := RunnerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RunnerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RunnerPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RunnerPaginator) NextPage(ctx context.Context) ([]Runner, error) {
	var response RunnerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Runner
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRunnerFilters = map[string]string{
	"busy":                 "Description.Busy",
	"id":                   "Description.ID",
	"labels":               "Description.Labels",
	"name":                 "Description.Name",
	"os":                   "Description.OS",
	"repository_full_name": "Description.RepoFullName",
	"status":               "Description.Status",
}

func ListRunner(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRunner")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRunner NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRunner NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRunner GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRunner GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRunner GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRunnerPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRunnerFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRunner NewRunnerPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRunner paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRunnerFilters = map[string]string{
	"busy":                 "Description.Busy",
	"id":                   "Description.ID",
	"labels":               "Description.Labels",
	"name":                 "Description.Name",
	"os":                   "Description.OS",
	"repository_full_name": "Description.RepoFullName",
	"status":               "Description.Status",
}

func GetRunner(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRunner")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRunnerPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRunnerFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Runner =============================

// ==========================  START: Secret =============================

type Secret struct {
	ResourceID      string                   `json:"resource_id"`
	PlatformID      string                   `json:"platform_id"`
	Description     github.SecretDescription `json:"description"`
	Metadata        github.Metadata          `json:"metadata"`
	DescribedBy     string                   `json:"described_by"`
	ResourceType    string                   `json:"resource_type"`
	IntegrationType string                   `json:"integration_type"`
	IntegrationID   string                   `json:"integration_id"`
}

type SecretHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Secret        `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type SecretHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []SecretHit       `json:"hits"`
}

type SecretSearchResponse struct {
	PitID string     `json:"pit_id"`
	Hits  SecretHits `json:"hits"`
}

type SecretPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSecretPaginator(filters []essdk.BoolFilter, limit *int64) (SecretPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_actions_repository_secret", filters, limit)
	if err != nil {
		return SecretPaginator{}, err
	}

	p := SecretPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SecretPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SecretPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SecretPaginator) NextPage(ctx context.Context) ([]Secret, error) {
	var response SecretSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Secret
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSecretFilters = map[string]string{
	"name":                      "Description.Name",
	"repository_full_name":      "Description.RepoFullName",
	"selected_repositories_url": "Description.SelectedRepositoriesURL",
	"visibility":                "Description.Visibility",
}

func ListSecret(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSecret")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecret NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecret NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecret GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecret GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecret GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSecretPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSecretFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecret NewSecretPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSecret paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSecretFilters = map[string]string{
	"name":                      "Description.Name",
	"repository_full_name":      "Description.RepoFullName",
	"selected_repositories_url": "Description.SelectedRepositoriesURL",
	"visibility":                "Description.Visibility",
}

func GetSecret(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSecret")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSecretPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSecretFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Secret =============================

// ==========================  START: WorkflowRun =============================

type WorkflowRun struct {
	ResourceID      string                        `json:"resource_id"`
	PlatformID      string                        `json:"platform_id"`
	Description     github.WorkflowRunDescription `json:"description"`
	Metadata        github.Metadata               `json:"metadata"`
	DescribedBy     string                        `json:"described_by"`
	ResourceType    string                        `json:"resource_type"`
	IntegrationType string                        `json:"integration_type"`
	IntegrationID   string                        `json:"integration_id"`
}

type WorkflowRunHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  WorkflowRun   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type WorkflowRunHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []WorkflowRunHit  `json:"hits"`
}

type WorkflowRunSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  WorkflowRunHits `json:"hits"`
}

type WorkflowRunPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWorkflowRunPaginator(filters []essdk.BoolFilter, limit *int64) (WorkflowRunPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_actions_repository_workflow_run", filters, limit)
	if err != nil {
		return WorkflowRunPaginator{}, err
	}

	p := WorkflowRunPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WorkflowRunPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WorkflowRunPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p WorkflowRunPaginator) NextPage(ctx context.Context) ([]WorkflowRun, error) {
	var response WorkflowRunSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []WorkflowRun
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWorkflowRunFilters = map[string]string{
	"actor":                  "Description.Actor",
	"actor_login":            "Description.Actor.Login",
	"triggering_actor":       "Description.TriggeringActor",
	"triggering_actor_login": "Description.TriggeringActor.Login",
}

func ListWorkflowRun(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWorkflowRun")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkflowRun NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkflowRun NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkflowRun GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkflowRun GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkflowRun GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewWorkflowRunPaginator(essdk.BuildFilter(ctx, d.QueryContext, listWorkflowRunFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkflowRun NewWorkflowRunPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListWorkflowRun paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getWorkflowRunFilters = map[string]string{
	"actor":                  "Description.Actor",
	"actor_login":            "Description.Actor.Login",
	"triggering_actor":       "Description.TriggeringActor",
	"triggering_actor_login": "Description.TriggeringActor.Login",
}

func GetWorkflowRun(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWorkflowRun")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewWorkflowRunPaginator(essdk.BuildFilter(ctx, d.QueryContext, getWorkflowRunFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: WorkflowRun =============================

// ==========================  START: Blob =============================

type Blob struct {
	ResourceID      string                 `json:"resource_id"`
	PlatformID      string                 `json:"platform_id"`
	Description     github.BlobDescription `json:"description"`
	Metadata        github.Metadata        `json:"metadata"`
	DescribedBy     string                 `json:"described_by"`
	ResourceType    string                 `json:"resource_type"`
	IntegrationType string                 `json:"integration_type"`
	IntegrationID   string                 `json:"integration_id"`
}

type BlobHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Blob          `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type BlobHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []BlobHit         `json:"hits"`
}

type BlobSearchResponse struct {
	PitID string   `json:"pit_id"`
	Hits  BlobHits `json:"hits"`
}

type BlobPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewBlobPaginator(filters []essdk.BoolFilter, limit *int64) (BlobPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_blob", filters, limit)
	if err != nil {
		return BlobPaginator{}, err
	}

	p := BlobPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p BlobPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p BlobPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p BlobPaginator) NextPage(ctx context.Context) ([]Blob, error) {
	var response BlobSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Blob
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listBlobFilters = map[string]string{
	"blob_sha":             "Description.SHA",
	"content":              "Description.Content",
	"encoding":             "Description.Encoding",
	"node_id":              "Description.NodeID",
	"repository_full_name": "Description.RepoFullName",
	"size":                 "Description.Size",
	"url":                  "Description.URL",
}

func ListBlob(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListBlob")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListBlob NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListBlob NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListBlob GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListBlob GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListBlob GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewBlobPaginator(essdk.BuildFilter(ctx, d.QueryContext, listBlobFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListBlob NewBlobPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListBlob paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getBlobFilters = map[string]string{
	"blob_sha":             "Description.SHA",
	"content":              "Description.Content",
	"encoding":             "Description.Encoding",
	"node_id":              "Description.NodeID",
	"repository_full_name": "Description.RepoFullName",
	"size":                 "Description.Size",
	"url":                  "Description.URL",
}

func GetBlob(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetBlob")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewBlobPaginator(essdk.BuildFilter(ctx, d.QueryContext, getBlobFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Blob =============================

// ==========================  START: Branch =============================

type Branch struct {
	ResourceID      string                   `json:"resource_id"`
	PlatformID      string                   `json:"platform_id"`
	Description     github.BranchDescription `json:"description"`
	Metadata        github.Metadata          `json:"metadata"`
	DescribedBy     string                   `json:"described_by"`
	ResourceType    string                   `json:"resource_type"`
	IntegrationType string                   `json:"integration_type"`
	IntegrationID   string                   `json:"integration_id"`
}

type BranchHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Branch        `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type BranchHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []BranchHit       `json:"hits"`
}

type BranchSearchResponse struct {
	PitID string     `json:"pit_id"`
	Hits  BranchHits `json:"hits"`
}

type BranchPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewBranchPaginator(filters []essdk.BoolFilter, limit *int64) (BranchPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_branch", filters, limit)
	if err != nil {
		return BranchPaginator{}, err
	}

	p := BranchPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p BranchPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p BranchPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p BranchPaginator) NextPage(ctx context.Context) ([]Branch, error) {
	var response BranchSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Branch
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listBranchFilters = map[string]string{
	"branch_protection_rule": "Description.BranchProtectionRule",
	"commit":                 "Description.Commit",
	"name":                   "Description.Name",
	"protected":              "Description.Protected",
	"repository_full_name":   "Description.RepoFullName",
}

func ListBranch(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListBranch")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListBranch NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListBranch NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListBranch GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListBranch GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListBranch GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewBranchPaginator(essdk.BuildFilter(ctx, d.QueryContext, listBranchFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListBranch NewBranchPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListBranch paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getBranchFilters = map[string]string{
	"branch_protection_rule": "Description.BranchProtectionRule",
	"commit":                 "Description.Commit",
	"name":                   "Description.Name",
	"protected":              "Description.Protected",
	"repository_full_name":   "Description.RepoFullName",
}

func GetBranch(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetBranch")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewBranchPaginator(essdk.BuildFilter(ctx, d.QueryContext, getBranchFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Branch =============================

// ==========================  START: BranchProtection =============================

type BranchProtection struct {
	ResourceID      string                             `json:"resource_id"`
	PlatformID      string                             `json:"platform_id"`
	Description     github.BranchProtectionDescription `json:"description"`
	Metadata        github.Metadata                    `json:"metadata"`
	DescribedBy     string                             `json:"described_by"`
	ResourceType    string                             `json:"resource_type"`
	IntegrationType string                             `json:"integration_type"`
	IntegrationID   string                             `json:"integration_id"`
}

type BranchProtectionHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  BranchProtection `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type BranchProtectionHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []BranchProtectionHit `json:"hits"`
}

type BranchProtectionSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  BranchProtectionHits `json:"hits"`
}

type BranchProtectionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewBranchProtectionPaginator(filters []essdk.BoolFilter, limit *int64) (BranchProtectionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_branch_protection", filters, limit)
	if err != nil {
		return BranchProtectionPaginator{}, err
	}

	p := BranchProtectionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p BranchProtectionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p BranchProtectionPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p BranchProtectionPaginator) NextPage(ctx context.Context) ([]BranchProtection, error) {
	var response BranchProtectionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []BranchProtection
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listBranchProtectionFilters = map[string]string{
	"id":                   "Description.Id",
	"node_id":              "Description.NodeId",
	"repository_full_name": "Description.RepoFullName",
}

func ListBranchProtection(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListBranchProtection")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListBranchProtection NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListBranchProtection NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListBranchProtection GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListBranchProtection GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListBranchProtection GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewBranchProtectionPaginator(essdk.BuildFilter(ctx, d.QueryContext, listBranchProtectionFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListBranchProtection NewBranchProtectionPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListBranchProtection paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getBranchProtectionFilters = map[string]string{
	"id":                   "Description.Id",
	"node_id":              "Description.NodeId",
	"repository_full_name": "Description.RepoFullName",
}

func GetBranchProtection(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetBranchProtection")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewBranchProtectionPaginator(essdk.BuildFilter(ctx, d.QueryContext, getBranchProtectionFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: BranchProtection =============================

// ==========================  START: Commit =============================

type Commit struct {
	ResourceID      string                   `json:"resource_id"`
	PlatformID      string                   `json:"platform_id"`
	Description     github.CommitDescription `json:"description"`
	Metadata        github.Metadata          `json:"metadata"`
	DescribedBy     string                   `json:"described_by"`
	ResourceType    string                   `json:"resource_type"`
	IntegrationType string                   `json:"integration_type"`
	IntegrationID   string                   `json:"integration_id"`
}

type CommitHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Commit        `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type CommitHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []CommitHit       `json:"hits"`
}

type CommitSearchResponse struct {
	PitID string     `json:"pit_id"`
	Hits  CommitHits `json:"hits"`
}

type CommitPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCommitPaginator(filters []essdk.BoolFilter, limit *int64) (CommitPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_commit", filters, limit)
	if err != nil {
		return CommitPaginator{}, err
	}

	p := CommitPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CommitPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CommitPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CommitPaginator) NextPage(ctx context.Context) ([]Commit, error) {
	var response CommitSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Commit
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCommitFilters = map[string]string{
	"additions":             "Description.Additions",
	"author":                "Description.Author",
	"author_login":          "Description.AuthorLogin",
	"authored_by_committer": "Description.AuthoredByCommitter",
	"can_subscribe":         "Description.CanSubscribe",
	"changed_files":         "Description.ChangedFiles",
	"commit_url":            "Description.CommitUrl",
	"committed_via_web":     "Description.CommittedViaWeb",
	"committer":             "Description.Committer",
	"committer_login":       "Description.CommitterLogin",
	"deletions":             "Description.Deletions",
	"message":               "Description.Message",
	"message_headline":      "Description.MessageHeadline",
	"node_id":               "Description.NodeId",
	"repository_full_name":  "Description.RepoFullName",
	"sha":                   "Description.Sha",
	"short_sha":             "Description.ShortSha",
	"signature":             "Description.Signature",
	"status":                "Description.Status",
	"subscription":          "Description.Subscription",
	"tarball_url":           "Description.TarballUrl",
	"tree_url":              "Description.TreeUrl",
	"url":                   "Description.Url",
	"zipball_url":           "Description.ZipballUrl",
}

func ListCommit(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCommit")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCommit NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCommit NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCommit GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCommit GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCommit GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCommitPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCommitFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCommit NewCommitPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCommit paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCommitFilters = map[string]string{
	"additions":             "Description.Additions",
	"author":                "Description.Author",
	"author_login":          "Description.AuthorLogin",
	"authored_by_committer": "Description.AuthoredByCommitter",
	"can_subscribe":         "Description.CanSubscribe",
	"changed_files":         "Description.ChangedFiles",
	"commit_url":            "Description.CommitUrl",
	"committed_via_web":     "Description.CommittedViaWeb",
	"committer":             "Description.Committer",
	"committer_login":       "Description.CommitterLogin",
	"deletions":             "Description.Deletions",
	"message":               "Description.Message",
	"message_headline":      "Description.MessageHeadline",
	"node_id":               "Description.NodeId",
	"repository_full_name":  "Description.RepoFullName",
	"sha":                   "Description.Sha",
	"short_sha":             "Description.ShortSha",
	"signature":             "Description.Signature",
	"status":                "Description.Status",
	"subscription":          "Description.Subscription",
	"tarball_url":           "Description.TarballUrl",
	"tree_url":              "Description.TreeUrl",
	"url":                   "Description.Url",
	"zipball_url":           "Description.ZipballUrl",
}

func GetCommit(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCommit")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCommitPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCommitFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Commit =============================

// ==========================  START: CommunityProfile =============================

type CommunityProfile struct {
	ResourceID      string                             `json:"resource_id"`
	PlatformID      string                             `json:"platform_id"`
	Description     github.CommunityProfileDescription `json:"description"`
	Metadata        github.Metadata                    `json:"metadata"`
	DescribedBy     string                             `json:"described_by"`
	ResourceType    string                             `json:"resource_type"`
	IntegrationType string                             `json:"integration_type"`
	IntegrationID   string                             `json:"integration_id"`
}

type CommunityProfileHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  CommunityProfile `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type CommunityProfileHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []CommunityProfileHit `json:"hits"`
}

type CommunityProfileSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  CommunityProfileHits `json:"hits"`
}

type CommunityProfilePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCommunityProfilePaginator(filters []essdk.BoolFilter, limit *int64) (CommunityProfilePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_communityprofile", filters, limit)
	if err != nil {
		return CommunityProfilePaginator{}, err
	}

	p := CommunityProfilePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CommunityProfilePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CommunityProfilePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CommunityProfilePaginator) NextPage(ctx context.Context) ([]CommunityProfile, error) {
	var response CommunityProfileSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CommunityProfile
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCommunityProfileFilters = map[string]string{
	"code_of_conduct":        "Description.CodeOfConduct",
	"contributing":           "Description.Contributing",
	"issue_templates":        "Description.IssueTemplates",
	"license_info":           "Description.LicenseInfo",
	"pull_request_templates": "Description.PullRequestTemplates",
	"readme":                 "Description.ReadMe",
	"repository_full_name":   "Description.RepoFullName",
	"security":               "Description.Security",
}

func ListCommunityProfile(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCommunityProfile")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCommunityProfile NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCommunityProfile NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCommunityProfile GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCommunityProfile GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCommunityProfile GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCommunityProfilePaginator(essdk.BuildFilter(ctx, d.QueryContext, listCommunityProfileFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCommunityProfile NewCommunityProfilePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCommunityProfile paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCommunityProfileFilters = map[string]string{
	"code_of_conduct":        "Description.CodeOfConduct",
	"contributing":           "Description.Contributing",
	"issue_templates":        "Description.IssueTemplates",
	"license_info":           "Description.LicenseInfo",
	"pull_request_templates": "Description.PullRequestTemplates",
	"readme":                 "Description.ReadMe",
	"repository_full_name":   "Description.RepoFullName",
	"security":               "Description.Security",
}

func GetCommunityProfile(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCommunityProfile")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCommunityProfilePaginator(essdk.BuildFilter(ctx, d.QueryContext, getCommunityProfileFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CommunityProfile =============================

// ==========================  START: GitIgnore =============================

type GitIgnore struct {
	ResourceID      string                      `json:"resource_id"`
	PlatformID      string                      `json:"platform_id"`
	Description     github.GitIgnoreDescription `json:"description"`
	Metadata        github.Metadata             `json:"metadata"`
	DescribedBy     string                      `json:"described_by"`
	ResourceType    string                      `json:"resource_type"`
	IntegrationType string                      `json:"integration_type"`
	IntegrationID   string                      `json:"integration_id"`
}

type GitIgnoreHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  GitIgnore     `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type GitIgnoreHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []GitIgnoreHit    `json:"hits"`
}

type GitIgnoreSearchResponse struct {
	PitID string        `json:"pit_id"`
	Hits  GitIgnoreHits `json:"hits"`
}

type GitIgnorePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGitIgnorePaginator(filters []essdk.BoolFilter, limit *int64) (GitIgnorePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_gitignore", filters, limit)
	if err != nil {
		return GitIgnorePaginator{}, err
	}

	p := GitIgnorePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GitIgnorePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GitIgnorePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p GitIgnorePaginator) NextPage(ctx context.Context) ([]GitIgnore, error) {
	var response GitIgnoreSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GitIgnore
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGitIgnoreFilters = map[string]string{
	"name":   "Description.Name",
	"source": "Description.Source",
}

func ListGitIgnore(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGitIgnore")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListGitIgnore NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListGitIgnore NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListGitIgnore GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListGitIgnore GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListGitIgnore GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewGitIgnorePaginator(essdk.BuildFilter(ctx, d.QueryContext, listGitIgnoreFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListGitIgnore NewGitIgnorePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListGitIgnore paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getGitIgnoreFilters = map[string]string{
	"name":   "Description.Name",
	"source": "Description.Source",
}

func GetGitIgnore(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGitIgnore")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewGitIgnorePaginator(essdk.BuildFilter(ctx, d.QueryContext, getGitIgnoreFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: GitIgnore =============================

// ==========================  START: Issue =============================

type Issue struct {
	ResourceID      string                  `json:"resource_id"`
	PlatformID      string                  `json:"platform_id"`
	Description     github.IssueDescription `json:"description"`
	Metadata        github.Metadata         `json:"metadata"`
	DescribedBy     string                  `json:"described_by"`
	ResourceType    string                  `json:"resource_type"`
	IntegrationType string                  `json:"integration_type"`
	IntegrationID   string                  `json:"integration_id"`
}

type IssueHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Issue         `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type IssueHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []IssueHit        `json:"hits"`
}

type IssueSearchResponse struct {
	PitID string    `json:"pit_id"`
	Hits  IssueHits `json:"hits"`
}

type IssuePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIssuePaginator(filters []essdk.BoolFilter, limit *int64) (IssuePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_issue", filters, limit)
	if err != nil {
		return IssuePaginator{}, err
	}

	p := IssuePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IssuePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IssuePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p IssuePaginator) NextPage(ctx context.Context) ([]Issue, error) {
	var response IssueSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Issue
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIssueFilters = map[string]string{
	"active_lock_reason":         "Description.ActiveLockReason",
	"assignees":                  "Description.Assignees",
	"assignees_total_count":      "Description.AssigneesTotalCount",
	"author":                     "Description.Author",
	"author_association":         "Description.AuthorAssociation",
	"author_login":               "Description.AuthorLogin",
	"body":                       "Description.Body",
	"body_url":                   "Description.BodyUrl",
	"closed":                     "Description.Closed",
	"comments_total_count":       "Description.CommentsTotalCount",
	"created_via_email":          "Description.CreatedViaEmail",
	"editor":                     "Description.Editor",
	"full_database_id":           "Description.FullDatabaseId",
	"id":                         "Description.Id",
	"includes_created_edit":      "Description.IncludesCreatedEdit",
	"is_pinned":                  "Description.IsPinned",
	"is_read_by_user":            "Description.IsReadByUser",
	"labels":                     "Description.Labels",
	"labels_src":                 "Description.LabelsSrc",
	"labels_total_count":         "Description.LabelsTotalCount",
	"locked":                     "Description.Locked",
	"milestone":                  "Description.Milestone",
	"node_id":                    "Description.NodeId",
	"number":                     "Description.Number",
	"repository_full_name":       "Description.RepositoryFullName",
	"state":                      "Description.State",
	"state_reason":               "Description.StateReason",
	"title":                      "Description.Title",
	"url":                        "Description.Url",
	"user_can_close":             "Description.UserCanClose",
	"user_can_react":             "Description.UserCanReact",
	"user_can_reopen":            "Description.UserCanReopen",
	"user_can_subscribe":         "Description.UserCanSubscribe",
	"user_can_update":            "Description.UserCanUpdate",
	"user_cannot_update_reasons": "Description.UserCannotUpdateReasons",
	"user_did_author":            "Description.UserDidAuthor",
	"user_subscription":          "Description.UserSubscription",
}

func ListIssue(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIssue")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListIssue NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListIssue NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListIssue GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListIssue GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListIssue GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewIssuePaginator(essdk.BuildFilter(ctx, d.QueryContext, listIssueFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListIssue NewIssuePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListIssue paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getIssueFilters = map[string]string{
	"active_lock_reason":         "Description.ActiveLockReason",
	"assignees":                  "Description.Assignees",
	"assignees_total_count":      "Description.AssigneesTotalCount",
	"author":                     "Description.Author",
	"author_association":         "Description.AuthorAssociation",
	"author_login":               "Description.AuthorLogin",
	"body":                       "Description.Body",
	"body_url":                   "Description.BodyUrl",
	"closed":                     "Description.Closed",
	"comments_total_count":       "Description.CommentsTotalCount",
	"created_via_email":          "Description.CreatedViaEmail",
	"editor":                     "Description.Editor",
	"full_database_id":           "Description.FullDatabaseId",
	"id":                         "Description.Id",
	"includes_created_edit":      "Description.IncludesCreatedEdit",
	"is_pinned":                  "Description.IsPinned",
	"is_read_by_user":            "Description.IsReadByUser",
	"labels":                     "Description.Labels",
	"labels_src":                 "Description.LabelsSrc",
	"labels_total_count":         "Description.LabelsTotalCount",
	"locked":                     "Description.Locked",
	"milestone":                  "Description.Milestone",
	"node_id":                    "Description.NodeId",
	"number":                     "Description.Number",
	"repository_full_name":       "Description.RepositoryFullName",
	"state":                      "Description.State",
	"state_reason":               "Description.StateReason",
	"title":                      "Description.Title",
	"url":                        "Description.Url",
	"user_can_close":             "Description.UserCanClose",
	"user_can_react":             "Description.UserCanReact",
	"user_can_reopen":            "Description.UserCanReopen",
	"user_can_subscribe":         "Description.UserCanSubscribe",
	"user_can_update":            "Description.UserCanUpdate",
	"user_cannot_update_reasons": "Description.UserCannotUpdateReasons",
	"user_did_author":            "Description.UserDidAuthor",
	"user_subscription":          "Description.UserSubscription",
}

func GetIssue(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIssue")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewIssuePaginator(essdk.BuildFilter(ctx, d.QueryContext, getIssueFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Issue =============================

// ==========================  START: IssueComment =============================

type IssueComment struct {
	ResourceID      string                         `json:"resource_id"`
	PlatformID      string                         `json:"platform_id"`
	Description     github.IssueCommentDescription `json:"description"`
	Metadata        github.Metadata                `json:"metadata"`
	DescribedBy     string                         `json:"described_by"`
	ResourceType    string                         `json:"resource_type"`
	IntegrationType string                         `json:"integration_type"`
	IntegrationID   string                         `json:"integration_id"`
}

type IssueCommentHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  IssueComment  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type IssueCommentHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []IssueCommentHit `json:"hits"`
}

type IssueCommentSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  IssueCommentHits `json:"hits"`
}

type IssueCommentPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIssueCommentPaginator(filters []essdk.BoolFilter, limit *int64) (IssueCommentPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_issue_comment", filters, limit)
	if err != nil {
		return IssueCommentPaginator{}, err
	}

	p := IssueCommentPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IssueCommentPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IssueCommentPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p IssueCommentPaginator) NextPage(ctx context.Context) ([]IssueComment, error) {
	var response IssueCommentSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []IssueComment
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIssueCommentFilters = map[string]string{
	"author":                "Description.Author",
	"author_association":    "Description.AuthorAssociation",
	"author_login":          "Description.AuthorLogin",
	"body":                  "Description.Body",
	"body_text":             "Description.BodyText",
	"can_delete":            "Description.CanDelete",
	"can_minimize":          "Description.CanMinimize",
	"can_react":             "Description.CanReact",
	"can_update":            "Description.CanUpdate",
	"cannot_update_reasons": "Description.CannotUpdateReasons",
	"created_via_email":     "Description.CreatedViaEmail",
	"did_author":            "Description.DidAuthor",
	"editor":                "Description.Editor",
	"editor_login":          "Description.EditorLogin",
	"id":                    "Description.Id",
	"includes_created_edit": "Description.IncludesCreatedEdit",
	"is_minimized":          "Description.IsMinimized",
	"minimized_reason":      "Description.MinimizedReason",
	"node_id":               "Description.NodeId",
	"number":                "Description.Number",
	"repository_full_name":  "Description.RepoFullName",
	"url":                   "Description.Url",
}

func ListIssueComment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIssueComment")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListIssueComment NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListIssueComment NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListIssueComment GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListIssueComment GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListIssueComment GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewIssueCommentPaginator(essdk.BuildFilter(ctx, d.QueryContext, listIssueCommentFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListIssueComment NewIssueCommentPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListIssueComment paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getIssueCommentFilters = map[string]string{
	"author":                "Description.Author",
	"author_association":    "Description.AuthorAssociation",
	"author_login":          "Description.AuthorLogin",
	"body":                  "Description.Body",
	"body_text":             "Description.BodyText",
	"can_delete":            "Description.CanDelete",
	"can_minimize":          "Description.CanMinimize",
	"can_react":             "Description.CanReact",
	"can_update":            "Description.CanUpdate",
	"cannot_update_reasons": "Description.CannotUpdateReasons",
	"created_via_email":     "Description.CreatedViaEmail",
	"did_author":            "Description.DidAuthor",
	"editor":                "Description.Editor",
	"editor_login":          "Description.EditorLogin",
	"id":                    "Description.Id",
	"includes_created_edit": "Description.IncludesCreatedEdit",
	"is_minimized":          "Description.IsMinimized",
	"minimized_reason":      "Description.MinimizedReason",
	"node_id":               "Description.NodeId",
	"number":                "Description.Number",
	"repository_full_name":  "Description.RepoFullName",
	"url":                   "Description.Url",
}

func GetIssueComment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIssueComment")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewIssueCommentPaginator(essdk.BuildFilter(ctx, d.QueryContext, getIssueCommentFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: IssueComment =============================

// ==========================  START: License =============================

type License struct {
	ResourceID      string                    `json:"resource_id"`
	PlatformID      string                    `json:"platform_id"`
	Description     github.LicenseDescription `json:"description"`
	Metadata        github.Metadata           `json:"metadata"`
	DescribedBy     string                    `json:"described_by"`
	ResourceType    string                    `json:"resource_type"`
	IntegrationType string                    `json:"integration_type"`
	IntegrationID   string                    `json:"integration_id"`
}

type LicenseHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  License       `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type LicenseHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []LicenseHit      `json:"hits"`
}

type LicenseSearchResponse struct {
	PitID string      `json:"pit_id"`
	Hits  LicenseHits `json:"hits"`
}

type LicensePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLicensePaginator(filters []essdk.BoolFilter, limit *int64) (LicensePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_license", filters, limit)
	if err != nil {
		return LicensePaginator{}, err
	}

	p := LicensePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LicensePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LicensePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p LicensePaginator) NextPage(ctx context.Context) ([]License, error) {
	var response LicenseSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []License
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLicenseFilters = map[string]string{
	"conditions":     "Description.Conditions",
	"description":    "Description.Description",
	"featured":       "Description.Featured",
	"hidden":         "Description.Hidden",
	"implementation": "Description.Implementation",
	"key":            "Description.Key",
	"limitations":    "Description.Limitations",
	"name":           "Description.Name",
	"nickname":       "Description.Nickname",
	"permissions":    "Description.Permissions",
	"pseudo_license": "Description.PseudoLicense",
	"spdx_id":        "Description.SpdxId",
	"url":            "Description.Url",
}

func ListLicense(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLicense")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListLicense NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListLicense NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListLicense GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListLicense GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListLicense GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewLicensePaginator(essdk.BuildFilter(ctx, d.QueryContext, listLicenseFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListLicense NewLicensePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListLicense paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getLicenseFilters = map[string]string{
	"conditions":     "Description.Conditions",
	"description":    "Description.Description",
	"featured":       "Description.Featured",
	"hidden":         "Description.Hidden",
	"implementation": "Description.Implementation",
	"key":            "Description.Key",
	"limitations":    "Description.Limitations",
	"name":           "Description.Name",
	"nickname":       "Description.Nickname",
	"permissions":    "Description.Permissions",
	"pseudo_license": "Description.PseudoLicense",
	"spdx_id":        "Description.SpdxId",
	"url":            "Description.Url",
}

func GetLicense(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLicense")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewLicensePaginator(essdk.BuildFilter(ctx, d.QueryContext, getLicenseFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: License =============================

// ==========================  START: Organization =============================

type Organization struct {
	ResourceID      string                         `json:"resource_id"`
	PlatformID      string                         `json:"platform_id"`
	Description     github.OrganizationDescription `json:"description"`
	Metadata        github.Metadata                `json:"metadata"`
	DescribedBy     string                         `json:"described_by"`
	ResourceType    string                         `json:"resource_type"`
	IntegrationType string                         `json:"integration_type"`
	IntegrationID   string                         `json:"integration_id"`
}

type OrganizationHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Organization  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type OrganizationHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []OrganizationHit `json:"hits"`
}

type OrganizationSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  OrganizationHits `json:"hits"`
}

type OrganizationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewOrganizationPaginator(filters []essdk.BoolFilter, limit *int64) (OrganizationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_organization", filters, limit)
	if err != nil {
		return OrganizationPaginator{}, err
	}

	p := OrganizationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p OrganizationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p OrganizationPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p OrganizationPaginator) NextPage(ctx context.Context) ([]Organization, error) {
	var response OrganizationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Organization
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listOrganizationFilters = map[string]string{
	"announcement":                            "Description.Announcement",
	"announcement_user_dismissible":           "Description.AnnouncementUserDismissible",
	"any_pinnable_items":                      "Description.AnyPinnableItems",
	"avatar_url":                              "Description.AvatarUrl",
	"billing_email":                           "Description.BillingEmail",
	"can_administer":                          "Description.CanAdminister",
	"can_changed_pinned_items":                "Description.CanChangedPinnedItems",
	"can_create_projects":                     "Description.CanCreateProjects",
	"can_create_repositories":                 "Description.CanCreateRepositories",
	"can_create_teams":                        "Description.CanCreateTeams",
	"can_sponsor":                             "Description.CanSponsor",
	"collaborators":                           "Description.Collaborators",
	"default_repo_permission":                 "Description.DefaultRepoPermission",
	"description":                             "Description.Description",
	"email":                                   "Description.Email",
	"estimated_next_sponsors_payout_in_cents": "Description.EstimatedNextSponsorsPayoutInCents",
	"followers":                               "Description.Followers",
	"following":                               "Description.Following",
	"has_organization_projects":               "Description.HasOrganizationProjects",
	"has_repository_projects":                 "Description.HasRepositoryProjects",
	"has_sponsors_listing":                    "Description.HasSponsorsListing",
	"hooks":                                   "Description.Hooks",
	"id":                                      "Description.Id",
	"interaction_ability":                     "Description.InteractionAbility",
	"is_a_member":                             "Description.IsAMember",
	"is_following":                            "Description.IsFollowing",
	"is_sponsoring":                           "Description.IsSponsoring",
	"is_sponsoring_you":                       "Description.IsSponsoringYou",
	"is_verified":                             "Description.IsVerified",
	"location":                                "Description.Location",
	"login":                                   "Description.Login",
	"members_allowed_repository_creation_type":   "Description.MembersAllowedRepositoryCreationType",
	"members_can_create_internal_repos":          "Description.MembersCanCreateInternalRepos",
	"members_can_create_pages":                   "Description.MembersCanCreatePages",
	"members_can_create_private_repos":           "Description.MembersCanCreatePrivateRepos",
	"members_can_create_public_repos":            "Description.MembersCanCreatePublicRepos",
	"members_can_create_repos":                   "Description.MembersCanCreateRepos",
	"members_can_fork_private_repos":             "Description.MembersCanForkPrivateRepos",
	"members_with_role_total_count":              "Description.MembersWithRoleTotalCount",
	"monthly_estimated_sponsors_income_in_cents": "Description.MonthlyEstimatedSponsorsIncomeInCents",
	"name":                                         "Description.Name",
	"new_team_url":                                 "Description.NewTeamUrl",
	"node_id":                                      "Description.NodeId",
	"packages_total_count":                         "Description.PackagesTotalCount",
	"pinnable_items_total_count":                   "Description.PinnableItemsTotalCount",
	"pinned_items_remaining":                       "Description.PinnedItemsRemaining",
	"pinned_items_total_count":                     "Description.PinnedItemsTotalCount",
	"plan_filled_seats":                            "Description.PlanFilledSeats",
	"plan_name":                                    "Description.PlanName",
	"plan_private_repos":                           "Description.PlanPrivateRepos",
	"plan_seats":                                   "Description.PlanSeats",
	"plan_space":                                   "Description.PlanSpace",
	"private_repositories_total_count":             "Description.PrivateRepositoriesTotalCount",
	"projects_total_count":                         "Description.ProjectsTotalCount",
	"projects_url":                                 "Description.ProjectsUrl",
	"projects_v2_total_count":                      "Description.ProjectsV2TotalCount",
	"public_repositories_total_count":              "Description.PublicRepositoriesTotalCount",
	"repositories_total_count":                     "Description.RepositoriesTotalCount",
	"repositories_total_disk_usage":                "Description.RepositoriesTotalDiskUsage",
	"saml_identity_provider":                       "Description.SamlIdentityProvider",
	"sponsoring_total_count":                       "Description.SponsoringTotalCount",
	"sponsors_listing":                             "Description.SponsorsListing",
	"sponsors_total_count":                         "Description.SponsorsTotalCount",
	"teams_total_count":                            "Description.TeamsTotalCount",
	"teams_url":                                    "Description.TeamsUrl",
	"total_sponsorship_amount_as_sponsor_in_cents": "Description.TotalSponsorshipAmountAsSponsorInCents",
	"twitter_username":                             "Description.TwitterUsername",
	"two_factor_requirement_enabled":               "Description.TwoFactorRequirementEnabled",
	"url":                                          "Description.Url",
	"web_commit_signoff_required":                  "Description.WebCommitSignoffRequired",
	"website_url":                                  "Description.WebsiteUrl",
}

func ListOrganization(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListOrganization")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganization NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganization NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganization GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganization GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganization GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewOrganizationPaginator(essdk.BuildFilter(ctx, d.QueryContext, listOrganizationFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganization NewOrganizationPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListOrganization paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getOrganizationFilters = map[string]string{
	"announcement":                            "Description.Announcement",
	"announcement_user_dismissible":           "Description.AnnouncementUserDismissible",
	"any_pinnable_items":                      "Description.AnyPinnableItems",
	"avatar_url":                              "Description.AvatarUrl",
	"billing_email":                           "Description.BillingEmail",
	"can_administer":                          "Description.CanAdminister",
	"can_changed_pinned_items":                "Description.CanChangedPinnedItems",
	"can_create_projects":                     "Description.CanCreateProjects",
	"can_create_repositories":                 "Description.CanCreateRepositories",
	"can_create_teams":                        "Description.CanCreateTeams",
	"can_sponsor":                             "Description.CanSponsor",
	"collaborators":                           "Description.Collaborators",
	"default_repo_permission":                 "Description.DefaultRepoPermission",
	"description":                             "Description.Description",
	"email":                                   "Description.Email",
	"estimated_next_sponsors_payout_in_cents": "Description.EstimatedNextSponsorsPayoutInCents",
	"followers":                               "Description.Followers",
	"following":                               "Description.Following",
	"has_organization_projects":               "Description.HasOrganizationProjects",
	"has_repository_projects":                 "Description.HasRepositoryProjects",
	"has_sponsors_listing":                    "Description.HasSponsorsListing",
	"hooks":                                   "Description.Hooks",
	"id":                                      "Description.Id",
	"interaction_ability":                     "Description.InteractionAbility",
	"is_a_member":                             "Description.IsAMember",
	"is_following":                            "Description.IsFollowing",
	"is_sponsoring":                           "Description.IsSponsoring",
	"is_sponsoring_you":                       "Description.IsSponsoringYou",
	"is_verified":                             "Description.IsVerified",
	"location":                                "Description.Location",
	"login":                                   "Description.Login",
	"members_allowed_repository_creation_type":   "Description.MembersAllowedRepositoryCreationType",
	"members_can_create_internal_repos":          "Description.MembersCanCreateInternalRepos",
	"members_can_create_pages":                   "Description.MembersCanCreatePages",
	"members_can_create_private_repos":           "Description.MembersCanCreatePrivateRepos",
	"members_can_create_public_repos":            "Description.MembersCanCreatePublicRepos",
	"members_can_create_repos":                   "Description.MembersCanCreateRepos",
	"members_can_fork_private_repos":             "Description.MembersCanForkPrivateRepos",
	"members_with_role_total_count":              "Description.MembersWithRoleTotalCount",
	"monthly_estimated_sponsors_income_in_cents": "Description.MonthlyEstimatedSponsorsIncomeInCents",
	"name":                                         "Description.Name",
	"new_team_url":                                 "Description.NewTeamUrl",
	"node_id":                                      "Description.NodeId",
	"packages_total_count":                         "Description.PackagesTotalCount",
	"pinnable_items_total_count":                   "Description.PinnableItemsTotalCount",
	"pinned_items_remaining":                       "Description.PinnedItemsRemaining",
	"pinned_items_total_count":                     "Description.PinnedItemsTotalCount",
	"plan_filled_seats":                            "Description.PlanFilledSeats",
	"plan_name":                                    "Description.PlanName",
	"plan_private_repos":                           "Description.PlanPrivateRepos",
	"plan_seats":                                   "Description.PlanSeats",
	"plan_space":                                   "Description.PlanSpace",
	"private_repositories_total_count":             "Description.PrivateRepositoriesTotalCount",
	"projects_total_count":                         "Description.ProjectsTotalCount",
	"projects_url":                                 "Description.ProjectsUrl",
	"projects_v2_total_count":                      "Description.ProjectsV2TotalCount",
	"public_repositories_total_count":              "Description.PublicRepositoriesTotalCount",
	"repositories_total_count":                     "Description.RepositoriesTotalCount",
	"repositories_total_disk_usage":                "Description.RepositoriesTotalDiskUsage",
	"saml_identity_provider":                       "Description.SamlIdentityProvider",
	"sponsoring_total_count":                       "Description.SponsoringTotalCount",
	"sponsors_listing":                             "Description.SponsorsListing",
	"sponsors_total_count":                         "Description.SponsorsTotalCount",
	"teams_total_count":                            "Description.TeamsTotalCount",
	"teams_url":                                    "Description.TeamsUrl",
	"total_sponsorship_amount_as_sponsor_in_cents": "Description.TotalSponsorshipAmountAsSponsorInCents",
	"twitter_username":                             "Description.TwitterUsername",
	"two_factor_requirement_enabled":               "Description.TwoFactorRequirementEnabled",
	"url":                                          "Description.Url",
	"web_commit_signoff_required":                  "Description.WebCommitSignoffRequired",
	"website_url":                                  "Description.WebsiteUrl",
}

func GetOrganization(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetOrganization")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewOrganizationPaginator(essdk.BuildFilter(ctx, d.QueryContext, getOrganizationFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Organization =============================

// ==========================  START: OrgCollaborators =============================

type OrgCollaborators struct {
	ResourceID      string                             `json:"resource_id"`
	PlatformID      string                             `json:"platform_id"`
	Description     github.OrgCollaboratorsDescription `json:"description"`
	Metadata        github.Metadata                    `json:"metadata"`
	DescribedBy     string                             `json:"described_by"`
	ResourceType    string                             `json:"resource_type"`
	IntegrationType string                             `json:"integration_type"`
	IntegrationID   string                             `json:"integration_id"`
}

type OrgCollaboratorsHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  OrgCollaborators `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type OrgCollaboratorsHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []OrgCollaboratorsHit `json:"hits"`
}

type OrgCollaboratorsSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  OrgCollaboratorsHits `json:"hits"`
}

type OrgCollaboratorsPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewOrgCollaboratorsPaginator(filters []essdk.BoolFilter, limit *int64) (OrgCollaboratorsPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_organization_collaborator", filters, limit)
	if err != nil {
		return OrgCollaboratorsPaginator{}, err
	}

	p := OrgCollaboratorsPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p OrgCollaboratorsPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p OrgCollaboratorsPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p OrgCollaboratorsPaginator) NextPage(ctx context.Context) ([]OrgCollaborators, error) {
	var response OrgCollaboratorsSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []OrgCollaborators
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listOrgCollaboratorsFilters = map[string]string{
	"affiliation":     "Description.Affiliation",
	"organization":    "Description.Organization",
	"permission":      "Description.Permission",
	"repository_name": "Description.RepositoryName",
	"user_login":      "Description.UserLogin",
}

func ListOrgCollaborators(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListOrgCollaborators")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgCollaborators NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgCollaborators NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgCollaborators GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgCollaborators GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgCollaborators GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewOrgCollaboratorsPaginator(essdk.BuildFilter(ctx, d.QueryContext, listOrgCollaboratorsFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgCollaborators NewOrgCollaboratorsPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListOrgCollaborators paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getOrgCollaboratorsFilters = map[string]string{
	"affiliation":     "Description.Affiliation",
	"organization":    "Description.Organization",
	"permission":      "Description.Permission",
	"repository_name": "Description.RepositoryName",
	"user_login":      "Description.UserLogin",
}

func GetOrgCollaborators(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetOrgCollaborators")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewOrgCollaboratorsPaginator(essdk.BuildFilter(ctx, d.QueryContext, getOrgCollaboratorsFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: OrgCollaborators =============================

// ==========================  START: OrgAlertDependabot =============================

type OrgAlertDependabot struct {
	ResourceID      string                               `json:"resource_id"`
	PlatformID      string                               `json:"platform_id"`
	Description     github.OrgAlertDependabotDescription `json:"description"`
	Metadata        github.Metadata                      `json:"metadata"`
	DescribedBy     string                               `json:"described_by"`
	ResourceType    string                               `json:"resource_type"`
	IntegrationType string                               `json:"integration_type"`
	IntegrationID   string                               `json:"integration_id"`
}

type OrgAlertDependabotHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  OrgAlertDependabot `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type OrgAlertDependabotHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []OrgAlertDependabotHit `json:"hits"`
}

type OrgAlertDependabotSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  OrgAlertDependabotHits `json:"hits"`
}

type OrgAlertDependabotPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewOrgAlertDependabotPaginator(filters []essdk.BoolFilter, limit *int64) (OrgAlertDependabotPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_organization_dependabotalert", filters, limit)
	if err != nil {
		return OrgAlertDependabotPaginator{}, err
	}

	p := OrgAlertDependabotPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p OrgAlertDependabotPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p OrgAlertDependabotPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p OrgAlertDependabotPaginator) NextPage(ctx context.Context) ([]OrgAlertDependabot, error) {
	var response OrgAlertDependabotSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []OrgAlertDependabot
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listOrgAlertDependabotFilters = map[string]string{
	"alert_number":                         "Description.AlertNumber",
	"dependency_manifest_path":             "Description.DependencyManifestPath",
	"dependency_package_ecosystem":         "Description.DependencyPackageEcosystem",
	"dependency_package_name":              "Description.DependencyPackageName",
	"dependency_scope":                     "Description.DependencyScope",
	"dismissed_comment":                    "Description.DismissedComment",
	"dismissed_reason":                     "Description.DismissedReason",
	"html_url":                             "Description.HTMLURL",
	"repository_full_name":                 "Description.RepoFullName",
	"security_advisory_cve_id":             "Description.SecurityAdvisoryCVEID",
	"security_advisory_cvss_score":         "Description.SecurityAdvisoryCVSSScore",
	"security_advisory_cvss_vector_string": "Description.SecurityAdvisoryCVSSVector",
	"security_advisory_cwes":               "Description.SecurityAdvisoryCWEs",
	"security_advisory_description":        "Description.SecurityAdvisoryDescription",
	"security_advisory_ghsa_id":            "Description.SecurityAdvisoryGHSAID",
	"security_advisory_severity":           "Description.SecurityAdvisorySeverity",
	"security_advisory_summary":            "Description.SecurityAdvisorySummary",
	"state":                                "Description.State",
	"url":                                  "Description.URL",
}

func ListOrgAlertDependabot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListOrgAlertDependabot")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgAlertDependabot NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgAlertDependabot NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgAlertDependabot GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgAlertDependabot GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgAlertDependabot GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewOrgAlertDependabotPaginator(essdk.BuildFilter(ctx, d.QueryContext, listOrgAlertDependabotFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgAlertDependabot NewOrgAlertDependabotPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListOrgAlertDependabot paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getOrgAlertDependabotFilters = map[string]string{
	"alert_number":                         "Description.AlertNumber",
	"dependency_manifest_path":             "Description.DependencyManifestPath",
	"dependency_package_ecosystem":         "Description.DependencyPackageEcosystem",
	"dependency_package_name":              "Description.DependencyPackageName",
	"dependency_scope":                     "Description.DependencyScope",
	"dismissed_comment":                    "Description.DismissedComment",
	"dismissed_reason":                     "Description.DismissedReason",
	"html_url":                             "Description.HTMLURL",
	"repository_full_name":                 "Description.RepoFullName",
	"security_advisory_cve_id":             "Description.SecurityAdvisoryCVEID",
	"security_advisory_cvss_score":         "Description.SecurityAdvisoryCVSSScore",
	"security_advisory_cvss_vector_string": "Description.SecurityAdvisoryCVSSVector",
	"security_advisory_cwes":               "Description.SecurityAdvisoryCWEs",
	"security_advisory_description":        "Description.SecurityAdvisoryDescription",
	"security_advisory_ghsa_id":            "Description.SecurityAdvisoryGHSAID",
	"security_advisory_severity":           "Description.SecurityAdvisorySeverity",
	"security_advisory_summary":            "Description.SecurityAdvisorySummary",
	"state":                                "Description.State",
	"url":                                  "Description.URL",
}

func GetOrgAlertDependabot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetOrgAlertDependabot")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewOrgAlertDependabotPaginator(essdk.BuildFilter(ctx, d.QueryContext, getOrgAlertDependabotFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: OrgAlertDependabot =============================

// ==========================  START: OrgExternalIdentity =============================

type OrgExternalIdentity struct {
	ResourceID      string                                `json:"resource_id"`
	PlatformID      string                                `json:"platform_id"`
	Description     github.OrgExternalIdentityDescription `json:"description"`
	Metadata        github.Metadata                       `json:"metadata"`
	DescribedBy     string                                `json:"described_by"`
	ResourceType    string                                `json:"resource_type"`
	IntegrationType string                                `json:"integration_type"`
	IntegrationID   string                                `json:"integration_id"`
}

type OrgExternalIdentityHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  OrgExternalIdentity `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type OrgExternalIdentityHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []OrgExternalIdentityHit `json:"hits"`
}

type OrgExternalIdentitySearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  OrgExternalIdentityHits `json:"hits"`
}

type OrgExternalIdentityPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewOrgExternalIdentityPaginator(filters []essdk.BoolFilter, limit *int64) (OrgExternalIdentityPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_organization_externalidentity", filters, limit)
	if err != nil {
		return OrgExternalIdentityPaginator{}, err
	}

	p := OrgExternalIdentityPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p OrgExternalIdentityPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p OrgExternalIdentityPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p OrgExternalIdentityPaginator) NextPage(ctx context.Context) ([]OrgExternalIdentity, error) {
	var response OrgExternalIdentitySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []OrgExternalIdentity
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listOrgExternalIdentityFilters = map[string]string{
	"guid":                    "Description.Guid",
	"organization":            "Description.Organization",
	"organization_invitation": "Description.OrganizationInvitation",
	"saml_identity":           "Description.SamlIdentity",
	"scim_identity":           "Description.ScimIdentity",
	"user_detail":             "Description.User",
	"user_login":              "Description.User.Login",
}

func ListOrgExternalIdentity(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListOrgExternalIdentity")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgExternalIdentity NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgExternalIdentity NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgExternalIdentity GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgExternalIdentity GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgExternalIdentity GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewOrgExternalIdentityPaginator(essdk.BuildFilter(ctx, d.QueryContext, listOrgExternalIdentityFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgExternalIdentity NewOrgExternalIdentityPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListOrgExternalIdentity paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getOrgExternalIdentityFilters = map[string]string{
	"guid":                    "Description.Guid",
	"organization":            "Description.Organization",
	"organization_invitation": "Description.OrganizationInvitation",
	"saml_identity":           "Description.SamlIdentity",
	"scim_identity":           "Description.ScimIdentity",
	"user_detail":             "Description.User",
	"user_login":              "Description.User.Login",
}

func GetOrgExternalIdentity(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetOrgExternalIdentity")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewOrgExternalIdentityPaginator(essdk.BuildFilter(ctx, d.QueryContext, getOrgExternalIdentityFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: OrgExternalIdentity =============================

// ==========================  START: OrgMembers =============================

type OrgMembers struct {
	ResourceID      string                       `json:"resource_id"`
	PlatformID      string                       `json:"platform_id"`
	Description     github.OrgMembersDescription `json:"description"`
	Metadata        github.Metadata              `json:"metadata"`
	DescribedBy     string                       `json:"described_by"`
	ResourceType    string                       `json:"resource_type"`
	IntegrationType string                       `json:"integration_type"`
	IntegrationID   string                       `json:"integration_id"`
}

type OrgMembersHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  OrgMembers    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type OrgMembersHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []OrgMembersHit   `json:"hits"`
}

type OrgMembersSearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  OrgMembersHits `json:"hits"`
}

type OrgMembersPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewOrgMembersPaginator(filters []essdk.BoolFilter, limit *int64) (OrgMembersPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_organization_member", filters, limit)
	if err != nil {
		return OrgMembersPaginator{}, err
	}

	p := OrgMembersPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p OrgMembersPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p OrgMembersPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p OrgMembersPaginator) NextPage(ctx context.Context) ([]OrgMembers, error) {
	var response OrgMembersSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []OrgMembers
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listOrgMembersFilters = map[string]string{
	"has_two_factor_enabled": "Description.HasTwoFactorEnabled",
	"organization":           "Description.Organization",
	"role":                   "Description.Role",
}

func ListOrgMembers(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListOrgMembers")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgMembers NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgMembers NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgMembers GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgMembers GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgMembers GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewOrgMembersPaginator(essdk.BuildFilter(ctx, d.QueryContext, listOrgMembersFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrgMembers NewOrgMembersPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListOrgMembers paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getOrgMembersFilters = map[string]string{
	"has_two_factor_enabled": "Description.HasTwoFactorEnabled",
	"organization":           "Description.Organization",
	"role":                   "Description.Role",
}

func GetOrgMembers(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetOrgMembers")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewOrgMembersPaginator(essdk.BuildFilter(ctx, d.QueryContext, getOrgMembersFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: OrgMembers =============================

// ==========================  START: PullRequest =============================

type PullRequest struct {
	ResourceID      string                        `json:"resource_id"`
	PlatformID      string                        `json:"platform_id"`
	Description     github.PullRequestDescription `json:"description"`
	Metadata        github.Metadata               `json:"metadata"`
	DescribedBy     string                        `json:"described_by"`
	ResourceType    string                        `json:"resource_type"`
	IntegrationType string                        `json:"integration_type"`
	IntegrationID   string                        `json:"integration_id"`
}

type PullRequestHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  PullRequest   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type PullRequestHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []PullRequestHit  `json:"hits"`
}

type PullRequestSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  PullRequestHits `json:"hits"`
}

type PullRequestPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewPullRequestPaginator(filters []essdk.BoolFilter, limit *int64) (PullRequestPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_pullrequest", filters, limit)
	if err != nil {
		return PullRequestPaginator{}, err
	}

	p := PullRequestPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p PullRequestPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p PullRequestPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p PullRequestPaginator) NextPage(ctx context.Context) ([]PullRequest, error) {
	var response PullRequestSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []PullRequest
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listPullRequestFilters = map[string]string{
	"active_lock_reason":          "Description.ActiveLockReason",
	"additions":                   "Description.Additions",
	"assignees":                   "Description.Assignees",
	"assignees_total_count":       "Description.AssigneesTotalCount",
	"author":                      "Description.Author",
	"author_association":          "Description.AuthorAssociation",
	"base_ref":                    "Description.BaseRef",
	"base_ref_name":               "Description.BaseRefName",
	"body":                        "Description.Body",
	"can_apply_suggestion":        "Description.CanApplySuggestion",
	"can_close":                   "Description.CanClose",
	"can_delete_head_ref":         "Description.CanDeleteHeadRef",
	"can_disable_auto_merge":      "Description.CanDisableAutoMerge",
	"can_edit_files":              "Description.CanEditFiles",
	"can_enable_auto_merge":       "Description.CanEnableAutoMerge",
	"can_merge_as_admin":          "Description.CanMergeAsAdmin",
	"can_react":                   "Description.CanReact",
	"can_reopen":                  "Description.CanReopen",
	"can_subscribe":               "Description.CanSubscribe",
	"can_update":                  "Description.CanUpdate",
	"can_update_branch":           "Description.CanUpdateBranch",
	"cannot_update_reasons":       "Description.CannotUpdateReasons",
	"changed_files":               "Description.ChangedFiles",
	"checks_url":                  "Description.ChecksUrl",
	"closed":                      "Description.Closed",
	"commits_total_count":         "Description.CommitsTotalCount",
	"created_via_email":           "Description.CreatedViaEmail",
	"deletions":                   "Description.Deletions",
	"did_author":                  "Description.DidAuthor",
	"editor":                      "Description.Editor",
	"head_ref":                    "Description.HeadRef",
	"head_ref_name":               "Description.HeadRefName",
	"head_ref_oid":                "Description.HeadRefOid",
	"id":                          "Description.Id",
	"includes_created_edit":       "Description.IncludesCreatedEdit",
	"is_cross_repository":         "Description.IsCrossRepository",
	"is_draft":                    "Description.IsDraft",
	"is_read_by_user":             "Description.IsReadByUser",
	"labels":                      "Description.Labels",
	"labels_src":                  "Description.LabelsSrc",
	"labels_total_count":          "Description.LabelsTotalCount",
	"locked":                      "Description.Locked",
	"maintainer_can_modify":       "Description.MaintainerCanModify",
	"merge_commit":                "Description.MergeCommit",
	"mergeable":                   "Description.Mergeable",
	"merged":                      "Description.Merged",
	"merged_by":                   "Description.MergedBy",
	"milestone":                   "Description.Milestone",
	"node_id":                     "Description.NodeId",
	"number":                      "Description.Number",
	"permalink":                   "Description.Permalink",
	"repository_full_name":        "Description.RepoFullName",
	"revert_url":                  "Description.RevertUrl",
	"review_decision":             "Description.ReviewDecision",
	"review_requests_total_count": "Description.ReviewRequestsTotalCount",
	"reviews_total_count":         "Description.ReviewsTotalCount",
	"state":                       "Description.State",
	"subscription":                "Description.Subscription",
	"suggested_reviewers":         "Description.SuggestedReviewers",
	"title":                       "Description.Title",
	"total_comments_count":        "Description.TotalCommentsCount",
	"url":                         "Description.Url",
}

func ListPullRequest(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListPullRequest")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListPullRequest NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListPullRequest NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListPullRequest GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListPullRequest GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListPullRequest GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewPullRequestPaginator(essdk.BuildFilter(ctx, d.QueryContext, listPullRequestFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListPullRequest NewPullRequestPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListPullRequest paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getPullRequestFilters = map[string]string{
	"active_lock_reason":          "Description.ActiveLockReason",
	"additions":                   "Description.Additions",
	"assignees":                   "Description.Assignees",
	"assignees_total_count":       "Description.AssigneesTotalCount",
	"author":                      "Description.Author",
	"author_association":          "Description.AuthorAssociation",
	"base_ref":                    "Description.BaseRef",
	"base_ref_name":               "Description.BaseRefName",
	"body":                        "Description.Body",
	"can_apply_suggestion":        "Description.CanApplySuggestion",
	"can_close":                   "Description.CanClose",
	"can_delete_head_ref":         "Description.CanDeleteHeadRef",
	"can_disable_auto_merge":      "Description.CanDisableAutoMerge",
	"can_edit_files":              "Description.CanEditFiles",
	"can_enable_auto_merge":       "Description.CanEnableAutoMerge",
	"can_merge_as_admin":          "Description.CanMergeAsAdmin",
	"can_react":                   "Description.CanReact",
	"can_reopen":                  "Description.CanReopen",
	"can_subscribe":               "Description.CanSubscribe",
	"can_update":                  "Description.CanUpdate",
	"can_update_branch":           "Description.CanUpdateBranch",
	"cannot_update_reasons":       "Description.CannotUpdateReasons",
	"changed_files":               "Description.ChangedFiles",
	"checks_url":                  "Description.ChecksUrl",
	"closed":                      "Description.Closed",
	"commits_total_count":         "Description.CommitsTotalCount",
	"created_via_email":           "Description.CreatedViaEmail",
	"deletions":                   "Description.Deletions",
	"did_author":                  "Description.DidAuthor",
	"editor":                      "Description.Editor",
	"head_ref":                    "Description.HeadRef",
	"head_ref_name":               "Description.HeadRefName",
	"head_ref_oid":                "Description.HeadRefOid",
	"id":                          "Description.Id",
	"includes_created_edit":       "Description.IncludesCreatedEdit",
	"is_cross_repository":         "Description.IsCrossRepository",
	"is_draft":                    "Description.IsDraft",
	"is_read_by_user":             "Description.IsReadByUser",
	"labels":                      "Description.Labels",
	"labels_src":                  "Description.LabelsSrc",
	"labels_total_count":          "Description.LabelsTotalCount",
	"locked":                      "Description.Locked",
	"maintainer_can_modify":       "Description.MaintainerCanModify",
	"merge_commit":                "Description.MergeCommit",
	"mergeable":                   "Description.Mergeable",
	"merged":                      "Description.Merged",
	"merged_by":                   "Description.MergedBy",
	"milestone":                   "Description.Milestone",
	"node_id":                     "Description.NodeId",
	"number":                      "Description.Number",
	"permalink":                   "Description.Permalink",
	"repository_full_name":        "Description.RepoFullName",
	"revert_url":                  "Description.RevertUrl",
	"review_decision":             "Description.ReviewDecision",
	"review_requests_total_count": "Description.ReviewRequestsTotalCount",
	"reviews_total_count":         "Description.ReviewsTotalCount",
	"state":                       "Description.State",
	"subscription":                "Description.Subscription",
	"suggested_reviewers":         "Description.SuggestedReviewers",
	"title":                       "Description.Title",
	"total_comments_count":        "Description.TotalCommentsCount",
	"url":                         "Description.Url",
}

func GetPullRequest(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetPullRequest")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewPullRequestPaginator(essdk.BuildFilter(ctx, d.QueryContext, getPullRequestFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: PullRequest =============================

// ==========================  START: Repository =============================

type Repository struct {
	ResourceID      string                       `json:"resource_id"`
	PlatformID      string                       `json:"platform_id"`
	Description     github.RepositoryDescription `json:"description"`
	Metadata        github.Metadata              `json:"metadata"`
	DescribedBy     string                       `json:"described_by"`
	ResourceType    string                       `json:"resource_type"`
	IntegrationType string                       `json:"integration_type"`
	IntegrationID   string                       `json:"integration_id"`
}

type RepositoryHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Repository    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type RepositoryHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []RepositoryHit   `json:"hits"`
}

type RepositorySearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  RepositoryHits `json:"hits"`
}

type RepositoryPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRepositoryPaginator(filters []essdk.BoolFilter, limit *int64) (RepositoryPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_repository", filters, limit)
	if err != nil {
		return RepositoryPaginator{}, err
	}

	p := RepositoryPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RepositoryPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RepositoryPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RepositoryPaginator) NextPage(ctx context.Context) ([]Repository, error) {
	var response RepositorySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Repository
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRepositoryFilters = map[string]string{
	"allow_update_branch":              "Description.AllowUpdateBranch",
	"auto_merge_allowed":               "Description.AutoMergeAllowed",
	"can_administer":                   "Description.CanAdminister",
	"can_create_projects":              "Description.CanCreateProjects",
	"can_subscribe":                    "Description.CanSubscribe",
	"can_update_topics":                "Description.CanUpdateTopics",
	"code_of_conduct":                  "Description.CodeOfConduct",
	"contact_links":                    "Description.ContactLinks",
	"created_at":                       "Description.CreatedAt",
	"default_branch_ref":               "Description.DefaultBranchRef",
	"delete_branch_on_merge":           "Description.DeleteBranchOnMerge",
	"description":                      "Description.Description",
	"disk_usage":                       "Description.DiskUsage",
	"fork_count":                       "Description.ForkCount",
	"forking_allowed":                  "Description.ForkingAllowed",
	"full_name":                        "Description.NameWithOwner",
	"funding_links":                    "Description.FundingLinks",
	"has_discussions_enabled":          "Description.HasDiscussionsEnabled",
	"has_downloads":                    "Description.HasDownloads",
	"has_issues_enabled":               "Description.HasIssuesEnabled",
	"has_pages":                        "Description.HasPages",
	"has_projects_enabled":             "Description.HasProjectsEnabled",
	"has_starred":                      "Description.HasStarred",
	"has_vulnerability_alerts_enabled": "Description.HasVulnerabilityAlertsEnabled",
	"has_wiki_enabled":                 "Description.HasWikiEnabled",
	"homepage_url":                     "Description.HomepageURL",
	"hooks":                            "Description.Hooks",
	"id":                               "Description.Id",
	"interaction_ability":              "Description.InteractionAbility",
	"is_archived":                      "Description.IsArchived",
	"is_blank_issues_enabled":          "Description.IsBlankIssuesEnabled",
	"is_disabled":                      "Description.IsDisabled",
	"is_empty":                         "Description.IsEmpty",
	"is_fork":                          "Description.IsFork",
	"is_in_organization":               "Description.IsInOrganization",
	"is_locked":                        "Description.IsLocked",
	"is_mirror":                        "Description.IsMirror",
	"is_private":                       "Description.IsPrivate",
	"is_security_policy_enabled":       "Description.IsSecurityPolicyEnabled",
	"is_template":                      "Description.IsTemplate",
	"is_user_configuration_repository": "Description.IsUserConfigurationRepository",
	"issue_templates":                  "Description.IssueTemplates",
	"license_info":                     "Description.LicenseInfo",
	"lock_reason":                      "Description.LockReason",
	"merge_commit_allowed":             "Description.MergeCommitAllowed",
	"merge_commit_message":             "Description.MergeCommitMessage",
	"merge_commit_title":               "Description.MergeCommitTitle",
	"mirror_url":                       "Description.MirrorURL",
	"name":                             "Description.Name",
	"name_with_owner":                  "Description.NameWithOwner",
	"network_count":                    "Description.NetworkCount",
	"node_id":                          "Description.NodeId",
	"open_graph_image_url":             "Description.OpenGraphImageURL",
	"open_issues_total_count":          "Description.OpenIssuesTotalCount",
	"owner_login":                      "Description.OwnerLogin",
	"possible_commit_emails":           "Description.PossibleCommitEmails",
	"primary_language":                 "Description.PrimaryLanguage",
	"projects_url":                     "Description.ProjectsURL",
	"pull_request_templates":           "Description.PullRequestTemplates",
	"rebase_merge_allowed":             "Description.RebaseMergeAllowed",
	"repository_topics_total_count":    "Description.RepositoryTopicsTotalCount",
	"security_policy_url":              "Description.SecurityPolicyURL",
	"squash_merge_allowed":             "Description.SquashMergeAllowed",
	"squash_merge_commit_message":      "Description.SquashMergeCommitMessage",
	"squash_merge_commit_title":        "Description.SquashMergeCommitTitle",
	"ssh_url":                          "Description.SSHURL",
	"stargazer_count":                  "Description.StargazerCount",
	"subscribers_count":                "Description.SubscribersCount",
	"subscription":                     "Description.Subscription",
	"topics":                           "Description.Topics",
	"url":                              "Description.URL",
	"uses_custom_open_graph_image":     "Description.UsesCustomOpenGraphImage",
	"visibility":                       "Description.Visibility",
	"watchers_total_count":             "Description.WatchersTotalCount",
	"web_commit_signoff_required":      "Description.WebCommitSignOffRequired",
	"your_permission":                  "Description.YourPermission",
}

func ListRepository(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRepository")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepository NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepository NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepository GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepository GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepository GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRepositoryPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRepositoryFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepository NewRepositoryPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRepository paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRepositoryFilters = map[string]string{
	"allow_update_branch":              "Description.AllowUpdateBranch",
	"auto_merge_allowed":               "Description.AutoMergeAllowed",
	"can_administer":                   "Description.CanAdminister",
	"can_create_projects":              "Description.CanCreateProjects",
	"can_subscribe":                    "Description.CanSubscribe",
	"can_update_topics":                "Description.CanUpdateTopics",
	"code_of_conduct":                  "Description.CodeOfConduct",
	"contact_links":                    "Description.ContactLinks",
	"created_at":                       "Description.CreatedAt",
	"default_branch_ref":               "Description.DefaultBranchRef",
	"delete_branch_on_merge":           "Description.DeleteBranchOnMerge",
	"description":                      "Description.Description",
	"disk_usage":                       "Description.DiskUsage",
	"fork_count":                       "Description.ForkCount",
	"forking_allowed":                  "Description.ForkingAllowed",
	"full_name":                        "Description.NameWithOwner",
	"funding_links":                    "Description.FundingLinks",
	"has_discussions_enabled":          "Description.HasDiscussionsEnabled",
	"has_downloads":                    "Description.HasDownloads",
	"has_issues_enabled":               "Description.HasIssuesEnabled",
	"has_pages":                        "Description.HasPages",
	"has_projects_enabled":             "Description.HasProjectsEnabled",
	"has_starred":                      "Description.HasStarred",
	"has_vulnerability_alerts_enabled": "Description.HasVulnerabilityAlertsEnabled",
	"has_wiki_enabled":                 "Description.HasWikiEnabled",
	"homepage_url":                     "Description.HomepageURL",
	"hooks":                            "Description.Hooks",
	"id":                               "Description.Id",
	"interaction_ability":              "Description.InteractionAbility",
	"is_archived":                      "Description.IsArchived",
	"is_blank_issues_enabled":          "Description.IsBlankIssuesEnabled",
	"is_disabled":                      "Description.IsDisabled",
	"is_empty":                         "Description.IsEmpty",
	"is_fork":                          "Description.IsFork",
	"is_in_organization":               "Description.IsInOrganization",
	"is_locked":                        "Description.IsLocked",
	"is_mirror":                        "Description.IsMirror",
	"is_private":                       "Description.IsPrivate",
	"is_security_policy_enabled":       "Description.IsSecurityPolicyEnabled",
	"is_template":                      "Description.IsTemplate",
	"is_user_configuration_repository": "Description.IsUserConfigurationRepository",
	"issue_templates":                  "Description.IssueTemplates",
	"license_info":                     "Description.LicenseInfo",
	"lock_reason":                      "Description.LockReason",
	"merge_commit_allowed":             "Description.MergeCommitAllowed",
	"merge_commit_message":             "Description.MergeCommitMessage",
	"merge_commit_title":               "Description.MergeCommitTitle",
	"mirror_url":                       "Description.MirrorURL",
	"name":                             "Description.Name",
	"name_with_owner":                  "Description.NameWithOwner",
	"network_count":                    "Description.NetworkCount",
	"node_id":                          "Description.NodeId",
	"open_graph_image_url":             "Description.OpenGraphImageURL",
	"open_issues_total_count":          "Description.OpenIssuesTotalCount",
	"owner_login":                      "Description.OwnerLogin",
	"possible_commit_emails":           "Description.PossibleCommitEmails",
	"primary_language":                 "Description.PrimaryLanguage",
	"projects_url":                     "Description.ProjectsURL",
	"pull_request_templates":           "Description.PullRequestTemplates",
	"rebase_merge_allowed":             "Description.RebaseMergeAllowed",
	"repository_topics_total_count":    "Description.RepositoryTopicsTotalCount",
	"security_policy_url":              "Description.SecurityPolicyURL",
	"squash_merge_allowed":             "Description.SquashMergeAllowed",
	"squash_merge_commit_message":      "Description.SquashMergeCommitMessage",
	"squash_merge_commit_title":        "Description.SquashMergeCommitTitle",
	"ssh_url":                          "Description.SSHURL",
	"stargazer_count":                  "Description.StargazerCount",
	"subscribers_count":                "Description.SubscribersCount",
	"subscription":                     "Description.Subscription",
	"topics":                           "Description.Topics",
	"url":                              "Description.URL",
	"uses_custom_open_graph_image":     "Description.UsesCustomOpenGraphImage",
	"visibility":                       "Description.Visibility",
	"watchers_total_count":             "Description.WatchersTotalCount",
	"web_commit_signoff_required":      "Description.WebCommitSignOffRequired",
	"your_permission":                  "Description.YourPermission",
}

func GetRepository(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRepository")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRepositoryPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRepositoryFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Repository =============================

// ==========================  START: Release =============================

type Release struct {
	ResourceID      string                    `json:"resource_id"`
	PlatformID      string                    `json:"platform_id"`
	Description     github.ReleaseDescription `json:"description"`
	Metadata        github.Metadata           `json:"metadata"`
	DescribedBy     string                    `json:"described_by"`
	ResourceType    string                    `json:"resource_type"`
	IntegrationType string                    `json:"integration_type"`
	IntegrationID   string                    `json:"integration_id"`
}

type ReleaseHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Release       `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ReleaseHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []ReleaseHit      `json:"hits"`
}

type ReleaseSearchResponse struct {
	PitID string      `json:"pit_id"`
	Hits  ReleaseHits `json:"hits"`
}

type ReleasePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewReleasePaginator(filters []essdk.BoolFilter, limit *int64) (ReleasePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_release", filters, limit)
	if err != nil {
		return ReleasePaginator{}, err
	}

	p := ReleasePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ReleasePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ReleasePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ReleasePaginator) NextPage(ctx context.Context) ([]Release, error) {
	var response ReleaseSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Release
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listReleaseFilters = map[string]string{
	"assets":               "Description.Assets",
	"assets_url":           "Description.AssetsURL",
	"author_login":         "Description.AssetsURL",
	"body":                 "Description.Body",
	"draft":                "Description.Draft",
	"html_url":             "Description.HTMLURL",
	"id":                   "Description.ID",
	"name":                 "Description.Name",
	"node_id":              "Description.NodeID",
	"prerelease":           "Description.Prerelease",
	"repository_full_name": "Description.RepositoryFullName",
	"tag_name":             "Description.TagName",
	"tarball_url":          "Description.TarballURL",
	"target_commitish":     "Description.TargetCommitish",
	"upload_url":           "Description.UploadURL",
	"url":                  "Description.URL",
	"zipball_url":          "Description.ZipballURL",
}

func ListRelease(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRelease")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRelease NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRelease NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRelease GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRelease GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRelease GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewReleasePaginator(essdk.BuildFilter(ctx, d.QueryContext, listReleaseFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRelease NewReleasePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRelease paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getReleaseFilters = map[string]string{
	"assets":               "Description.Assets",
	"assets_url":           "Description.AssetsURL",
	"author_login":         "Description.AssetsURL",
	"body":                 "Description.Body",
	"draft":                "Description.Draft",
	"html_url":             "Description.HTMLURL",
	"id":                   "Description.ID",
	"name":                 "Description.Name",
	"node_id":              "Description.NodeID",
	"prerelease":           "Description.Prerelease",
	"repository_full_name": "Description.RepositoryFullName",
	"tag_name":             "Description.TagName",
	"tarball_url":          "Description.TarballURL",
	"target_commitish":     "Description.TargetCommitish",
	"upload_url":           "Description.UploadURL",
	"url":                  "Description.URL",
	"zipball_url":          "Description.ZipballURL",
}

func GetRelease(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRelease")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewReleasePaginator(essdk.BuildFilter(ctx, d.QueryContext, getReleaseFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Release =============================

// ==========================  START: RepoCollaborators =============================

type RepoCollaborators struct {
	ResourceID      string                              `json:"resource_id"`
	PlatformID      string                              `json:"platform_id"`
	Description     github.RepoCollaboratorsDescription `json:"description"`
	Metadata        github.Metadata                     `json:"metadata"`
	DescribedBy     string                              `json:"described_by"`
	ResourceType    string                              `json:"resource_type"`
	IntegrationType string                              `json:"integration_type"`
	IntegrationID   string                              `json:"integration_id"`
}

type RepoCollaboratorsHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  RepoCollaborators `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type RepoCollaboratorsHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []RepoCollaboratorsHit `json:"hits"`
}

type RepoCollaboratorsSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  RepoCollaboratorsHits `json:"hits"`
}

type RepoCollaboratorsPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRepoCollaboratorsPaginator(filters []essdk.BoolFilter, limit *int64) (RepoCollaboratorsPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_repository_collaborator", filters, limit)
	if err != nil {
		return RepoCollaboratorsPaginator{}, err
	}

	p := RepoCollaboratorsPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RepoCollaboratorsPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RepoCollaboratorsPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RepoCollaboratorsPaginator) NextPage(ctx context.Context) ([]RepoCollaborators, error) {
	var response RepoCollaboratorsSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RepoCollaborators
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRepoCollaboratorsFilters = map[string]string{
	"affiliation":          "Description.Affiliation",
	"permission":           "Description.Permission",
	"repository_full_name": "Description.RepoFullName",
	"user_login":           "Description.UserLogin",
}

func ListRepoCollaborators(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRepoCollaborators")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoCollaborators NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoCollaborators NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoCollaborators GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoCollaborators GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoCollaborators GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRepoCollaboratorsPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRepoCollaboratorsFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoCollaborators NewRepoCollaboratorsPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRepoCollaborators paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRepoCollaboratorsFilters = map[string]string{
	"affiliation":          "Description.Affiliation",
	"permission":           "Description.Permission",
	"repository_full_name": "Description.RepoFullName",
	"user_login":           "Description.UserLogin",
}

func GetRepoCollaborators(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRepoCollaborators")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRepoCollaboratorsPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRepoCollaboratorsFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RepoCollaborators =============================

// ==========================  START: RepoAlertDependabot =============================

type RepoAlertDependabot struct {
	ResourceID      string                                `json:"resource_id"`
	PlatformID      string                                `json:"platform_id"`
	Description     github.RepoAlertDependabotDescription `json:"description"`
	Metadata        github.Metadata                       `json:"metadata"`
	DescribedBy     string                                `json:"described_by"`
	ResourceType    string                                `json:"resource_type"`
	IntegrationType string                                `json:"integration_type"`
	IntegrationID   string                                `json:"integration_id"`
}

type RepoAlertDependabotHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  RepoAlertDependabot `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type RepoAlertDependabotHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []RepoAlertDependabotHit `json:"hits"`
}

type RepoAlertDependabotSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  RepoAlertDependabotHits `json:"hits"`
}

type RepoAlertDependabotPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRepoAlertDependabotPaginator(filters []essdk.BoolFilter, limit *int64) (RepoAlertDependabotPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_repository_dependabotalert", filters, limit)
	if err != nil {
		return RepoAlertDependabotPaginator{}, err
	}

	p := RepoAlertDependabotPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RepoAlertDependabotPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RepoAlertDependabotPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RepoAlertDependabotPaginator) NextPage(ctx context.Context) ([]RepoAlertDependabot, error) {
	var response RepoAlertDependabotSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RepoAlertDependabot
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRepoAlertDependabotFilters = map[string]string{}

func ListRepoAlertDependabot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRepoAlertDependabot")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoAlertDependabot NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoAlertDependabot NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoAlertDependabot GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoAlertDependabot GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoAlertDependabot GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRepoAlertDependabotPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRepoAlertDependabotFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoAlertDependabot NewRepoAlertDependabotPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRepoAlertDependabot paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRepoAlertDependabotFilters = map[string]string{}

func GetRepoAlertDependabot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRepoAlertDependabot")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRepoAlertDependabotPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRepoAlertDependabotFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RepoAlertDependabot =============================

// ==========================  START: RepoDeployment =============================

type RepoDeployment struct {
	ResourceID      string                           `json:"resource_id"`
	PlatformID      string                           `json:"platform_id"`
	Description     github.RepoDeploymentDescription `json:"description"`
	Metadata        github.Metadata                  `json:"metadata"`
	DescribedBy     string                           `json:"described_by"`
	ResourceType    string                           `json:"resource_type"`
	IntegrationType string                           `json:"integration_type"`
	IntegrationID   string                           `json:"integration_id"`
}

type RepoDeploymentHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  RepoDeployment `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type RepoDeploymentHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []RepoDeploymentHit `json:"hits"`
}

type RepoDeploymentSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  RepoDeploymentHits `json:"hits"`
}

type RepoDeploymentPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRepoDeploymentPaginator(filters []essdk.BoolFilter, limit *int64) (RepoDeploymentPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_repository_deployment", filters, limit)
	if err != nil {
		return RepoDeploymentPaginator{}, err
	}

	p := RepoDeploymentPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RepoDeploymentPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RepoDeploymentPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RepoDeploymentPaginator) NextPage(ctx context.Context) ([]RepoDeployment, error) {
	var response RepoDeploymentSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RepoDeployment
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRepoDeploymentFilters = map[string]string{
	"commit_sha":           "Description.CommitSha",
	"creator":              "Description.Creator",
	"description":          "Description.Description",
	"environment":          "Description.Environment",
	"id":                   "Description.Id",
	"latest_environment":   "Description.LatestEnvironment",
	"latest_status":        "Description.LatestStatus",
	"node_id":              "Description.NodeId",
	"original_environment": "Description.OriginalEnvironment",
	"payload":              "Description.Payload",
	"ref":                  "Description.Ref",
	"repository_full_name": "Description.RepoFullName",
	"state":                "Description.State",
	"task":                 "Description.Task",
}

func ListRepoDeployment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRepoDeployment")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoDeployment NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoDeployment NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoDeployment GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoDeployment GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoDeployment GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRepoDeploymentPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRepoDeploymentFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoDeployment NewRepoDeploymentPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRepoDeployment paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRepoDeploymentFilters = map[string]string{
	"commit_sha":           "Description.CommitSha",
	"creator":              "Description.Creator",
	"description":          "Description.Description",
	"environment":          "Description.Environment",
	"id":                   "Description.Id",
	"latest_environment":   "Description.LatestEnvironment",
	"latest_status":        "Description.LatestStatus",
	"node_id":              "Description.NodeId",
	"original_environment": "Description.OriginalEnvironment",
	"payload":              "Description.Payload",
	"ref":                  "Description.Ref",
	"repository_full_name": "Description.RepoFullName",
	"state":                "Description.State",
	"task":                 "Description.Task",
}

func GetRepoDeployment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRepoDeployment")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRepoDeploymentPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRepoDeploymentFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RepoDeployment =============================

// ==========================  START: RepoEnvironment =============================

type RepoEnvironment struct {
	ResourceID      string                            `json:"resource_id"`
	PlatformID      string                            `json:"platform_id"`
	Description     github.RepoEnvironmentDescription `json:"description"`
	Metadata        github.Metadata                   `json:"metadata"`
	DescribedBy     string                            `json:"described_by"`
	ResourceType    string                            `json:"resource_type"`
	IntegrationType string                            `json:"integration_type"`
	IntegrationID   string                            `json:"integration_id"`
}

type RepoEnvironmentHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  RepoEnvironment `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type RepoEnvironmentHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []RepoEnvironmentHit `json:"hits"`
}

type RepoEnvironmentSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  RepoEnvironmentHits `json:"hits"`
}

type RepoEnvironmentPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRepoEnvironmentPaginator(filters []essdk.BoolFilter, limit *int64) (RepoEnvironmentPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_repository_environment", filters, limit)
	if err != nil {
		return RepoEnvironmentPaginator{}, err
	}

	p := RepoEnvironmentPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RepoEnvironmentPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RepoEnvironmentPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RepoEnvironmentPaginator) NextPage(ctx context.Context) ([]RepoEnvironment, error) {
	var response RepoEnvironmentSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RepoEnvironment
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRepoEnvironmentFilters = map[string]string{
	"id":                   "Description.Id",
	"name":                 "Description.Name",
	"node_id":              "Description.NodeId",
	"repository_full_name": "Description.RepoFullName",
}

func ListRepoEnvironment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRepoEnvironment")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoEnvironment NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoEnvironment NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoEnvironment GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoEnvironment GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoEnvironment GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRepoEnvironmentPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRepoEnvironmentFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoEnvironment NewRepoEnvironmentPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRepoEnvironment paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRepoEnvironmentFilters = map[string]string{
	"id":                   "Description.Id",
	"name":                 "Description.Name",
	"node_id":              "Description.NodeId",
	"repository_full_name": "Description.RepoFullName",
}

func GetRepoEnvironment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRepoEnvironment")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRepoEnvironmentPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRepoEnvironmentFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RepoEnvironment =============================

// ==========================  START: RepoRuleSet =============================

type RepoRuleSet struct {
	ResourceID      string                        `json:"resource_id"`
	PlatformID      string                        `json:"platform_id"`
	Description     github.RepoRuleSetDescription `json:"description"`
	Metadata        github.Metadata               `json:"metadata"`
	DescribedBy     string                        `json:"described_by"`
	ResourceType    string                        `json:"resource_type"`
	IntegrationType string                        `json:"integration_type"`
	IntegrationID   string                        `json:"integration_id"`
}

type RepoRuleSetHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  RepoRuleSet   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type RepoRuleSetHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []RepoRuleSetHit  `json:"hits"`
}

type RepoRuleSetSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  RepoRuleSetHits `json:"hits"`
}

type RepoRuleSetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRepoRuleSetPaginator(filters []essdk.BoolFilter, limit *int64) (RepoRuleSetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_repository_ruleset", filters, limit)
	if err != nil {
		return RepoRuleSetPaginator{}, err
	}

	p := RepoRuleSetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RepoRuleSetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RepoRuleSetPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RepoRuleSetPaginator) NextPage(ctx context.Context) ([]RepoRuleSet, error) {
	var response RepoRuleSetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RepoRuleSet
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRepoRuleSetFilters = map[string]string{
	"bypass_actors":        "Description.BypassActors",
	"conditions":           "Description.Conditions",
	"database_id":          "Description.DatabaseID",
	"enforcement":          "Description.Enforcement",
	"id":                   "Description.ID",
	"name":                 "Description.Name",
	"repository_full_name": "Description.RepoFullName",
	"rules":                "Description.Rules",
}

func ListRepoRuleSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRepoRuleSet")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoRuleSet NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoRuleSet NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoRuleSet GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoRuleSet GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoRuleSet GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRepoRuleSetPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRepoRuleSetFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoRuleSet NewRepoRuleSetPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRepoRuleSet paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRepoRuleSetFilters = map[string]string{
	"bypass_actors":        "Description.BypassActors",
	"conditions":           "Description.Conditions",
	"database_id":          "Description.DatabaseID",
	"enforcement":          "Description.Enforcement",
	"id":                   "Description.ID",
	"name":                 "Description.Name",
	"repository_full_name": "Description.RepoFullName",
	"rules":                "Description.Rules",
}

func GetRepoRuleSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRepoRuleSet")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRepoRuleSetPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRepoRuleSetFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RepoRuleSet =============================

// ==========================  START: RepoSBOM =============================

type RepoSBOM struct {
	ResourceID      string                     `json:"resource_id"`
	PlatformID      string                     `json:"platform_id"`
	Description     github.RepoSBOMDescription `json:"description"`
	Metadata        github.Metadata            `json:"metadata"`
	DescribedBy     string                     `json:"described_by"`
	ResourceType    string                     `json:"resource_type"`
	IntegrationType string                     `json:"integration_type"`
	IntegrationID   string                     `json:"integration_id"`
}

type RepoSBOMHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  RepoSBOM      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type RepoSBOMHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []RepoSBOMHit     `json:"hits"`
}

type RepoSBOMSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  RepoSBOMHits `json:"hits"`
}

type RepoSBOMPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRepoSBOMPaginator(filters []essdk.BoolFilter, limit *int64) (RepoSBOMPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_repository_sbom", filters, limit)
	if err != nil {
		return RepoSBOMPaginator{}, err
	}

	p := RepoSBOMPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RepoSBOMPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RepoSBOMPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RepoSBOMPaginator) NextPage(ctx context.Context) ([]RepoSBOM, error) {
	var response RepoSBOMSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RepoSBOM
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRepoSBOMFilters = map[string]string{
	"creation_info":        "Description.CreationInfo",
	"data_license":         "Description.DataLicense",
	"document_describes":   "Description.DocumentDescribes",
	"document_namespace":   "Description.DocumentNamespace",
	"name":                 "Description.Name",
	"packages":             "Description.Packages",
	"repository_full_name": "Description.RepositoryFullName",
	"spdx_id":              "Description.SPDXID",
	"spdx_version":         "Description.SPDXVersion",
}

func ListRepoSBOM(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRepoSBOM")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoSBOM NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoSBOM NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoSBOM GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoSBOM GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoSBOM GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRepoSBOMPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRepoSBOMFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoSBOM NewRepoSBOMPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRepoSBOM paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRepoSBOMFilters = map[string]string{
	"creation_info":        "Description.CreationInfo",
	"data_license":         "Description.DataLicense",
	"document_describes":   "Description.DocumentDescribes",
	"document_namespace":   "Description.DocumentNamespace",
	"name":                 "Description.Name",
	"packages":             "Description.Packages",
	"repository_full_name": "Description.RepositoryFullName",
	"spdx_id":              "Description.SPDXID",
	"spdx_version":         "Description.SPDXVersion",
}

func GetRepoSBOM(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRepoSBOM")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRepoSBOMPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRepoSBOMFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RepoSBOM =============================

// ==========================  START: RepoVulnerabilityAlert =============================

type RepoVulnerabilityAlert struct {
	ResourceID      string                                   `json:"resource_id"`
	PlatformID      string                                   `json:"platform_id"`
	Description     github.RepoVulnerabilityAlertDescription `json:"description"`
	Metadata        github.Metadata                          `json:"metadata"`
	DescribedBy     string                                   `json:"described_by"`
	ResourceType    string                                   `json:"resource_type"`
	IntegrationType string                                   `json:"integration_type"`
	IntegrationID   string                                   `json:"integration_id"`
}

type RepoVulnerabilityAlertHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  RepoVulnerabilityAlert `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type RepoVulnerabilityAlertHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []RepoVulnerabilityAlertHit `json:"hits"`
}

type RepoVulnerabilityAlertSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  RepoVulnerabilityAlertHits `json:"hits"`
}

type RepoVulnerabilityAlertPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRepoVulnerabilityAlertPaginator(filters []essdk.BoolFilter, limit *int64) (RepoVulnerabilityAlertPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_repository_vulnerabilityalert", filters, limit)
	if err != nil {
		return RepoVulnerabilityAlertPaginator{}, err
	}

	p := RepoVulnerabilityAlertPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RepoVulnerabilityAlertPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RepoVulnerabilityAlertPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RepoVulnerabilityAlertPaginator) NextPage(ctx context.Context) ([]RepoVulnerabilityAlert, error) {
	var response RepoVulnerabilityAlertSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RepoVulnerabilityAlert
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRepoVulnerabilityAlertFilters = map[string]string{
	"cvss_score":                   "Description.CvssScore",
	"dependency_scope":             "Description.DependencyScope",
	"dismiss_comment":              "Description.DismissComment",
	"dismiss_reason":               "Description.DismissReason",
	"dismisser":                    "Description.Dismisser",
	"node_id":                      "Description.NodeID",
	"number":                       "Description.Number",
	"repository_full_name":         "Description.RepositoryFullName",
	"security_advisory":            "Description.SecurityAdvisory",
	"security_vulnerability":       "Description.SecurityVulnerability",
	"severity":                     "Description.Severity",
	"state":                        "Description.State",
	"vulnerable_manifest_filename": "Description.VulnerableManifestFilename",
	"vulnerable_manifest_path":     "Description.VulnerableManifestPath",
	"vulnerable_requirements":      "Description.VulnerableRequirements",
}

func ListRepoVulnerabilityAlert(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRepoVulnerabilityAlert")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoVulnerabilityAlert NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoVulnerabilityAlert NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoVulnerabilityAlert GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoVulnerabilityAlert GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoVulnerabilityAlert GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRepoVulnerabilityAlertPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRepoVulnerabilityAlertFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRepoVulnerabilityAlert NewRepoVulnerabilityAlertPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRepoVulnerabilityAlert paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRepoVulnerabilityAlertFilters = map[string]string{
	"cvss_score":                   "Description.CvssScore",
	"dependency_scope":             "Description.DependencyScope",
	"dismiss_comment":              "Description.DismissComment",
	"dismiss_reason":               "Description.DismissReason",
	"dismisser":                    "Description.Dismisser",
	"node_id":                      "Description.NodeID",
	"number":                       "Description.Number",
	"repository_full_name":         "Description.RepositoryFullName",
	"security_advisory":            "Description.SecurityAdvisory",
	"security_vulnerability":       "Description.SecurityVulnerability",
	"severity":                     "Description.Severity",
	"state":                        "Description.State",
	"vulnerable_manifest_filename": "Description.VulnerableManifestFilename",
	"vulnerable_manifest_path":     "Description.VulnerableManifestPath",
	"vulnerable_requirements":      "Description.VulnerableRequirements",
}

func GetRepoVulnerabilityAlert(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRepoVulnerabilityAlert")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRepoVulnerabilityAlertPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRepoVulnerabilityAlertFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RepoVulnerabilityAlert =============================

// ==========================  START: Stargazer =============================

type Stargazer struct {
	ResourceID      string                      `json:"resource_id"`
	PlatformID      string                      `json:"platform_id"`
	Description     github.StargazerDescription `json:"description"`
	Metadata        github.Metadata             `json:"metadata"`
	DescribedBy     string                      `json:"described_by"`
	ResourceType    string                      `json:"resource_type"`
	IntegrationType string                      `json:"integration_type"`
	IntegrationID   string                      `json:"integration_id"`
}

type StargazerHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Stargazer     `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type StargazerHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []StargazerHit    `json:"hits"`
}

type StargazerSearchResponse struct {
	PitID string        `json:"pit_id"`
	Hits  StargazerHits `json:"hits"`
}

type StargazerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewStargazerPaginator(filters []essdk.BoolFilter, limit *int64) (StargazerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_stargazer", filters, limit)
	if err != nil {
		return StargazerPaginator{}, err
	}

	p := StargazerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p StargazerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p StargazerPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p StargazerPaginator) NextPage(ctx context.Context) ([]Stargazer, error) {
	var response StargazerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Stargazer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listStargazerFilters = map[string]string{
	"repository_full_name": "Description.RepoFullName",
	"user_detail":          "Description.UserDetail",
	"user_login":           "Description.UserLogin",
}

func ListStargazer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListStargazer")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListStargazer NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListStargazer NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListStargazer GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListStargazer GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListStargazer GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewStargazerPaginator(essdk.BuildFilter(ctx, d.QueryContext, listStargazerFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListStargazer NewStargazerPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListStargazer paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getStargazerFilters = map[string]string{
	"repository_full_name": "Description.RepoFullName",
	"user_detail":          "Description.UserDetail",
	"user_login":           "Description.UserLogin",
}

func GetStargazer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetStargazer")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewStargazerPaginator(essdk.BuildFilter(ctx, d.QueryContext, getStargazerFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Stargazer =============================

// ==========================  START: Tag =============================

type Tag struct {
	ResourceID      string                `json:"resource_id"`
	PlatformID      string                `json:"platform_id"`
	Description     github.TagDescription `json:"description"`
	Metadata        github.Metadata       `json:"metadata"`
	DescribedBy     string                `json:"described_by"`
	ResourceType    string                `json:"resource_type"`
	IntegrationType string                `json:"integration_type"`
	IntegrationID   string                `json:"integration_id"`
}

type TagHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Tag           `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type TagHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []TagHit          `json:"hits"`
}

type TagSearchResponse struct {
	PitID string  `json:"pit_id"`
	Hits  TagHits `json:"hits"`
}

type TagPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewTagPaginator(filters []essdk.BoolFilter, limit *int64) (TagPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_tag", filters, limit)
	if err != nil {
		return TagPaginator{}, err
	}

	p := TagPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p TagPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p TagPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p TagPaginator) NextPage(ctx context.Context) ([]Tag, error) {
	var response TagSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Tag
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listTagFilters = map[string]string{
	"commit":               "Description.Commit",
	"message":              "Description.Message",
	"name":                 "Description.Name",
	"repository_full_name": "Description.RepositoryFullName",
	"tagger_date":          "Description.TaggerDate",
	"tagger_login":         "Description.TaggerLogin",
	"tagger_name":          "Description.TaggerName",
}

func ListTag(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListTag")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListTag NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListTag NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListTag GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListTag GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListTag GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewTagPaginator(essdk.BuildFilter(ctx, d.QueryContext, listTagFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListTag NewTagPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListTag paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getTagFilters = map[string]string{
	"commit":               "Description.Commit",
	"message":              "Description.Message",
	"name":                 "Description.Name",
	"repository_full_name": "Description.RepositoryFullName",
	"tagger_date":          "Description.TaggerDate",
	"tagger_login":         "Description.TaggerLogin",
	"tagger_name":          "Description.TaggerName",
}

func GetTag(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetTag")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewTagPaginator(essdk.BuildFilter(ctx, d.QueryContext, getTagFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Tag =============================

// ==========================  START: Team =============================

type Team struct {
	ResourceID      string                 `json:"resource_id"`
	PlatformID      string                 `json:"platform_id"`
	Description     github.TeamDescription `json:"description"`
	Metadata        github.Metadata        `json:"metadata"`
	DescribedBy     string                 `json:"described_by"`
	ResourceType    string                 `json:"resource_type"`
	IntegrationType string                 `json:"integration_type"`
	IntegrationID   string                 `json:"integration_id"`
}

type TeamHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Team          `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type TeamHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []TeamHit         `json:"hits"`
}

type TeamSearchResponse struct {
	PitID string   `json:"pit_id"`
	Hits  TeamHits `json:"hits"`
}

type TeamPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewTeamPaginator(filters []essdk.BoolFilter, limit *int64) (TeamPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_team", filters, limit)
	if err != nil {
		return TeamPaginator{}, err
	}

	p := TeamPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p TeamPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p TeamPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p TeamPaginator) NextPage(ctx context.Context) ([]Team, error) {
	var response TeamSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Team
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listTeamFilters = map[string]string{
	"ancestors_total_count":    "Organization.AncestorsTotalCount",
	"avatar_url":               "Organization.AvatarURL",
	"can_administer":           "Organization.CanAdminister",
	"can_subscribe":            "Organization.CanSubscribe",
	"child_teams_total_count":  "Organization.ChildTeamsTotalCount",
	"combined_slug":            "Organization.CombinedSlug",
	"description":              "Organization.Description",
	"discussions_total_count":  "Organization.DiscussionsTotalCount",
	"discussions_url":          "Organization.DiscussionsURL",
	"edit_team_url":            "Organization.EditTeamURL",
	"id":                       "Organization.ID",
	"invitations_total_count":  "Organization.InvitationsTotalCount",
	"members_total_count":      "Organization.MembersTotalCount",
	"members_url":              "Organization.MembersURL",
	"name":                     "Organization.Name",
	"new_team_url":             "Organization.NewTeamURL",
	"node_id":                  "Organization.NodeID",
	"organization":             "Organization.Organization",
	"parent_team":              "Organization.ParentTeam",
	"privacy":                  "Organization.Privacy",
	"projects_v2_total_count":  "Organization.ProjectsV2TotalCount",
	"repositories_total_count": "Organization.RepositoriesTotalCount",
	"repositories_url":         "Organization.RepositoriesURL",
	"slug":                     "Organization.Slug",
	"subscription":             "Organization.Subscription",
	"teams_url":                "Organization.TeamsURL",
	"url":                      "Organization.URL",
}

func ListTeam(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListTeam")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeam NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeam NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeam GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeam GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeam GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewTeamPaginator(essdk.BuildFilter(ctx, d.QueryContext, listTeamFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeam NewTeamPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListTeam paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getTeamFilters = map[string]string{
	"ancestors_total_count":    "Organization.AncestorsTotalCount",
	"avatar_url":               "Organization.AvatarURL",
	"can_administer":           "Organization.CanAdminister",
	"can_subscribe":            "Organization.CanSubscribe",
	"child_teams_total_count":  "Organization.ChildTeamsTotalCount",
	"combined_slug":            "Organization.CombinedSlug",
	"description":              "Organization.Description",
	"discussions_total_count":  "Organization.DiscussionsTotalCount",
	"discussions_url":          "Organization.DiscussionsURL",
	"edit_team_url":            "Organization.EditTeamURL",
	"id":                       "Organization.ID",
	"invitations_total_count":  "Organization.InvitationsTotalCount",
	"members_total_count":      "Organization.MembersTotalCount",
	"members_url":              "Organization.MembersURL",
	"name":                     "Organization.Name",
	"new_team_url":             "Organization.NewTeamURL",
	"node_id":                  "Organization.NodeID",
	"organization":             "Organization.Organization",
	"parent_team":              "Organization.ParentTeam",
	"privacy":                  "Organization.Privacy",
	"projects_v2_total_count":  "Organization.ProjectsV2TotalCount",
	"repositories_total_count": "Organization.RepositoriesTotalCount",
	"repositories_url":         "Organization.RepositoriesURL",
	"slug":                     "Organization.Slug",
	"subscription":             "Organization.Subscription",
	"teams_url":                "Organization.TeamsURL",
	"url":                      "Organization.URL",
}

func GetTeam(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetTeam")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewTeamPaginator(essdk.BuildFilter(ctx, d.QueryContext, getTeamFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Team =============================

// ==========================  START: TeamMembers =============================

type TeamMembers struct {
	ResourceID      string                        `json:"resource_id"`
	PlatformID      string                        `json:"platform_id"`
	Description     github.TeamMembersDescription `json:"description"`
	Metadata        github.Metadata               `json:"metadata"`
	DescribedBy     string                        `json:"described_by"`
	ResourceType    string                        `json:"resource_type"`
	IntegrationType string                        `json:"integration_type"`
	IntegrationID   string                        `json:"integration_id"`
}

type TeamMembersHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  TeamMembers   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type TeamMembersHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []TeamMembersHit  `json:"hits"`
}

type TeamMembersSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  TeamMembersHits `json:"hits"`
}

type TeamMembersPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewTeamMembersPaginator(filters []essdk.BoolFilter, limit *int64) (TeamMembersPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_team_member", filters, limit)
	if err != nil {
		return TeamMembersPaginator{}, err
	}

	p := TeamMembersPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p TeamMembersPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p TeamMembersPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p TeamMembersPaginator) NextPage(ctx context.Context) ([]TeamMembers, error) {
	var response TeamMembersSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []TeamMembers
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listTeamMembersFilters = map[string]string{
	"organization": "Description.Organization",
	"role":         "Description.Role",
	"slug":         "Description.Slug",
}

func ListTeamMembers(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListTeamMembers")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeamMembers NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeamMembers NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeamMembers GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeamMembers GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeamMembers GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewTeamMembersPaginator(essdk.BuildFilter(ctx, d.QueryContext, listTeamMembersFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeamMembers NewTeamMembersPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListTeamMembers paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getTeamMembersFilters = map[string]string{
	"organization": "Description.Organization",
	"role":         "Description.Role",
	"slug":         "Description.Slug",
}

func GetTeamMembers(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetTeamMembers")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewTeamMembersPaginator(essdk.BuildFilter(ctx, d.QueryContext, getTeamMembersFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: TeamMembers =============================

// ==========================  START: TeamRepository =============================

type TeamRepository struct {
	ResourceID      string                           `json:"resource_id"`
	PlatformID      string                           `json:"platform_id"`
	Description     github.TeamRepositoryDescription `json:"description"`
	Metadata        github.Metadata                  `json:"metadata"`
	DescribedBy     string                           `json:"described_by"`
	ResourceType    string                           `json:"resource_type"`
	IntegrationType string                           `json:"integration_type"`
	IntegrationID   string                           `json:"integration_id"`
}

type TeamRepositoryHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  TeamRepository `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type TeamRepositoryHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []TeamRepositoryHit `json:"hits"`
}

type TeamRepositorySearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  TeamRepositoryHits `json:"hits"`
}

type TeamRepositoryPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewTeamRepositoryPaginator(filters []essdk.BoolFilter, limit *int64) (TeamRepositoryPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_team_repository", filters, limit)
	if err != nil {
		return TeamRepositoryPaginator{}, err
	}

	p := TeamRepositoryPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p TeamRepositoryPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p TeamRepositoryPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p TeamRepositoryPaginator) NextPage(ctx context.Context) ([]TeamRepository, error) {
	var response TeamRepositorySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []TeamRepository
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listTeamRepositoryFilters = map[string]string{}

func ListTeamRepository(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListTeamRepository")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeamRepository NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeamRepository NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeamRepository GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeamRepository GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeamRepository GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewTeamRepositoryPaginator(essdk.BuildFilter(ctx, d.QueryContext, listTeamRepositoryFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListTeamRepository NewTeamRepositoryPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListTeamRepository paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getTeamRepositoryFilters = map[string]string{}

func GetTeamRepository(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetTeamRepository")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewTeamRepositoryPaginator(essdk.BuildFilter(ctx, d.QueryContext, getTeamRepositoryFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: TeamRepository =============================

// ==========================  START: TrafficViewDaily =============================

type TrafficViewDaily struct {
	ResourceID      string                             `json:"resource_id"`
	PlatformID      string                             `json:"platform_id"`
	Description     github.TrafficViewDailyDescription `json:"description"`
	Metadata        github.Metadata                    `json:"metadata"`
	DescribedBy     string                             `json:"described_by"`
	ResourceType    string                             `json:"resource_type"`
	IntegrationType string                             `json:"integration_type"`
	IntegrationID   string                             `json:"integration_id"`
}

type TrafficViewDailyHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  TrafficViewDaily `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type TrafficViewDailyHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []TrafficViewDailyHit `json:"hits"`
}

type TrafficViewDailySearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  TrafficViewDailyHits `json:"hits"`
}

type TrafficViewDailyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewTrafficViewDailyPaginator(filters []essdk.BoolFilter, limit *int64) (TrafficViewDailyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_traffic_view_daily", filters, limit)
	if err != nil {
		return TrafficViewDailyPaginator{}, err
	}

	p := TrafficViewDailyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p TrafficViewDailyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p TrafficViewDailyPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p TrafficViewDailyPaginator) NextPage(ctx context.Context) ([]TrafficViewDaily, error) {
	var response TrafficViewDailySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []TrafficViewDaily
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listTrafficViewDailyFilters = map[string]string{
	"count":                "Description.Count",
	"repository_full_name": "Description.RepositoryFullName",
	"uniques":              "Description.Uniques",
}

func ListTrafficViewDaily(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListTrafficViewDaily")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListTrafficViewDaily NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListTrafficViewDaily NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListTrafficViewDaily GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListTrafficViewDaily GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListTrafficViewDaily GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewTrafficViewDailyPaginator(essdk.BuildFilter(ctx, d.QueryContext, listTrafficViewDailyFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListTrafficViewDaily NewTrafficViewDailyPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListTrafficViewDaily paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getTrafficViewDailyFilters = map[string]string{
	"count":                "Description.Count",
	"repository_full_name": "Description.RepositoryFullName",
	"uniques":              "Description.Uniques",
}

func GetTrafficViewDaily(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetTrafficViewDaily")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewTrafficViewDailyPaginator(essdk.BuildFilter(ctx, d.QueryContext, getTrafficViewDailyFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: TrafficViewDaily =============================

// ==========================  START: TrafficViewWeekly =============================

type TrafficViewWeekly struct {
	ResourceID      string                              `json:"resource_id"`
	PlatformID      string                              `json:"platform_id"`
	Description     github.TrafficViewWeeklyDescription `json:"description"`
	Metadata        github.Metadata                     `json:"metadata"`
	DescribedBy     string                              `json:"described_by"`
	ResourceType    string                              `json:"resource_type"`
	IntegrationType string                              `json:"integration_type"`
	IntegrationID   string                              `json:"integration_id"`
}

type TrafficViewWeeklyHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  TrafficViewWeekly `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type TrafficViewWeeklyHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []TrafficViewWeeklyHit `json:"hits"`
}

type TrafficViewWeeklySearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  TrafficViewWeeklyHits `json:"hits"`
}

type TrafficViewWeeklyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewTrafficViewWeeklyPaginator(filters []essdk.BoolFilter, limit *int64) (TrafficViewWeeklyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_traffic_view_weekly", filters, limit)
	if err != nil {
		return TrafficViewWeeklyPaginator{}, err
	}

	p := TrafficViewWeeklyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p TrafficViewWeeklyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p TrafficViewWeeklyPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p TrafficViewWeeklyPaginator) NextPage(ctx context.Context) ([]TrafficViewWeekly, error) {
	var response TrafficViewWeeklySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []TrafficViewWeekly
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listTrafficViewWeeklyFilters = map[string]string{
	"count":                "Description.Count",
	"repository_full_name": "Description.RepositoryFullName",
	"uniques":              "Description.Uniques",
}

func ListTrafficViewWeekly(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListTrafficViewWeekly")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListTrafficViewWeekly NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListTrafficViewWeekly NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListTrafficViewWeekly GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListTrafficViewWeekly GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListTrafficViewWeekly GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewTrafficViewWeeklyPaginator(essdk.BuildFilter(ctx, d.QueryContext, listTrafficViewWeeklyFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListTrafficViewWeekly NewTrafficViewWeeklyPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListTrafficViewWeekly paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getTrafficViewWeeklyFilters = map[string]string{
	"count":                "Description.Count",
	"repository_full_name": "Description.RepositoryFullName",
	"uniques":              "Description.Uniques",
}

func GetTrafficViewWeekly(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetTrafficViewWeekly")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewTrafficViewWeeklyPaginator(essdk.BuildFilter(ctx, d.QueryContext, getTrafficViewWeeklyFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: TrafficViewWeekly =============================

// ==========================  START: Tree =============================

type Tree struct {
	ResourceID      string                 `json:"resource_id"`
	PlatformID      string                 `json:"platform_id"`
	Description     github.TreeDescription `json:"description"`
	Metadata        github.Metadata        `json:"metadata"`
	DescribedBy     string                 `json:"described_by"`
	ResourceType    string                 `json:"resource_type"`
	IntegrationType string                 `json:"integration_type"`
	IntegrationID   string                 `json:"integration_id"`
}

type TreeHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Tree          `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type TreeHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []TreeHit         `json:"hits"`
}

type TreeSearchResponse struct {
	PitID string   `json:"pit_id"`
	Hits  TreeHits `json:"hits"`
}

type TreePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewTreePaginator(filters []essdk.BoolFilter, limit *int64) (TreePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_tree", filters, limit)
	if err != nil {
		return TreePaginator{}, err
	}

	p := TreePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p TreePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p TreePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p TreePaginator) NextPage(ctx context.Context) ([]Tree, error) {
	var response TreeSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Tree
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listTreeFilters = map[string]string{
	"mode":                 "Description.Mode",
	"path":                 "Description.Path",
	"recursive":            "Description.Recursive",
	"repository_full_name": "Description.RepositoryFullName",
	"sha":                  "Description.SHA",
	"size":                 "Description.Size",
	"tree_sha":             "Description.TreeSHA",
	"truncated":            "Description.Truncated",
	"type":                 "Description.Type",
	"url":                  "Description.URL",
}

func ListTree(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListTree")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListTree NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListTree NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListTree GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListTree GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListTree GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewTreePaginator(essdk.BuildFilter(ctx, d.QueryContext, listTreeFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListTree NewTreePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListTree paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getTreeFilters = map[string]string{
	"mode":                 "Description.Mode",
	"path":                 "Description.Path",
	"recursive":            "Description.Recursive",
	"repository_full_name": "Description.RepositoryFullName",
	"sha":                  "Description.SHA",
	"size":                 "Description.Size",
	"tree_sha":             "Description.TreeSHA",
	"truncated":            "Description.Truncated",
	"type":                 "Description.Type",
	"url":                  "Description.URL",
}

func GetTree(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetTree")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewTreePaginator(essdk.BuildFilter(ctx, d.QueryContext, getTreeFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Tree =============================

// ==========================  START: User =============================

type User struct {
	ResourceID      string                 `json:"resource_id"`
	PlatformID      string                 `json:"platform_id"`
	Description     github.UserDescription `json:"description"`
	Metadata        github.Metadata        `json:"metadata"`
	DescribedBy     string                 `json:"described_by"`
	ResourceType    string                 `json:"resource_type"`
	IntegrationType string                 `json:"integration_type"`
	IntegrationID   string                 `json:"integration_id"`
}

type UserHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  User          `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type UserHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []UserHit         `json:"hits"`
}

type UserSearchResponse struct {
	PitID string   `json:"pit_id"`
	Hits  UserHits `json:"hits"`
}

type UserPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewUserPaginator(filters []essdk.BoolFilter, limit *int64) (UserPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "githubuser", filters, limit)
	if err != nil {
		return UserPaginator{}, err
	}

	p := UserPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p UserPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p UserPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p UserPaginator) NextPage(ctx context.Context) ([]User, error) {
	var response UserSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []User
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listUserFilters = map[string]string{
	"any_pinnable_items":               "Description.AnyPinnableItems",
	"avatar_url":                       "Description.AvatarUrl",
	"bio":                              "Description.Bio",
	"can_changed_pinned_items":         "Description.CanChangedPinnedItems",
	"can_create_projects":              "Description.CanCreateProjects",
	"can_follow":                       "Description.CanFollow",
	"can_sponsor":                      "Description.CanSponsor",
	"closed_pull_requests_total_count": "Description.ClosedPullRequestsTotalCount",
	"company":                          "Description.Company",
	"email":                            "Description.Email",
	"estimated_next_sponsors_payout_in_cents": "Description.EstimatedNextSponsorsPayoutInCents",
	"followers_total_count":                   "Description.FollowersTotalCount",
	"following_total_count":                   "Description.FollowingTotalCount",
	"has_sponsors_listing":                    "Description.HasSponsorsListing",
	"id":                                      "Description.Id",
	"interaction_ability":                     "Description.InteractionAbility",
	"is_bounty_hunter":                        "Description.IsBountyHunter",
	"is_campus_expert":                        "Description.IsCampusExpert",
	"is_developer_program_member":             "Description.IsDeveloperProgramMember",
	"is_employee":                             "Description.IsEmployee",
	"is_following":                            "Description.IsFollowing",
	"is_following_you":                        "Description.IsFollowingYou",
	"is_github_star":                          "Description.IsGitHubStar",
	"is_hireable":                             "Description.IsHireable",
	"is_site_admin":                           "Description.IsSiteAdmin",
	"is_sponsoring":                           "Description.IsSponsoring",
	"is_sponsoring_you":                       "Description.IsSponsoringYou",
	"is_you":                                  "Description.IsYou",
	"issues_total_count":                      "Description.IssuesTotalCount",
	"location":                                "Description.Location",
	"login":                                   "Description.Login",
	"merged_pull_requests_total_count":        "Description.MergedPullRequestsTotalCount",
	"monthly_estimated_sponsors_income_in_cents": "Description.MonthlyEstimatedSponsorsIncomeInCents",
	"name":                             "Description.Name",
	"node_id":                          "Description.NodeId",
	"open_pull_requests_total_count":   "Description.OpenPullRequestsTotalCount",
	"organizations_total_count":        "Description.OrganizationsTotalCount",
	"packages_total_count":             "Description.PackagesTotalCount",
	"pinned_items_remaining":           "Description.PinnedItemsRemaining",
	"pinned_items_total_count":         "Description.PinnedItemsTotalCount",
	"private_repositories_total_count": "Description.PrivateRepositoriesTotalCount",
	"projects_url":                     "Description.ProjectsUrl",
	"pronouns":                         "Description.Pronouns",
	"public_gists_total_count":         "Description.PublicGistsTotalCount",
	"public_keys_total_count":          "Description.PublicKeysTotalCount",
	"public_repositories_total_count":  "Description.PublicRepositoriesTotalCount",
	"repositories_total_disk_usage":    "Description.RepositoriesTotalDiskUsage",
	"sponsoring_total_count":           "Description.SponsoringTotalCount",
	"sponsors_listing":                 "Description.SponsorsListing",
	"sponsors_total_count":             "Description.SponsorsTotalCount",
	"starred_repositories_total_count": "Description.StarredRepositoriesTotalCount",
	"status":                           "Description.Status",
	"twitter_username":                 "Description.TwitterUsername",
	"url":                              "Description.Url",
	"watching_total_count":             "Description.WatchingTotalCount",
	"website_url":                      "Description.WebsiteUrl",
}

func ListUser(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListUser")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListUser NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListUser NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListUser GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListUser GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListUser GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewUserPaginator(essdk.BuildFilter(ctx, d.QueryContext, listUserFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListUser NewUserPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListUser paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getUserFilters = map[string]string{
	"any_pinnable_items":               "Description.AnyPinnableItems",
	"avatar_url":                       "Description.AvatarUrl",
	"bio":                              "Description.Bio",
	"can_changed_pinned_items":         "Description.CanChangedPinnedItems",
	"can_create_projects":              "Description.CanCreateProjects",
	"can_follow":                       "Description.CanFollow",
	"can_sponsor":                      "Description.CanSponsor",
	"closed_pull_requests_total_count": "Description.ClosedPullRequestsTotalCount",
	"company":                          "Description.Company",
	"email":                            "Description.Email",
	"estimated_next_sponsors_payout_in_cents": "Description.EstimatedNextSponsorsPayoutInCents",
	"followers_total_count":                   "Description.FollowersTotalCount",
	"following_total_count":                   "Description.FollowingTotalCount",
	"has_sponsors_listing":                    "Description.HasSponsorsListing",
	"id":                                      "Description.Id",
	"interaction_ability":                     "Description.InteractionAbility",
	"is_bounty_hunter":                        "Description.IsBountyHunter",
	"is_campus_expert":                        "Description.IsCampusExpert",
	"is_developer_program_member":             "Description.IsDeveloperProgramMember",
	"is_employee":                             "Description.IsEmployee",
	"is_following":                            "Description.IsFollowing",
	"is_following_you":                        "Description.IsFollowingYou",
	"is_github_star":                          "Description.IsGitHubStar",
	"is_hireable":                             "Description.IsHireable",
	"is_site_admin":                           "Description.IsSiteAdmin",
	"is_sponsoring":                           "Description.IsSponsoring",
	"is_sponsoring_you":                       "Description.IsSponsoringYou",
	"is_you":                                  "Description.IsYou",
	"issues_total_count":                      "Description.IssuesTotalCount",
	"location":                                "Description.Location",
	"login":                                   "Description.Login",
	"merged_pull_requests_total_count":        "Description.MergedPullRequestsTotalCount",
	"monthly_estimated_sponsors_income_in_cents": "Description.MonthlyEstimatedSponsorsIncomeInCents",
	"name":                             "Description.Name",
	"node_id":                          "Description.NodeId",
	"open_pull_requests_total_count":   "Description.OpenPullRequestsTotalCount",
	"organizations_total_count":        "Description.OrganizationsTotalCount",
	"packages_total_count":             "Description.PackagesTotalCount",
	"pinned_items_remaining":           "Description.PinnedItemsRemaining",
	"pinned_items_total_count":         "Description.PinnedItemsTotalCount",
	"private_repositories_total_count": "Description.PrivateRepositoriesTotalCount",
	"projects_url":                     "Description.ProjectsUrl",
	"pronouns":                         "Description.Pronouns",
	"public_gists_total_count":         "Description.PublicGistsTotalCount",
	"public_keys_total_count":          "Description.PublicKeysTotalCount",
	"public_repositories_total_count":  "Description.PublicRepositoriesTotalCount",
	"repositories_total_disk_usage":    "Description.RepositoriesTotalDiskUsage",
	"sponsoring_total_count":           "Description.SponsoringTotalCount",
	"sponsors_listing":                 "Description.SponsorsListing",
	"sponsors_total_count":             "Description.SponsorsTotalCount",
	"starred_repositories_total_count": "Description.StarredRepositoriesTotalCount",
	"status":                           "Description.Status",
	"twitter_username":                 "Description.TwitterUsername",
	"url":                              "Description.Url",
	"watching_total_count":             "Description.WatchingTotalCount",
	"website_url":                      "Description.WebsiteUrl",
}

func GetUser(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetUser")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewUserPaginator(essdk.BuildFilter(ctx, d.QueryContext, getUserFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: User =============================

// ==========================  START: Workflow =============================

type Workflow struct {
	ResourceID      string                     `json:"resource_id"`
	PlatformID      string                     `json:"platform_id"`
	Description     github.WorkflowDescription `json:"description"`
	Metadata        github.Metadata            `json:"metadata"`
	DescribedBy     string                     `json:"described_by"`
	ResourceType    string                     `json:"resource_type"`
	IntegrationType string                     `json:"integration_type"`
	IntegrationID   string                     `json:"integration_id"`
}

type WorkflowHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Workflow      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type WorkflowHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []WorkflowHit     `json:"hits"`
}

type WorkflowSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  WorkflowHits `json:"hits"`
}

type WorkflowPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWorkflowPaginator(filters []essdk.BoolFilter, limit *int64) (WorkflowPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "githubworkflow", filters, limit)
	if err != nil {
		return WorkflowPaginator{}, err
	}

	p := WorkflowPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WorkflowPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WorkflowPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p WorkflowPaginator) NextPage(ctx context.Context) ([]Workflow, error) {
	var response WorkflowSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Workflow
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWorkflowFilters = map[string]string{
	"badge_url":                  "Description.BadgeURL",
	"html_url":                   "Description.HTMLURL",
	"id":                         "Description.ID",
	"name":                       "Description.Name",
	"node_id":                    "Description.NodeID",
	"path":                       "Description.Path",
	"pipeline":                   "Description.Pipeline",
	"repository_full_name":       "Description.RepositoryFullName",
	"state":                      "Description.State",
	"url":                        "Description.State",
	"workflow_file_content":      "Description.WorkFlowFileContent",
	"workflow_file_content_json": "Description.WorkFlowFileContentJson",
}

func ListWorkflow(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWorkflow")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkflow NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkflow NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkflow GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkflow GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkflow GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewWorkflowPaginator(essdk.BuildFilter(ctx, d.QueryContext, listWorkflowFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkflow NewWorkflowPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListWorkflow paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getWorkflowFilters = map[string]string{
	"badge_url":                  "Description.BadgeURL",
	"html_url":                   "Description.HTMLURL",
	"id":                         "Description.ID",
	"name":                       "Description.Name",
	"node_id":                    "Description.NodeID",
	"path":                       "Description.Path",
	"pipeline":                   "Description.Pipeline",
	"repository_full_name":       "Description.RepositoryFullName",
	"state":                      "Description.State",
	"url":                        "Description.State",
	"workflow_file_content":      "Description.WorkFlowFileContent",
	"workflow_file_content_json": "Description.WorkFlowFileContentJson",
}

func GetWorkflow(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWorkflow")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewWorkflowPaginator(essdk.BuildFilter(ctx, d.QueryContext, getWorkflowFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Workflow =============================

// ==========================  START: CodeOwner =============================

type CodeOwner struct {
	ResourceID      string                      `json:"resource_id"`
	PlatformID      string                      `json:"platform_id"`
	Description     github.CodeOwnerDescription `json:"description"`
	Metadata        github.Metadata             `json:"metadata"`
	DescribedBy     string                      `json:"described_by"`
	ResourceType    string                      `json:"resource_type"`
	IntegrationType string                      `json:"integration_type"`
	IntegrationID   string                      `json:"integration_id"`
}

type CodeOwnerHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  CodeOwner     `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type CodeOwnerHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []CodeOwnerHit    `json:"hits"`
}

type CodeOwnerSearchResponse struct {
	PitID string        `json:"pit_id"`
	Hits  CodeOwnerHits `json:"hits"`
}

type CodeOwnerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCodeOwnerPaginator(filters []essdk.BoolFilter, limit *int64) (CodeOwnerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "github_codeowner", filters, limit)
	if err != nil {
		return CodeOwnerPaginator{}, err
	}

	p := CodeOwnerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CodeOwnerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CodeOwnerPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CodeOwnerPaginator) NextPage(ctx context.Context) ([]CodeOwner, error) {
	var response CodeOwnerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CodeOwner
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCodeOwnerFilters = map[string]string{
	"line": "LineNumber",
}

func ListCodeOwner(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCodeOwner")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeOwner NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeOwner NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeOwner GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeOwner GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeOwner GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCodeOwnerPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCodeOwnerFilters, "github", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeOwner NewCodeOwnerPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCodeOwner paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCodeOwnerFilters = map[string]string{
	"line": "LineNumber",
}

func GetCodeOwner(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCodeOwner")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCodeOwnerPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCodeOwnerFilters, "github", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CodeOwner =============================
